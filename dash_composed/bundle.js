this["dash_composed"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/lib/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ReactComponent = exports.ExampleComponent = undefined;
	
	var _ExampleComponent = __webpack_require__(/*! ./components/ExampleComponent.react */ 1);
	
	var ExampleComponent = _interopRequireDefault(_ExampleComponent).default;
	
	var _ReactComponent = __webpack_require__(/*! ./components/ReactComponent.react */ 11);
	
	var ReactComponent = _interopRequireDefault(_ReactComponent).default;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable import/prefer-default-export */
	exports.ExampleComponent = ExampleComponent;
	exports.ReactComponent = ReactComponent;

/***/ },
/* 1 */
/*!**********************************************!*\
  !*** ./components/ExampleComponent.react.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(/*! react */ 2);
	
	var React = _interopRequireDefault(_react).default;
	
	var Component = _react.Component;
	
	var _propTypes = __webpack_require__(/*! prop-types */ 3);
	
	var PropTypes = _interopRequireDefault(_propTypes).default;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * ExampleComponent is an example component.
	 * It takes a property, `label`, and
	 * displays it.
	 * It renders an input with the property `value`
	 * which is editable by the user.
	 */
	var ExampleComponent = function (_Component) {
	    _inherits(ExampleComponent, _Component);
	
	    function ExampleComponent() {
	        _classCallCheck(this, ExampleComponent);
	
	        return _possibleConstructorReturn(this, (ExampleComponent.__proto__ || Object.getPrototypeOf(ExampleComponent)).apply(this, arguments));
	    }
	
	    _createClass(ExampleComponent, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                id = _props.id,
	                label = _props.label,
	                setProps = _props.setProps,
	                value = _props.value;
	
	
	            return React.createElement(
	                'div',
	                { id: id },
	                'ExampleComponent: ',
	                label,
	                React.createElement('input', {
	                    value: value,
	                    onChange: function onChange(e) {
	                        /*
	                         * Send the new value to the parent component.
	                         * In a Dash app, this will send the data back to the
	                         * Python Dash app server.
	                         */
	                        if (setProps) {
	                            setProps({
	                                value: e.target.value
	                            });
	                        }
	                    }
	                })
	            );
	        }
	    }]);
	
	    return ExampleComponent;
	}(Component);
	
	exports.default = ExampleComponent;
	
	
	ExampleComponent.propTypes = {
	    /**
	     * The ID used to identify this compnent in Dash callbacks
	     */
	    id: PropTypes.string,
	
	    /**
	     * A label that will be printed when this component is rendered.
	     */
	    label: PropTypes.string.isRequired,
	
	    /**
	     * The value displayed in the input
	     */
	    value: PropTypes.string,
	
	    /**
	     * Dash-assigned callback that should be called whenever any of the
	     * properties change
	     */
	    setProps: PropTypes.func
	};

/***/ },
/* 2 */
/*!************************!*\
  !*** external "React" ***!
  \************************/
/***/ function(module, exports) {

	(function() { module.exports = this["React"]; }());

/***/ },
/* 3 */
/*!************************************************************************!*\
  !*** ../~/.registry.npmjs.org/prop-types/15.6.1/~/prop-types/index.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	if (true) {
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;
	
	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };
	
	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ 4)(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = require('./factoryWithThrowingShims')();
	}


/***/ },
/* 4 */
/*!******************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/prop-types/15.6.1/~/prop-types/factoryWithTypeCheckers.js ***!
  \******************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ 5);
	var invariant = __webpack_require__(/*! fbjs/lib/invariant */ 6);
	var warning = __webpack_require__(/*! fbjs/lib/warning */ 7);
	var assign = __webpack_require__(/*! object-assign */ 8);
	
	var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ 9);
	var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ 10);
	
	module.exports = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */
	
	  var ANONYMOUS = '<<anonymous>>';
	
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),
	
	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };
	
	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/
	
	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;
	
	  function createChainableTypeChecker(validate) {
	    if (true) {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;
	
	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant(
	            false,
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	        } else if (("development") !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            warning(
	              false,
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `%s` prop on `%s`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
	              propFullName,
	              componentName
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }
	
	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);
	
	    return chainedCheckType;
	  }
	
	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);
	
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	  }
	
	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }
	
	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }
	
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        warning(
	          false,
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received %s at index %s.',
	          getPostfixForTypeWarning(checker),
	          i
	        );
	        return emptyFunction.thatReturnsNull;
	      }
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }
	
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from
	      // props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	
	    return createChainableTypeChecker(validate);
	  }
	
	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }
	
	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }
	
	        return true;
	      default:
	        return false;
	    }
	  }
	
	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }
	
	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }
	
	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }
	
	    return false;
	  }
	
	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }
	
	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }
	
	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }
	
	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }
	
	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};


/***/ },
/* 5 */
/*!************************************************************************!*\
  !*** ../~/.registry.npmjs.org/fbjs/0.8.16/~/fbjs/lib/emptyFunction.js ***!
  \************************************************************************/
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 6 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/fbjs/0.8.16/~/fbjs/lib/invariant.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var validateFormat = function validateFormat(format) {};
	
	if (true) {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;

/***/ },
/* 7 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/fbjs/0.8.16/~/fbjs/lib/warning.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(/*! ./emptyFunction */ 5);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (true) {
	  var printWarning = function printWarning(format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	
	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	
	  warning = function warning(condition, format) {
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }
	
	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}
	
	module.exports = warning;

/***/ },
/* 8 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/object-assign/4.1.1/~/object-assign/index.js ***!
  \*****************************************************************************/
/***/ function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 9 */
/*!*******************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/prop-types/15.6.1/~/prop-types/lib/ReactPropTypesSecret.js ***!
  \*******************************************************************************************/
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;


/***/ },
/* 10 */
/*!*********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/prop-types/15.6.1/~/prop-types/checkPropTypes.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	if (true) {
	  var invariant = __webpack_require__(/*! fbjs/lib/invariant */ 6);
	  var warning = __webpack_require__(/*! fbjs/lib/warning */ 7);
	  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ 9);
	  var loggedTypeFailures = {};
	}
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (true) {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;
	
	          var stack = getStack ? getStack() : '';
	
	          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}
	
	module.exports = checkPropTypes;


/***/ },
/* 11 */
/*!********************************************!*\
  !*** ./components/ReactComponent.react.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(/*! react */ 2);
	
	var React = _interopRequireDefault(_react).default;
	
	var Component = _react.Component;
	
	var _propTypes = __webpack_require__(/*! prop-types */ 3);
	
	var PropTypes = _interopRequireDefault(_propTypes).default;
	
	var _transpile = __webpack_require__(/*! ../transpile */ 12);
	
	var generateElement = _transpile.generateElement;
	var renderElementAsync = _transpile.renderElementAsync;
	
	var _ramda = __webpack_require__(/*! ramda */ 23);
	
	var all = _ramda.all;
	var equals = _ramda.equals;
	var omit = _ramda.omit;
	var without = _ramda.without;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var basicType = PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool, PropTypes.object, PropTypes.array]);
	
	var ReactComponent = function (_Component) {
	  _inherits(ReactComponent, _Component);
	
	  function ReactComponent(props) {
	    _classCallCheck(this, ReactComponent);
	
	    var _this = _possibleConstructorReturn(this, (ReactComponent.__proto__ || Object.getPrototypeOf(ReactComponent)).call(this));
	
	    _this.state = { code: props.code };
	    _this.setProps = _this.setProps.bind(_this);
	    return _this;
	  }
	
	  _createClass(ReactComponent, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;
	
	      var _props = this.props,
	          code = _props.code,
	          scope = _props.scope,
	          noInline = _props.noInline;
	
	      // Transpilation arguments
	
	      var input = { code: code, scope: scope };
	
	      var errorCallback = function errorCallback(err) {
	        return _this2.setState({ element: undefined, error: err.toString() });
	      };
	      var renderElement = function renderElement(element) {
	        return _this2.setState({ element: element });
	      };
	
	      // State reset object
	      var state = { unsafeWrapperError: undefined, error: undefined };
	
	      try {
	        if (noInline) {
	          this.setState(_extends({}, state, { element: null })); // Reset output for async (no inline) evaluation
	          renderElementAsync(input, renderElement, errorCallback);
	        } else {
	          renderElement(generateElement(input, errorCallback));
	        }
	      } catch (error) {
	        this.setState(_extends({}, state, { error: error.toString() }));
	      }
	    }
	  }, {
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps, nextState) {
	      var _this3 = this;
	
	      var isPropEqual = function isPropEqual(key) {
	        return equals(_this3.props[key], nextProps[key]);
	      };
	      var propsToCheck = without(this.props.ignoredProps, [
	      // 'scope', 'code', 
	      "containerProps", "elementProps", "options", "layout", "data", "data2", "value", "value2"]);
	      console.log(this.props.id);
	
	      if (equals(nextState, this.state) && all(isPropEqual)(propsToCheck)) {
	        return false;
	      }
	
	      return true;
	    }
	  }, {
	    key: 'setProps',
	    value: function setProps(newProps) {
	      if (this.props.setProps) {
	        this.props.setProps(newProps);
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      if (this.state.error) {
	        console.error(this.state.error);
	      }
	
	      var _props2 = this.props,
	          id = _props2.id,
	          containerEl = _props2.containerEl,
	          containerProps = _props2.containerProps,
	          elementProps = _props2.elementProps,
	          options = _props2.options,
	          layout = _props2.layout,
	          data = _props2.data,
	          data2 = _props2.data2,
	          value = _props2.value,
	          value2 = _props2.value2;
	
	      var setProps = this.setProps;
	
	      var El = containerEl || 'div';
	      var Element = this.state.element;
	
	      return React.createElement(
	        El,
	        _extends({ id: id }, containerProps),
	        Element && React.createElement(Element, _extends({}, elementProps, {
	          options: options, layout: layout, data: data, data2: data2, value: value, value2: value2, setProps: setProps
	        }))
	      );
	    }
	  }]);
	
	  return ReactComponent;
	}(Component);
	
	ReactComponent.propTypes = {
	  /*The ID used to identify this compnent in Dash callbacks */
	  id: PropTypes.string,
	
	  code: PropTypes.string.isRequired,
	  scope: PropTypes.object,
	  noInline: PropTypes.bool,
	
	  containerEl: PropTypes.string,
	  containerProps: PropTypes.object,
	  elementProps: PropTypes.object,
	  ignoredProps: PropTypes.array,
	
	  /**
	   * Dash-assigned callback that should be called whenever any of the
	   * following properties change
	   */
	  setProps: PropTypes.func,
	
	  options: basicType,
	  layout: basicType,
	  data: basicType,
	  data2: basicType,
	  value: basicType,
	  value2: basicType
	
	};
	ReactComponent.defaultProps = {
	  scope: {},
	  noInline: false,
	
	  containerEl: 'div',
	  elementProps: {},
	  containerProps: {},
	  ignoredProps: [],
	
	  options: {},
	  layout: {},
	  data: {},
	  data2: {},
	  value: "",
	  value2: ""
	};
	exports.default = ReactComponent;

/***/ },
/* 12 */
/*!****************************!*\
  !*** ./transpile/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.renderElementAsync = exports.generateElement = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _transform = __webpack_require__(/*! ./transform */ 13);
	
	var transform = _interopRequireDefault(_transform).default;
	
	var _errorBoundary = __webpack_require__(/*! ./errorBoundary */ 342);
	
	var errorBoundary = _interopRequireDefault(_errorBoundary).default;
	
	var _evalCode = __webpack_require__(/*! ./evalCode */ 343);
	
	var evalCode = _interopRequireDefault(_evalCode).default;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var generateElement = exports.generateElement = function generateElement(_ref, errorCallback) {
	  var _ref$code = _ref.code,
	      code = _ref$code === undefined ? '' : _ref$code,
	      _ref$scope = _ref.scope,
	      scope = _ref$scope === undefined ? {} : _ref$scope;
	
	  // NOTE: Remove trailing semicolon to get an actual expression.
	  var codeTrimmed = code.trim().replace(/;$/, '');
	
	  // NOTE: Workaround for classes and arrow functions.
	  var transformed = transform('(' + codeTrimmed + ')').trim();
	
	  return errorBoundary(evalCode('return ' + transformed, scope), errorCallback);
	};
	
	var renderElementAsync = exports.renderElementAsync = function renderElementAsync(_ref2, resultCallback, errorCallback) {
	  var _ref2$code = _ref2.code,
	      code = _ref2$code === undefined ? '' : _ref2$code,
	      _ref2$scope = _ref2.scope,
	      scope = _ref2$scope === undefined ? {} : _ref2$scope;
	
	  var render = function render(element) {
	    resultCallback(errorBoundary(element, errorCallback));
	  };
	
	  if (!/render\s*\(/.test(code)) {
	    return errorCallback(new SyntaxError('No-Inline evaluations must call `render`.'));
	  }
	
	  evalCode(transform(code), _extends({}, scope, { render: render }));
	};

/***/ },
/* 13 */
/*!********************************!*\
  !*** ./transpile/transform.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _buble = __webpack_require__(/*! buble */ 14);
	
	var _transform = _buble.transform;
	
	__webpack_require__(/*! ramda */ 23);
	
	// export const _poly = { assign }
	
	/*
	For my purposes, I don't need the object assign polyfill
	*/
	var opts = {
	  // objectAssign: '_poly.assign',
	  transforms: {
	    dangerousForOf: true,
	    dangerousTaggedTemplateString: true
	  }
	};
	// import assign from 'core-js/fn/object/assign'
	
	exports.default = function (code) {
	  return _transform(code, opts).code;
	};

/***/ },
/* 14 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/buble/0.19.3/~/buble/dist/buble-browser.cjs.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
	
	var MagicString = _interopDefault(__webpack_require__(/*! magic-string */ 15));
	var acorn = __webpack_require__(/*! acorn */ 22);
	
	var xhtml = {
	  quot: '\u0022',
	  amp: '&',
	  apos: '\u0027',
	  lt: '<',
	  gt: '>',
	  nbsp: '\u00A0',
	  iexcl: '\u00A1',
	  cent: '\u00A2',
	  pound: '\u00A3',
	  curren: '\u00A4',
	  yen: '\u00A5',
	  brvbar: '\u00A6',
	  sect: '\u00A7',
	  uml: '\u00A8',
	  copy: '\u00A9',
	  ordf: '\u00AA',
	  laquo: '\u00AB',
	  not: '\u00AC',
	  shy: '\u00AD',
	  reg: '\u00AE',
	  macr: '\u00AF',
	  deg: '\u00B0',
	  plusmn: '\u00B1',
	  sup2: '\u00B2',
	  sup3: '\u00B3',
	  acute: '\u00B4',
	  micro: '\u00B5',
	  para: '\u00B6',
	  middot: '\u00B7',
	  cedil: '\u00B8',
	  sup1: '\u00B9',
	  ordm: '\u00BA',
	  raquo: '\u00BB',
	  frac14: '\u00BC',
	  frac12: '\u00BD',
	  frac34: '\u00BE',
	  iquest: '\u00BF',
	  Agrave: '\u00C0',
	  Aacute: '\u00C1',
	  Acirc: '\u00C2',
	  Atilde: '\u00C3',
	  Auml: '\u00C4',
	  Aring: '\u00C5',
	  AElig: '\u00C6',
	  Ccedil: '\u00C7',
	  Egrave: '\u00C8',
	  Eacute: '\u00C9',
	  Ecirc: '\u00CA',
	  Euml: '\u00CB',
	  Igrave: '\u00CC',
	  Iacute: '\u00CD',
	  Icirc: '\u00CE',
	  Iuml: '\u00CF',
	  ETH: '\u00D0',
	  Ntilde: '\u00D1',
	  Ograve: '\u00D2',
	  Oacute: '\u00D3',
	  Ocirc: '\u00D4',
	  Otilde: '\u00D5',
	  Ouml: '\u00D6',
	  times: '\u00D7',
	  Oslash: '\u00D8',
	  Ugrave: '\u00D9',
	  Uacute: '\u00DA',
	  Ucirc: '\u00DB',
	  Uuml: '\u00DC',
	  Yacute: '\u00DD',
	  THORN: '\u00DE',
	  szlig: '\u00DF',
	  agrave: '\u00E0',
	  aacute: '\u00E1',
	  acirc: '\u00E2',
	  atilde: '\u00E3',
	  auml: '\u00E4',
	  aring: '\u00E5',
	  aelig: '\u00E6',
	  ccedil: '\u00E7',
	  egrave: '\u00E8',
	  eacute: '\u00E9',
	  ecirc: '\u00EA',
	  euml: '\u00EB',
	  igrave: '\u00EC',
	  iacute: '\u00ED',
	  icirc: '\u00EE',
	  iuml: '\u00EF',
	  eth: '\u00F0',
	  ntilde: '\u00F1',
	  ograve: '\u00F2',
	  oacute: '\u00F3',
	  ocirc: '\u00F4',
	  otilde: '\u00F5',
	  ouml: '\u00F6',
	  divide: '\u00F7',
	  oslash: '\u00F8',
	  ugrave: '\u00F9',
	  uacute: '\u00FA',
	  ucirc: '\u00FB',
	  uuml: '\u00FC',
	  yacute: '\u00FD',
	  thorn: '\u00FE',
	  yuml: '\u00FF',
	  OElig: '\u0152',
	  oelig: '\u0153',
	  Scaron: '\u0160',
	  scaron: '\u0161',
	  Yuml: '\u0178',
	  fnof: '\u0192',
	  circ: '\u02C6',
	  tilde: '\u02DC',
	  Alpha: '\u0391',
	  Beta: '\u0392',
	  Gamma: '\u0393',
	  Delta: '\u0394',
	  Epsilon: '\u0395',
	  Zeta: '\u0396',
	  Eta: '\u0397',
	  Theta: '\u0398',
	  Iota: '\u0399',
	  Kappa: '\u039A',
	  Lambda: '\u039B',
	  Mu: '\u039C',
	  Nu: '\u039D',
	  Xi: '\u039E',
	  Omicron: '\u039F',
	  Pi: '\u03A0',
	  Rho: '\u03A1',
	  Sigma: '\u03A3',
	  Tau: '\u03A4',
	  Upsilon: '\u03A5',
	  Phi: '\u03A6',
	  Chi: '\u03A7',
	  Psi: '\u03A8',
	  Omega: '\u03A9',
	  alpha: '\u03B1',
	  beta: '\u03B2',
	  gamma: '\u03B3',
	  delta: '\u03B4',
	  epsilon: '\u03B5',
	  zeta: '\u03B6',
	  eta: '\u03B7',
	  theta: '\u03B8',
	  iota: '\u03B9',
	  kappa: '\u03BA',
	  lambda: '\u03BB',
	  mu: '\u03BC',
	  nu: '\u03BD',
	  xi: '\u03BE',
	  omicron: '\u03BF',
	  pi: '\u03C0',
	  rho: '\u03C1',
	  sigmaf: '\u03C2',
	  sigma: '\u03C3',
	  tau: '\u03C4',
	  upsilon: '\u03C5',
	  phi: '\u03C6',
	  chi: '\u03C7',
	  psi: '\u03C8',
	  omega: '\u03C9',
	  thetasym: '\u03D1',
	  upsih: '\u03D2',
	  piv: '\u03D6',
	  ensp: '\u2002',
	  emsp: '\u2003',
	  thinsp: '\u2009',
	  zwnj: '\u200C',
	  zwj: '\u200D',
	  lrm: '\u200E',
	  rlm: '\u200F',
	  ndash: '\u2013',
	  mdash: '\u2014',
	  lsquo: '\u2018',
	  rsquo: '\u2019',
	  sbquo: '\u201A',
	  ldquo: '\u201C',
	  rdquo: '\u201D',
	  bdquo: '\u201E',
	  dagger: '\u2020',
	  Dagger: '\u2021',
	  bull: '\u2022',
	  hellip: '\u2026',
	  permil: '\u2030',
	  prime: '\u2032',
	  Prime: '\u2033',
	  lsaquo: '\u2039',
	  rsaquo: '\u203A',
	  oline: '\u203E',
	  frasl: '\u2044',
	  euro: '\u20AC',
	  image: '\u2111',
	  weierp: '\u2118',
	  real: '\u211C',
	  trade: '\u2122',
	  alefsym: '\u2135',
	  larr: '\u2190',
	  uarr: '\u2191',
	  rarr: '\u2192',
	  darr: '\u2193',
	  harr: '\u2194',
	  crarr: '\u21B5',
	  lArr: '\u21D0',
	  uArr: '\u21D1',
	  rArr: '\u21D2',
	  dArr: '\u21D3',
	  hArr: '\u21D4',
	  forall: '\u2200',
	  part: '\u2202',
	  exist: '\u2203',
	  empty: '\u2205',
	  nabla: '\u2207',
	  isin: '\u2208',
	  notin: '\u2209',
	  ni: '\u220B',
	  prod: '\u220F',
	  sum: '\u2211',
	  minus: '\u2212',
	  lowast: '\u2217',
	  radic: '\u221A',
	  prop: '\u221D',
	  infin: '\u221E',
	  ang: '\u2220',
	  and: '\u2227',
	  or: '\u2228',
	  cap: '\u2229',
	  cup: '\u222A',
	  'int': '\u222B',
	  there4: '\u2234',
	  sim: '\u223C',
	  cong: '\u2245',
	  asymp: '\u2248',
	  ne: '\u2260',
	  equiv: '\u2261',
	  le: '\u2264',
	  ge: '\u2265',
	  sub: '\u2282',
	  sup: '\u2283',
	  nsub: '\u2284',
	  sube: '\u2286',
	  supe: '\u2287',
	  oplus: '\u2295',
	  otimes: '\u2297',
	  perp: '\u22A5',
	  sdot: '\u22C5',
	  lceil: '\u2308',
	  rceil: '\u2309',
	  lfloor: '\u230A',
	  rfloor: '\u230B',
	  lang: '\u2329',
	  rang: '\u232A',
	  loz: '\u25CA',
	  spades: '\u2660',
	  clubs: '\u2663',
	  hearts: '\u2665',
	  diams: '\u2666'
	};
	
	var hexNumber = /^[\da-fA-F]+$/;
	var decimalNumber = /^\d+$/;
	
	var inject = function(acorn$$1) {
	  var tt = acorn$$1.tokTypes;
	  var tc = acorn$$1.tokContexts;
	
	  tc.j_oTag = new acorn$$1.TokContext('<tag', false);
	  tc.j_cTag = new acorn$$1.TokContext('</tag', false);
	  tc.j_expr = new acorn$$1.TokContext('<tag>...</tag>', true, true);
	
	  tt.jsxName = new acorn$$1.TokenType('jsxName');
	  tt.jsxText = new acorn$$1.TokenType('jsxText', {beforeExpr: true});
	  tt.jsxTagStart = new acorn$$1.TokenType('jsxTagStart');
	  tt.jsxTagEnd = new acorn$$1.TokenType('jsxTagEnd');
	
	  tt.jsxTagStart.updateContext = function() {
	    this.context.push(tc.j_expr); // treat as beginning of JSX expression
	    this.context.push(tc.j_oTag); // start opening tag context
	    this.exprAllowed = false;
	  };
	  tt.jsxTagEnd.updateContext = function(prevType) {
	    var out = this.context.pop();
	    if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {
	      this.context.pop();
	      this.exprAllowed = this.curContext() === tc.j_expr;
	    } else {
	      this.exprAllowed = true;
	    }
	  };
	
	  var pp = acorn$$1.Parser.prototype;
	
	  // Reads inline JSX contents token.
	
	  pp.jsx_readToken = function() {
	    var out = '', chunkStart = this.pos;
	    for (;;) {
	      if (this.pos >= this.input.length)
	        this.raise(this.start, 'Unterminated JSX contents');
	      var ch = this.input.charCodeAt(this.pos);
	
	      switch (ch) {
	      case 60: // '<'
	      case 123: // '{'
	        if (this.pos === this.start) {
	          if (ch === 60 && this.exprAllowed) {
	            ++this.pos;
	            return this.finishToken(tt.jsxTagStart);
	          }
	          return this.getTokenFromCode(ch);
	        }
	        out += this.input.slice(chunkStart, this.pos);
	        return this.finishToken(tt.jsxText, out);
	
	      case 38: // '&'
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readEntity();
	        chunkStart = this.pos;
	        break;
	
	      default:
	        if (acorn$$1.isNewLine(ch)) {
	          out += this.input.slice(chunkStart, this.pos);
	          out += this.jsx_readNewLine(true);
	          chunkStart = this.pos;
	        } else {
	          ++this.pos;
	        }
	      }
	    }
	  };
	
	  pp.jsx_readNewLine = function(normalizeCRLF) {
	    var ch = this.input.charCodeAt(this.pos);
	    var out;
	    ++this.pos;
	    if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
	      ++this.pos;
	      out = normalizeCRLF ? '\n' : '\r\n';
	    } else {
	      out = String.fromCharCode(ch);
	    }
	    if (this.options.locations) {
	      ++this.curLine;
	      this.lineStart = this.pos;
	    }
	
	    return out;
	  };
	
	  pp.jsx_readString = function(quote) {
	    var out = '', chunkStart = ++this.pos;
	    for (;;) {
	      if (this.pos >= this.input.length)
	        this.raise(this.start, 'Unterminated string constant');
	      var ch = this.input.charCodeAt(this.pos);
	      if (ch === quote) break;
	      if (ch === 38) { // '&'
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readEntity();
	        chunkStart = this.pos;
	      } else if (acorn$$1.isNewLine(ch)) {
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readNewLine(false);
	        chunkStart = this.pos;
	      } else {
	        ++this.pos;
	      }
	    }
	    out += this.input.slice(chunkStart, this.pos++);
	    return this.finishToken(tt.string, out);
	  };
	
	  pp.jsx_readEntity = function() {
	    var str = '', count = 0, entity;
	    var ch = this.input[this.pos];
	    if (ch !== '&')
	      this.raise(this.pos, 'Entity must start with an ampersand');
	    var startPos = ++this.pos;
	    while (this.pos < this.input.length && count++ < 10) {
	      ch = this.input[this.pos++];
	      if (ch === ';') {
	        if (str[0] === '#') {
	          if (str[1] === 'x') {
	            str = str.substr(2);
	            if (hexNumber.test(str))
	              entity = String.fromCharCode(parseInt(str, 16));
	          } else {
	            str = str.substr(1);
	            if (decimalNumber.test(str))
	              entity = String.fromCharCode(parseInt(str, 10));
	          }
	        } else {
	          entity = xhtml[str];
	        }
	        break;
	      }
	      str += ch;
	    }
	    if (!entity) {
	      this.pos = startPos;
	      return '&';
	    }
	    return entity;
	  };
	
	
	  // Read a JSX identifier (valid tag or attribute name).
	  //
	  // Optimized version since JSX identifiers can't contain
	  // escape characters and so can be read as single slice.
	  // Also assumes that first character was already checked
	  // by isIdentifierStart in readToken.
	
	  pp.jsx_readWord = function() {
	    var ch, start = this.pos;
	    do {
	      ch = this.input.charCodeAt(++this.pos);
	    } while (acorn$$1.isIdentifierChar(ch) || ch === 45); // '-'
	    return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));
	  };
	
	  // Transforms JSX element name to string.
	
	  function getQualifiedJSXName(object) {
	    if (!object)
	      return object;
	
	    if (object.type === 'JSXIdentifier')
	      return object.name;
	
	    if (object.type === 'JSXNamespacedName')
	      return object.namespace.name + ':' + object.name.name;
	
	    if (object.type === 'JSXMemberExpression')
	      return getQualifiedJSXName(object.object) + '.' +
	      getQualifiedJSXName(object.property);
	  }
	
	  // Parse next token as JSX identifier
	
	  pp.jsx_parseIdentifier = function() {
	    var node = this.startNode();
	    if (this.type === tt.jsxName)
	      node.name = this.value;
	    else if (this.type.keyword)
	      node.name = this.type.keyword;
	    else
	      this.unexpected();
	    this.next();
	    return this.finishNode(node, 'JSXIdentifier');
	  };
	
	  // Parse namespaced identifier.
	
	  pp.jsx_parseNamespacedName = function() {
	    var startPos = this.start, startLoc = this.startLoc;
	    var name = this.jsx_parseIdentifier();
	    if (!this.options.plugins.jsx.allowNamespaces || !this.eat(tt.colon)) return name;
	    var node = this.startNodeAt(startPos, startLoc);
	    node.namespace = name;
	    node.name = this.jsx_parseIdentifier();
	    return this.finishNode(node, 'JSXNamespacedName');
	  };
	
	  // Parses element name in any form - namespaced, member
	  // or single identifier.
	
	  pp.jsx_parseElementName = function() {
	    if (this.type === tt.jsxTagEnd)
	      return '';
	    var startPos = this.start, startLoc = this.startLoc;
	    var node = this.jsx_parseNamespacedName();
	    if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !this.options.plugins.jsx.allowNamespacedObjects) {
	      this.unexpected();
	    }
	    while (this.eat(tt.dot)) {
	      var newNode = this.startNodeAt(startPos, startLoc);
	      newNode.object = node;
	      newNode.property = this.jsx_parseIdentifier();
	      node = this.finishNode(newNode, 'JSXMemberExpression');
	    }
	    return node;
	  };
	
	  // Parses any type of JSX attribute value.
	
	  pp.jsx_parseAttributeValue = function() {
	    switch (this.type) {
	    case tt.braceL:
	      var node = this.jsx_parseExpressionContainer();
	      if (node.expression.type === 'JSXEmptyExpression')
	        this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
	      return node;
	
	    case tt.jsxTagStart:
	    case tt.string:
	      return this.parseExprAtom();
	
	    default:
	      this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
	    }
	  };
	
	  // JSXEmptyExpression is unique type since it doesn't actually parse anything,
	  // and so it should start at the end of last read token (left brace) and finish
	  // at the beginning of the next one (right brace).
	
	  pp.jsx_parseEmptyExpression = function() {
	    var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
	    return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
	  };
	
	  // Parses JSX expression enclosed into curly brackets.
	
	
	  pp.jsx_parseExpressionContainer = function() {
	    var node = this.startNode();
	    this.next();
	    node.expression = this.type === tt.braceR
	      ? this.jsx_parseEmptyExpression()
	      : this.parseExpression();
	    this.expect(tt.braceR);
	    return this.finishNode(node, 'JSXExpressionContainer');
	  };
	
	  // Parses following JSX attribute name-value pair.
	
	  pp.jsx_parseAttribute = function() {
	    var node = this.startNode();
	    if (this.eat(tt.braceL)) {
	      this.expect(tt.ellipsis);
	      node.argument = this.parseMaybeAssign();
	      this.expect(tt.braceR);
	      return this.finishNode(node, 'JSXSpreadAttribute');
	    }
	    node.name = this.jsx_parseNamespacedName();
	    node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
	    return this.finishNode(node, 'JSXAttribute');
	  };
	
	  // Parses JSX opening tag starting after '<'.
	
	  pp.jsx_parseOpeningElementAt = function(startPos, startLoc) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.attributes = [];
	    var nodeName = this.jsx_parseElementName();
	    if (nodeName) node.name = nodeName;
	    while (this.type !== tt.slash && this.type !== tt.jsxTagEnd)
	      node.attributes.push(this.jsx_parseAttribute());
	    node.selfClosing = this.eat(tt.slash);
	    this.expect(tt.jsxTagEnd);
	    return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');
	  };
	
	  // Parses JSX closing tag starting after '</'.
	
	  pp.jsx_parseClosingElementAt = function(startPos, startLoc) {
	    var node = this.startNodeAt(startPos, startLoc);
	    var nodeName = this.jsx_parseElementName();
	    if (nodeName) node.name = nodeName;
	    this.expect(tt.jsxTagEnd);
	    return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');
	  };
	
	  // Parses entire JSX element, including it's opening tag
	  // (starting after '<'), attributes, contents and closing tag.
	
	  pp.jsx_parseElementAt = function(startPos, startLoc) {
	    var node = this.startNodeAt(startPos, startLoc);
	    var children = [];
	    var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
	    var closingElement = null;
	
	    if (!openingElement.selfClosing) {
	      contents: for (;;) {
	        switch (this.type) {
	        case tt.jsxTagStart:
	          startPos = this.start; startLoc = this.startLoc;
	          this.next();
	          if (this.eat(tt.slash)) {
	            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
	            break contents;
	          }
	          children.push(this.jsx_parseElementAt(startPos, startLoc));
	          break;
	
	        case tt.jsxText:
	          children.push(this.parseExprAtom());
	          break;
	
	        case tt.braceL:
	          children.push(this.jsx_parseExpressionContainer());
	          break;
	
	        default:
	          this.unexpected();
	        }
	      }
	      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
	        this.raise(
	          closingElement.start,
	          'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
	      }
	    }
	
	    node.openingElement = openingElement;
	    node.closingElement = closingElement;
	    node.children = children;
	    if (this.type === tt.relational && this.value === "<") {
	      this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
	    }
	    return this.finishNode(node, openingElement.name ? 'JSXElement' : 'JSXFragment');
	  };
	
	  // Parse JSX text
	
	  pp.jsx_parseText = function(value) {
	    var node = this.parseLiteral(value);
	    node.type = "JSXText";
	
	    return node;
	  };
	
	  // Parses entire JSX element from current position.
	
	  pp.jsx_parseElement = function() {
	    var startPos = this.start, startLoc = this.startLoc;
	    this.next();
	    return this.jsx_parseElementAt(startPos, startLoc);
	  };
	
	  acorn$$1.plugins.jsx = function(instance, opts) {
	    if (!opts) {
	      return;
	    }
	
	    if (typeof opts !== 'object') {
	      opts = {};
	    }
	
	    instance.options.plugins.jsx = {
	      allowNamespaces: opts.allowNamespaces !== false,
	      allowNamespacedObjects: !!opts.allowNamespacedObjects
	    };
	
	    instance.extend('parseExprAtom', function(inner) {
	      return function(refShortHandDefaultPos) {
	        if (this.type === tt.jsxText)
	          return this.jsx_parseText(this.value);
	        else if (this.type === tt.jsxTagStart)
	          return this.jsx_parseElement();
	        else
	          return inner.call(this, refShortHandDefaultPos);
	      };
	    });
	
	    instance.extend('readToken', function(inner) {
	      return function(code) {
	        var context = this.curContext();
	
	        if (context === tc.j_expr) return this.jsx_readToken();
	
	        if (context === tc.j_oTag || context === tc.j_cTag) {
	          if (acorn$$1.isIdentifierStart(code)) return this.jsx_readWord();
	
	          if (code == 62) {
	            ++this.pos;
	            return this.finishToken(tt.jsxTagEnd);
	          }
	
	          if ((code === 34 || code === 39) && context == tc.j_oTag)
	            return this.jsx_readString(code);
	        }
	
	        if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
	          ++this.pos;
	          return this.finishToken(tt.jsxTagStart);
	        }
	        return inner.call(this, code);
	      };
	    });
	
	    instance.extend('updateContext', function(inner) {
	      return function(prevType) {
	        if (this.type == tt.braceL) {
	          var curContext = this.curContext();
	          if (curContext == tc.j_oTag) this.context.push(tc.b_expr);
	          else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);
	          else inner.call(this, prevType);
	          this.exprAllowed = true;
	        } else if (this.type === tt.slash && prevType === tt.jsxTagStart) {
	          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
	          this.context.push(tc.j_cTag); // reconsider as closing tag context
	          this.exprAllowed = false;
	        } else {
	          return inner.call(this, prevType);
	        }
	      };
	    });
	  };
	
	  return acorn$$1;
	};
	
	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
	
	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}
	
	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}
	
	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}
	
	var inject$1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports['default'] = injectDynamicImport;
	/* eslint-disable no-underscore-dangle */
	
	var DynamicImportKey = exports.DynamicImportKey = 'Import';
	
	function injectDynamicImport(acorn$$1) {
	  var tt = acorn$$1.tokTypes;
	
	  // NOTE: This allows `yield import()` to parse correctly.
	  tt._import.startsExpr = true;
	
	  function parseDynamicImport() {
	    var node = this.startNode();
	    this.next();
	    if (this.type !== tt.parenL) {
	      this.unexpected();
	    }
	    return this.finishNode(node, DynamicImportKey);
	  }
	
	  function peekNext() {
	    return this.input[this.pos];
	  }
	
	  // eslint-disable-next-line no-param-reassign
	  acorn$$1.plugins.dynamicImport = function () {
	    function dynamicImportPlugin(instance) {
	      instance.extend('parseStatement', function (nextMethod) {
	        return function () {
	          function parseStatement() {
	            var node = this.startNode();
	            if (this.type === tt._import) {
	              var nextToken = peekNext.call(this);
	              if (nextToken === tt.parenL.label) {
	                var expr = this.parseExpression();
	                return this.parseExpressionStatement(node, expr);
	              }
	            }
	
	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	              args[_key] = arguments[_key];
	            }
	
	            return nextMethod.apply(this, args);
	          }
	
	          return parseStatement;
	        }();
	      });
	
	      instance.extend('parseExprAtom', function (nextMethod) {
	        return function () {
	          function parseExprAtom(refDestructuringErrors) {
	            if (this.type === tt._import) {
	              return parseDynamicImport.call(this);
	            }
	            return nextMethod.call(this, refDestructuringErrors);
	          }
	
	          return parseExprAtom;
	        }();
	      });
	    }
	
	    return dynamicImportPlugin;
	  }();
	
	  return acorn$$1;
	}
	});
	
	var acornDynamicImport = unwrapExports(inject$1);
	var inject_1 = inject$1.DynamicImportKey;
	
	// used for debugging, without the noise created by
	// circular references
	function toJSON(node) {
		var obj = {};
	
		Object.keys(node).forEach(function (key) {
			if (
				key === 'parent' ||
				key === 'program' ||
				key === 'keys' ||
				key === '__wrapped'
			)
				{ return; }
	
			if (Array.isArray(node[key])) {
				obj[key] = node[key].map(toJSON);
			} else if (node[key] && node[key].toJSON) {
				obj[key] = node[key].toJSON();
			} else {
				obj[key] = node[key];
			}
		});
	
		return obj;
	}
	
	var Node = function Node () {};
	
	Node.prototype.ancestor = function ancestor (level) {
		var node = this;
		while (level--) {
			node = node.parent;
			if (!node) { return null; }
		}
	
		return node;
	};
	
	Node.prototype.contains = function contains (node) {
			var this$1 = this;
	
		while (node) {
			if (node === this$1) { return true; }
			node = node.parent;
		}
	
		return false;
	};
	
	Node.prototype.findLexicalBoundary = function findLexicalBoundary () {
		return this.parent.findLexicalBoundary();
	};
	
	Node.prototype.findNearest = function findNearest (type) {
		if (typeof type === 'string') { type = new RegExp(("^" + type + "$")); }
		if (type.test(this.type)) { return this; }
		return this.parent.findNearest(type);
	};
	
	Node.prototype.unparenthesizedParent = function unparenthesizedParent () {
		var node = this.parent;
		while (node && node.type === 'ParenthesizedExpression') {
			node = node.parent;
		}
		return node;
	};
	
	Node.prototype.unparenthesize = function unparenthesize () {
		var node = this;
		while (node.type === 'ParenthesizedExpression') {
			node = node.expression;
		}
		return node;
	};
	
	Node.prototype.findScope = function findScope (functionScope) {
		return this.parent.findScope(functionScope);
	};
	
	Node.prototype.getIndentation = function getIndentation () {
		return this.parent.getIndentation();
	};
	
	Node.prototype.initialise = function initialise (transforms) {
			var this$1 = this;
	
		for (var i = 0, list = this$1.keys; i < list.length; i += 1) {
			var key = list[i];
	
				var value = this$1[key];
	
			if (Array.isArray(value)) {
				value.forEach(function (node) { return node && node.initialise(transforms); });
			} else if (value && typeof value === 'object') {
				value.initialise(transforms);
			}
		}
	};
	
	Node.prototype.toJSON = function toJSON$1 () {
		return toJSON(this);
	};
	
	Node.prototype.toString = function toString () {
		return this.program.magicString.original.slice(this.start, this.end);
	};
	
	Node.prototype.transpile = function transpile (code, transforms) {
			var this$1 = this;
	
		for (var i = 0, list = this$1.keys; i < list.length; i += 1) {
			var key = list[i];
	
				var value = this$1[key];
	
			if (Array.isArray(value)) {
				value.forEach(function (node) { return node && node.transpile(code, transforms); });
			} else if (value && typeof value === 'object') {
				value.transpile(code, transforms);
			}
		}
	};
	
	function extractNames(node) {
		var names = [];
		extractors[node.type](names, node);
		return names;
	}
	
	var extractors = {
		Identifier: function Identifier(names, node) {
			names.push(node);
		},
	
		ObjectPattern: function ObjectPattern(names, node) {
			for (var i = 0, list = node.properties; i < list.length; i += 1) {
				var prop = list[i];
	
				extractors[prop.type](names, prop);
			}
		},
	
		Property: function Property(names, node) {
			extractors[node.value.type](names, node.value);
		},
	
		ArrayPattern: function ArrayPattern(names, node) {
			for (var i = 0, list = node.elements; i < list.length; i += 1) {
				var element = list[i];
	
				if (element) { extractors[element.type](names, element); }
			}
		},
	
		RestElement: function RestElement(names, node) {
			extractors[node.argument.type](names, node.argument);
		},
	
		AssignmentPattern: function AssignmentPattern(names, node) {
			extractors[node.left.type](names, node.left);
		}
	};
	
	var reserved = Object.create(null);
	'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'
		.split(' ')
		.forEach(function (word) { return (reserved[word] = true); });
	
	function Scope(options) {
		options = options || {};
	
		this.parent = options.parent;
		this.isBlockScope = !!options.block;
		this.createDeclarationCallback = options.declare;
	
		var scope = this;
		while (scope.isBlockScope) { scope = scope.parent; }
		this.functionScope = scope;
	
		this.identifiers = [];
		this.declarations = Object.create(null);
		this.references = Object.create(null);
		this.blockScopedDeclarations = this.isBlockScope ? null : Object.create(null);
		this.aliases = Object.create(null);
	}
	
	Scope.prototype = {
		addDeclaration: function addDeclaration(node, kind) {
			var this$1 = this;
	
			for (var i = 0, list = extractNames(node); i < list.length; i += 1) {
				var identifier = list[i];
	
				var name = identifier.name;
	
				var declaration = { name: name, node: identifier, kind: kind, instances: [] };
				this$1.declarations[name] = declaration;
	
				if (this$1.isBlockScope) {
					if (!this$1.functionScope.blockScopedDeclarations[name])
						{ this$1.functionScope.blockScopedDeclarations[name] = []; }
					this$1.functionScope.blockScopedDeclarations[name].push(declaration);
				}
			}
		},
	
		addReference: function addReference(identifier) {
			if (this.consolidated) {
				this.consolidateReference(identifier);
			} else {
				this.identifiers.push(identifier);
			}
		},
	
		consolidate: function consolidate() {
			var this$1 = this;
	
			for (var i = 0; i < this.identifiers.length; i += 1) {
				// we might push to the array during consolidation, so don't cache length
				var identifier = this$1.identifiers[i];
				this$1.consolidateReference(identifier);
			}
	
			this.consolidated = true; // TODO understand why this is necessary... seems bad
		},
	
		consolidateReference: function consolidateReference(identifier) {
			var declaration = this.declarations[identifier.name];
			if (declaration) {
				declaration.instances.push(identifier);
			} else {
				this.references[identifier.name] = true;
				if (this.parent) { this.parent.addReference(identifier); }
			}
		},
	
		contains: function contains(name) {
			return (
				this.declarations[name] ||
				(this.parent ? this.parent.contains(name) : false)
			);
		},
	
		createIdentifier: function createIdentifier(base) {
			if (typeof base === 'number') { base = base.toString(); }
	
			base = base
				.replace(/\s/g, '')
				.replace(/\[([^\]]+)\]/g, '_$1')
				.replace(/[^a-zA-Z0-9_$]/g, '_')
				.replace(/_{2,}/, '_');
	
			var name = base;
			var counter = 1;
	
			while (
				this.declarations[name] ||
				this.references[name] ||
				this.aliases[name] ||
				name in reserved
			) {
				name = base + "$" + (counter++);
			}
	
			this.aliases[name] = true;
			return name;
		},
	
		createDeclaration: function createDeclaration(base) {
			var id = this.createIdentifier(base);
			this.createDeclarationCallback(id);
			return id;
		},
	
		findDeclaration: function findDeclaration(name) {
			return (
				this.declarations[name] ||
				(this.parent && this.parent.findDeclaration(name))
			);
		},
	
		// Sometimes, block scope declarations change name during transpilation
		resolveName: function resolveName(name) {
			var declaration = this.findDeclaration(name);
			return declaration ? declaration.name : name;
		}
	};
	
	function locate(source, index) {
		var lines = source.split('\n');
		var len = lines.length;
	
		var lineStart = 0;
		var i;
	
		for (i = 0; i < len; i += 1) {
			var line = lines[i];
			var lineEnd = lineStart + line.length + 1; // +1 for newline
	
			if (lineEnd > index) {
				return { line: i + 1, column: index - lineStart, char: i };
			}
	
			lineStart = lineEnd;
		}
	
		throw new Error('Could not determine location of character');
	}
	
	function pad(num, len) {
		var result = String(num);
		return result + repeat(' ', len - result.length);
	}
	
	function repeat(str, times) {
		var result = '';
		while (times--) { result += str; }
		return result;
	}
	
	function getSnippet(source, loc, length) {
		if ( length === void 0 ) length = 1;
	
		var first = Math.max(loc.line - 5, 0);
		var last = loc.line;
	
		var numDigits = String(last).length;
	
		var lines = source.split('\n').slice(first, last);
	
		var lastLine = lines[lines.length - 1];
		var offset = lastLine.slice(0, loc.column).replace(/\t/g, '  ').length;
	
		var snippet = lines
			.map(function (line, i) { return ((pad(i + first + 1, numDigits)) + " : " + (line.replace(/\t/g, '  '))); })
			.join('\n');
	
		snippet += '\n' + repeat(' ', numDigits + 3 + offset) + repeat('^', length);
	
		return snippet;
	}
	
	var CompileError = (function (Error) {
		function CompileError(message, node) {
			Error.call(this, message);
	
			this.name = 'CompileError';
			if (!node) {
				return;
			}
	
			var source = node.program.magicString.original;
			var loc = locate(source, node.start);
	
			this.message = message + " (" + (loc.line) + ":" + (loc.column) + ")";
	
			this.stack = new Error().stack.replace(
				new RegExp((".+new " + (this.name) + ".+\\n"), 'm'),
				''
			);
	
			this.loc = loc;
			this.snippet = getSnippet(source, loc, node.end - node.start);
		}
	
		if ( Error ) CompileError.__proto__ = Error;
		CompileError.prototype = Object.create( Error && Error.prototype );
		CompileError.prototype.constructor = CompileError;
	
		CompileError.prototype.toString = function toString () {
			return ((this.name) + ": " + (this.message) + "\n" + (this.snippet));
		};
	
		return CompileError;
	}(Error));
	
	function findIndex(array, fn) {
		for (var i = 0; i < array.length; i += 1) {
			if (fn(array[i], i)) { return i; }
		}
	
		return -1;
	}
	
	var handlers = {
		Identifier: destructureIdentifier,
		AssignmentPattern: destructureAssignmentPattern,
		ArrayPattern: destructureArrayPattern,
		ObjectPattern: destructureObjectPattern
	};
	
	function destructure(
		code,
		createIdentifier,
		resolveName,
		node,
		ref,
		inline,
		statementGenerators
	) {
		handlers[node.type](code, createIdentifier, resolveName, node, ref, inline, statementGenerators);
	}
	
	function destructureIdentifier(
		code,
		createIdentifier,
		resolveName,
		node,
		ref,
		inline,
		statementGenerators
	) {
		statementGenerators.push(function (start, prefix, suffix) {
			code.overwrite(node.start, node.end, (inline ? prefix : (prefix + "var ")) + resolveName(node) + " = " + ref + suffix);
			code.move(node.start, node.end, start);
		});
	}
	
	function destructureMemberExpression(
		code,
		createIdentifier,
		resolveName,
		node,
		ref,
		inline,
		statementGenerators
	) {
		statementGenerators.push(function (start, prefix, suffix) {
			code.prependRight(node.start, inline ? prefix : (prefix + "var "));
			code.appendLeft(node.end, (" = " + ref + suffix));
			code.move(node.start, node.end, start);
		});
	}
	
	function destructureAssignmentPattern(
		code,
		createIdentifier,
		resolveName,
		node,
		ref,
		inline,
		statementGenerators
	) {
		var isIdentifier = node.left.type === 'Identifier';
		var name = isIdentifier ? node.left.name : ref;
	
		if (!inline) {
			statementGenerators.push(function (start, prefix, suffix) {
				code.prependRight(
					node.left.end,
					(prefix + "if ( " + name + " === void 0 ) " + name)
				);
				code.move(node.left.end, node.right.end, start);
				code.appendLeft(node.right.end, suffix);
			});
		}
	
		if (!isIdentifier) {
			destructure(code, createIdentifier, resolveName, node.left, ref, inline, statementGenerators);
		}
	}
	
	function destructureArrayPattern(
		code,
		createIdentifier,
		resolveName,
		node,
		ref,
		inline,
		statementGenerators
	) {
		var c = node.start;
	
		node.elements.forEach(function (element, i) {
			if (!element) { return; }
	
			if (element.type === 'RestElement') {
				handleProperty(
					code,
					createIdentifier,
					resolveName,
					c,
					element.argument,
					(ref + ".slice(" + i + ")"),
					inline,
					statementGenerators
				);
			} else {
				handleProperty(
					code,
					createIdentifier,
					resolveName,
					c,
					element,
					(ref + "[" + i + "]"),
					inline,
					statementGenerators
				);
			}
			c = element.end;
		});
	
		code.remove(c, node.end);
	}
	
	function destructureObjectPattern(
		code,
		createIdentifier,
		resolveName,
		node,
		ref,
		inline,
		statementGenerators
	) {
		var this$1 = this;
	
		var c = node.start;
	
		var nonRestKeys = [];
		node.properties.forEach(function (prop) {
			var value;
			var content;
			if (prop.type === 'Property') {
				var isComputedKey = prop.computed || prop.key.type !== 'Identifier';
				var key = isComputedKey
					? code.slice(prop.key.start, prop.key.end)
					: prop.key.name;
				value = isComputedKey ? (ref + "[" + key + "]") : (ref + "." + key);
				content = prop.value;
				nonRestKeys.push(isComputedKey ? key : '"' + key + '"');
			} else if (prop.type === 'RestElement') {
				content = prop.argument;
				value = createIdentifier('rest');
				statementGenerators.push(function (start, prefix, suffix) {
					var helper = prop.program.getObjectWithoutPropertiesHelper(code);
					code.overwrite(
						prop.start,
						(c = prop.argument.start),
						(inline ? prefix : (prefix + "var ")) + value + " = " + helper + "( " + ref + ", [" + (nonRestKeys.join(', ')) + "] )" + suffix
					);
					code.move(prop.start, c, start);
				});
			} else {
				throw new CompileError(
					this$1,
					("Unexpected node of type " + (prop.type) + " in object pattern")
				);
			}
			handleProperty(code, createIdentifier, resolveName, c, content, value, inline, statementGenerators);
			c = prop.end;
		});
	
		code.remove(c, node.end);
	}
	
	function handleProperty(
		code,
		createIdentifier,
		resolveName,
		c,
		node,
		value,
		inline,
		statementGenerators
	) {
		switch (node.type) {
			case 'Identifier': {
				code.remove(c, node.start);
				destructureIdentifier(
					code,
					createIdentifier,
					resolveName,
					node,
					value,
					inline,
					statementGenerators
				);
				break;
			}
	
			case 'MemberExpression':
				code.remove(c, node.start);
				destructureMemberExpression(
					code,
					createIdentifier,
					resolveName,
					node,
					value,
					true,
					statementGenerators
				);
				break;
	
			case 'AssignmentPattern': {
				var name;
	
				var isIdentifier = node.left.type === 'Identifier';
	
				if (isIdentifier) {
					name = resolveName(node.left);
				} else {
					name = createIdentifier(value);
				}
	
				statementGenerators.push(function (start, prefix, suffix) {
					if (inline) {
						code.prependRight(
							node.right.start,
							(name + " = " + value + ", " + name + " = " + name + " === void 0 ? ")
						);
						code.appendLeft(node.right.end, (" : " + name + suffix));
					} else {
						code.prependRight(
							node.right.start,
							(prefix + "var " + name + " = " + value + "; if ( " + name + " === void 0 ) " + name + " = ")
						);
						code.appendLeft(node.right.end, suffix);
					}
	
					code.move(node.right.start, node.right.end, start);
				});
	
				if (isIdentifier) {
					code.remove(c, node.right.start);
				} else {
					code.remove(c, node.left.start);
					code.remove(node.left.end, node.right.start);
					handleProperty(
						code,
						createIdentifier,
						resolveName,
						c,
						node.left,
						name,
						inline,
						statementGenerators
					);
				}
	
				break;
			}
	
			case 'ObjectPattern': {
				code.remove(c, (c = node.start));
	
				var ref = value;
				if (node.properties.length > 1) {
					ref = createIdentifier(value);
	
					statementGenerators.push(function (start, prefix, suffix) {
						// this feels a tiny bit hacky, but we can't do a
						// straightforward appendLeft and keep correct order...
						code.prependRight(node.start, (inline ? '' : (prefix + "var ")) + ref + " = ");
						code.overwrite(node.start, (c = node.start + 1), value);
						code.appendLeft(c, suffix);
	
						code.overwrite(
							node.start,
							(c = node.start + 1),
							(inline ? '' : (prefix + "var ")) + ref + " = " + value + suffix
						);
						code.move(node.start, c, start);
					});
				}
	
				destructureObjectPattern(
					code,
					createIdentifier,
					resolveName,
					node,
					ref,
					inline,
					statementGenerators
				);
	
				break;
			}
	
			case 'ArrayPattern': {
				code.remove(c, (c = node.start));
	
				if (node.elements.filter(Boolean).length > 1) {
					var ref$1 = createIdentifier(value);
	
					statementGenerators.push(function (start, prefix, suffix) {
						code.prependRight(node.start, (inline ? '' : (prefix + "var ")) + ref$1 + " = ");
						code.overwrite(node.start, (c = node.start + 1), value, {
							contentOnly: true
						});
						code.appendLeft(c, suffix);
	
						code.move(node.start, c, start);
					});
	
					node.elements.forEach(function (element, i) {
						if (!element) { return; }
	
						if (element.type === 'RestElement') {
							handleProperty(
								code,
								createIdentifier,
								resolveName,
								c,
								element.argument,
								(ref$1 + ".slice(" + i + ")"),
								inline,
								statementGenerators
							);
						} else {
							handleProperty(
								code,
								createIdentifier,
								resolveName,
								c,
								element,
								(ref$1 + "[" + i + "]"),
								inline,
								statementGenerators
							);
						}
						c = element.end;
					});
				} else {
					var index = findIndex(node.elements, Boolean);
					var element = node.elements[index];
					if (element.type === 'RestElement') {
						handleProperty(
							code,
							createIdentifier,
							resolveName,
							c,
							element.argument,
							(value + ".slice(" + index + ")"),
							inline,
							statementGenerators
						);
					} else {
						handleProperty(
							code,
							createIdentifier,
							resolveName,
							c,
							element,
							(value + "[" + index + "]"),
							inline,
							statementGenerators
						);
					}
					c = element.end;
				}
	
				code.remove(c, node.end);
				break;
			}
	
			default: {
				throw new Error(("Unexpected node type in destructuring (" + (node.type) + ")"));
			}
		}
	}
	
	function isUseStrict(node) {
		if (!node) { return false; }
		if (node.type !== 'ExpressionStatement') { return false; }
		if (node.expression.type !== 'Literal') { return false; }
		return node.expression.value === 'use strict';
	}
	
	var BlockStatement = (function (Node$$1) {
		function BlockStatement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) BlockStatement.__proto__ = Node$$1;
		BlockStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		BlockStatement.prototype.constructor = BlockStatement;
	
		BlockStatement.prototype.createScope = function createScope () {
			var this$1 = this;
	
			this.parentIsFunction = /Function/.test(this.parent.type);
			this.isFunctionBlock = this.parentIsFunction || this.parent.type === 'Root';
			this.scope = new Scope({
				block: !this.isFunctionBlock,
				parent: this.parent.findScope(false),
				declare: function (id) { return this$1.createdDeclarations.push(id); }
			});
	
			if (this.parentIsFunction) {
				this.parent.params.forEach(function (node) {
					this$1.scope.addDeclaration(node, 'param');
				});
			}
		};
	
		BlockStatement.prototype.initialise = function initialise (transforms) {
			this.thisAlias = null;
			this.argumentsAlias = null;
			this.defaultParameters = [];
			this.createdDeclarations = [];
	
			// normally the scope gets created here, during initialisation,
			// but in some cases (e.g. `for` statements), we need to create
			// the scope early, as it pertains to both the init block and
			// the body of the statement
			if (!this.scope) { this.createScope(); }
	
			this.body.forEach(function (node) { return node.initialise(transforms); });
	
			this.scope.consolidate();
		};
	
		BlockStatement.prototype.findLexicalBoundary = function findLexicalBoundary () {
			if (this.type === 'Program') { return this; }
			if (/^Function/.test(this.parent.type)) { return this; }
	
			return this.parent.findLexicalBoundary();
		};
	
		BlockStatement.prototype.findScope = function findScope (functionScope) {
			if (functionScope && !this.isFunctionBlock)
				{ return this.parent.findScope(functionScope); }
			return this.scope;
		};
	
		BlockStatement.prototype.getArgumentsAlias = function getArgumentsAlias () {
			if (!this.argumentsAlias) {
				this.argumentsAlias = this.scope.createIdentifier('arguments');
			}
	
			return this.argumentsAlias;
		};
	
		BlockStatement.prototype.getArgumentsArrayAlias = function getArgumentsArrayAlias () {
			if (!this.argumentsArrayAlias) {
				this.argumentsArrayAlias = this.scope.createIdentifier('argsArray');
			}
	
			return this.argumentsArrayAlias;
		};
	
		BlockStatement.prototype.getThisAlias = function getThisAlias () {
			if (!this.thisAlias) {
				this.thisAlias = this.scope.createIdentifier('this');
			}
	
			return this.thisAlias;
		};
	
		BlockStatement.prototype.getIndentation = function getIndentation () {
			var this$1 = this;
	
			if (this.indentation === undefined) {
				var source = this.program.magicString.original;
	
				var useOuter = this.synthetic || !this.body.length;
				var c = useOuter ? this.start : this.body[0].start;
	
				while (c && source[c] !== '\n') { c -= 1; }
	
				this.indentation = '';
	
				// eslint-disable-next-line no-constant-condition
				while (true) {
					c += 1;
					var char = source[c];
	
					if (char !== ' ' && char !== '\t') { break; }
	
					this$1.indentation += char;
				}
	
				var indentString = this.program.magicString.getIndentString();
	
				// account for dedented class constructors
				var parent = this.parent;
				while (parent) {
					if (parent.kind === 'constructor' && !parent.parent.parent.superClass) {
						this$1.indentation = this$1.indentation.replace(indentString, '');
					}
	
					parent = parent.parent;
				}
	
				if (useOuter) { this.indentation += indentString; }
			}
	
			return this.indentation;
		};
	
		BlockStatement.prototype.transpile = function transpile (code, transforms) {
			var this$1 = this;
	
			var indentation = this.getIndentation();
	
			var introStatementGenerators = [];
	
			if (this.argumentsAlias) {
				introStatementGenerators.push(function (start, prefix, suffix) {
					var assignment = prefix + "var " + (this$1.argumentsAlias) + " = arguments" + suffix;
					code.appendLeft(start, assignment);
				});
			}
	
			if (this.thisAlias) {
				introStatementGenerators.push(function (start, prefix, suffix) {
					var assignment = prefix + "var " + (this$1.thisAlias) + " = this" + suffix;
					code.appendLeft(start, assignment);
				});
			}
	
			if (this.argumentsArrayAlias) {
				introStatementGenerators.push(function (start, prefix, suffix) {
					var i = this$1.scope.createIdentifier('i');
					var assignment = prefix + "var " + i + " = arguments.length, " + (this$1.argumentsArrayAlias) + " = Array(" + i + ");\n" + indentation + "while ( " + i + "-- ) " + (this$1.argumentsArrayAlias) + "[" + i + "] = arguments[" + i + "]" + suffix;
					code.appendLeft(start, assignment);
				});
			}
	
			if (/Function/.test(this.parent.type)) {
				this.transpileParameters(
					this.parent.params,
					code,
					transforms,
					indentation,
					introStatementGenerators
				);
			} else if ('CatchClause' === this.parent.type) {
				this.transpileParameters(
					[this.parent.param],
					code,
					transforms,
					indentation,
					introStatementGenerators
				);
			}
	
			if (transforms.letConst && this.isFunctionBlock) {
				this.transpileBlockScopedIdentifiers(code);
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
	
			if (this.createdDeclarations.length) {
				introStatementGenerators.push(function (start, prefix, suffix) {
					var assignment = prefix + "var " + (this$1.createdDeclarations.join(', ')) + suffix;
					code.appendLeft(start, assignment);
				});
			}
	
			if (this.synthetic) {
				if (this.parent.type === 'ArrowFunctionExpression') {
					var expr = this.body[0];
	
					if (introStatementGenerators.length) {
						code
							.appendLeft(this.start, "{")
							.prependRight(this.end, ((this.parent.getIndentation()) + "}"));
	
						code.prependRight(expr.start, ("\n" + indentation + "return "));
						code.appendLeft(expr.end, ";\n");
					} else if (transforms.arrow) {
						code.prependRight(expr.start, "{ return ");
						code.appendLeft(expr.end, "; }");
					}
				} else if (introStatementGenerators.length) {
					code.prependRight(this.start, "{").appendLeft(this.end, "}");
				}
			}
	
			var start;
			if (isUseStrict(this.body[0])) {
				start = this.body[0].end;
			} else if (this.synthetic || this.parent.type === 'Root') {
				start = this.start;
			} else {
				start = this.start + 1;
			}
	
			var prefix = "\n" + indentation;
			var suffix = ';';
			introStatementGenerators.forEach(function (fn, i) {
				if (i === introStatementGenerators.length - 1) { suffix = ";\n"; }
				fn(start, prefix, suffix);
			});
		};
	
		BlockStatement.prototype.transpileParameters = function transpileParameters (params, code, transforms, indentation, introStatementGenerators) {
			var this$1 = this;
	
			params.forEach(function (param) {
				if (
					param.type === 'AssignmentPattern' &&
					param.left.type === 'Identifier'
				) {
					if (transforms.defaultParameter) {
						introStatementGenerators.push(function (start, prefix, suffix) {
							var lhs = prefix + "if ( " + (param.left.name) + " === void 0 ) " + (param.left.name);
	
							code
								.prependRight(param.left.end, lhs)
								.move(param.left.end, param.right.end, start)
								.appendLeft(param.right.end, suffix);
						});
					}
				} else if (param.type === 'RestElement') {
					if (transforms.spreadRest) {
						introStatementGenerators.push(function (start, prefix, suffix) {
							var penultimateParam = params[params.length - 2];
	
							if (penultimateParam) {
								code.remove(
									penultimateParam ? penultimateParam.end : param.start,
									param.end
								);
							} else {
								var start$1 = param.start,
									end = param.end; // TODO https://gitlab.com/Rich-Harris/buble/issues/8
	
								while (/\s/.test(code.original[start$1 - 1])) { start$1 -= 1; }
								while (/\s/.test(code.original[end])) { end += 1; }
	
								code.remove(start$1, end);
							}
	
							var name = param.argument.name;
							var len = this$1.scope.createIdentifier('len');
							var count = params.length - 1;
	
							if (count) {
								code.prependRight(
									start,
									(prefix + "var " + name + " = [], " + len + " = arguments.length - " + count + ";\n" + indentation + "while ( " + len + "-- > 0 ) " + name + "[ " + len + " ] = arguments[ " + len + " + " + count + " ]" + suffix)
								);
							} else {
								code.prependRight(
									start,
									(prefix + "var " + name + " = [], " + len + " = arguments.length;\n" + indentation + "while ( " + len + "-- ) " + name + "[ " + len + " ] = arguments[ " + len + " ]" + suffix)
								);
							}
						});
					}
				} else if (param.type !== 'Identifier') {
					if (transforms.parameterDestructuring) {
						var ref = this$1.scope.createIdentifier('ref');
						destructure(
							code,
							function (id) { return this$1.scope.createIdentifier(id); },
							function (ref) {
								var name = ref.name;
	
								return this$1.scope.resolveName(name);
						},
							param,
							ref,
							false,
							introStatementGenerators
						);
						code.prependRight(param.start, ref);
					}
				}
			});
		};
	
		BlockStatement.prototype.transpileBlockScopedIdentifiers = function transpileBlockScopedIdentifiers (code) {
			var this$1 = this;
	
			Object.keys(this.scope.blockScopedDeclarations).forEach(function (name) {
				var declarations = this$1.scope.blockScopedDeclarations[name];
	
				for (var i$2 = 0, list$2 = declarations; i$2 < list$2.length; i$2 += 1) {
					var declaration = list$2[i$2];
	
					var cont = false; // TODO implement proper continue...
	
					if (declaration.kind === 'for.let') {
						// special case
						var forStatement = declaration.node.findNearest('ForStatement');
	
						if (forStatement.shouldRewriteAsFunction) {
							var outerAlias = this$1.scope.createIdentifier(name);
							var innerAlias = forStatement.reassigned[name]
								? this$1.scope.createIdentifier(name)
								: name;
	
							declaration.name = outerAlias;
							code.overwrite(
								declaration.node.start,
								declaration.node.end,
								outerAlias,
								{ storeName: true }
							);
	
							forStatement.aliases[name] = {
								outer: outerAlias,
								inner: innerAlias
							};
	
							for (var i = 0, list = declaration.instances; i < list.length; i += 1) {
								var identifier = list[i];
	
								var alias = forStatement.body.contains(identifier)
									? innerAlias
									: outerAlias;
	
								if (name !== alias) {
									code.overwrite(identifier.start, identifier.end, alias, {
										storeName: true
									});
								}
							}
	
							cont = true;
						}
					}
	
					if (!cont) {
						var alias$1 = this$1.scope.createIdentifier(name);
	
						if (name !== alias$1) {
							declaration.name = alias$1;
							code.overwrite(
								declaration.node.start,
								declaration.node.end,
								alias$1,
								{ storeName: true }
							);
	
							for (var i$1 = 0, list$1 = declaration.instances; i$1 < list$1.length; i$1 += 1) {
								var identifier$1 = list$1[i$1];
	
								identifier$1.rewritten = true;
								code.overwrite(identifier$1.start, identifier$1.end, alias$1, {
									storeName: true
								});
							}
						}
					}
				}
			});
		};
	
		return BlockStatement;
	}(Node));
	
	function isArguments(node) {
		return node.type === 'Identifier' && node.name === 'arguments';
	}
	
	function spread(
		code,
		elements,
		start,
		argumentsArrayAlias,
		isNew
	) {
		var i = elements.length;
		var firstSpreadIndex = -1;
	
		while (i--) {
			var element$1 = elements[i];
			if (element$1 && element$1.type === 'SpreadElement') {
				if (isArguments(element$1.argument)) {
					code.overwrite(
						element$1.argument.start,
						element$1.argument.end,
						argumentsArrayAlias
					);
				}
	
				firstSpreadIndex = i;
			}
		}
	
		if (firstSpreadIndex === -1) { return false; } // false indicates no spread elements
	
		if (isNew) {
			for (i = 0; i < elements.length; i += 1) {
				var element$2 = elements[i];
				if (element$2.type === 'SpreadElement') {
					code.remove(element$2.start, element$2.argument.start);
				} else {
					code.prependRight(element$2.start, '[');
					code.prependRight(element$2.end, ']');
				}
			}
	
			return true; // true indicates some spread elements
		}
	
		var element = elements[firstSpreadIndex];
		var previousElement = elements[firstSpreadIndex - 1];
	
		if (!previousElement) {
			code.remove(start, element.start);
			code.overwrite(element.end, elements[1].start, '.concat( ');
		} else {
			code.overwrite(previousElement.end, element.start, ' ].concat( ');
		}
	
		for (i = firstSpreadIndex; i < elements.length; i += 1) {
			element = elements[i];
	
			if (element) {
				if (element.type === 'SpreadElement') {
					code.remove(element.start, element.argument.start);
				} else {
					code.appendLeft(element.start, '[');
					code.appendLeft(element.end, ']');
				}
			}
		}
	
		return true; // true indicates some spread elements
	}
	
	var ArrayExpression = (function (Node$$1) {
		function ArrayExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ArrayExpression.__proto__ = Node$$1;
		ArrayExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ArrayExpression.prototype.constructor = ArrayExpression;
	
		ArrayExpression.prototype.initialise = function initialise (transforms) {
			var this$1 = this;
	
			if (transforms.spreadRest && this.elements.length) {
				var lexicalBoundary = this.findLexicalBoundary();
	
				var i = this.elements.length;
				while (i--) {
					var element = this$1.elements[i];
					if (
						element &&
						element.type === 'SpreadElement' &&
						isArguments(element.argument)
					) {
						this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();
					}
				}
			}
	
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		ArrayExpression.prototype.transpile = function transpile (code, transforms) {
			Node$$1.prototype.transpile.call(this, code, transforms);
	
			if (transforms.spreadRest) {
				// erase trailing comma after last array element if not an array hole
				if (this.elements.length) {
					var lastElement = this.elements[this.elements.length - 1];
					if (
						lastElement &&
						/\s*,/.test(code.original.slice(lastElement.end, this.end))
					) {
						code.overwrite(lastElement.end, this.end - 1, ' ');
					}
				}
	
				if (this.elements.length === 1) {
					var element = this.elements[0];
	
					if (element && element.type === 'SpreadElement') {
						// special case  [ ...arguments ]
						if (isArguments(element.argument)) {
							code.overwrite(
								this.start,
								this.end,
								("[].concat( " + (this.argumentsArrayAlias) + " )")
							); // TODO if this is the only use of argsArray, don't bother concating
						} else {
							code.overwrite(this.start, element.argument.start, '[].concat( ');
							code.overwrite(element.end, this.end, ' )');
						}
					}
				} else {
					var hasSpreadElements = spread(
						code,
						this.elements,
						this.start,
						this.argumentsArrayAlias
					);
	
					if (hasSpreadElements) {
						code.overwrite(this.end - 1, this.end, ')');
					}
				}
			}
		};
	
		return ArrayExpression;
	}(Node));
	
	function removeTrailingComma(code, c) {
		while (code.original[c] !== ')') {
			if (code.original[c] === ',') {
				code.remove(c, c + 1);
				return;
			}
	
			if (code.original[c] === '/') {
				c = code.original.indexOf(code.original[c + 1] === '/' ? '\n' : '*/', c) + 1;
			}
			c += 1;
		}
	}
	
	var ArrowFunctionExpression = (function (Node$$1) {
		function ArrowFunctionExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ArrowFunctionExpression.__proto__ = Node$$1;
		ArrowFunctionExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ArrowFunctionExpression.prototype.constructor = ArrowFunctionExpression;
	
		ArrowFunctionExpression.prototype.initialise = function initialise (transforms) {
			this.body.createScope();
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		ArrowFunctionExpression.prototype.transpile = function transpile (code, transforms) {
			var naked = this.params.length === 1 && this.start === this.params[0].start;
	
			if (transforms.arrow || this.needsArguments(transforms)) {
				// remove arrow
				var charIndex = this.body.start;
				while (code.original[charIndex] !== '=') {
					charIndex -= 1;
				}
				code.remove(charIndex, this.body.start);
	
				Node$$1.prototype.transpile.call(this, code, transforms);
	
				// wrap naked parameter
				if (naked) {
					code.prependRight(this.params[0].start, '(');
					code.appendLeft(this.params[0].end, ')');
				}
	
				// add function
				if (this.parent && this.parent.type === 'ExpressionStatement') {
					// standalone expression statement
					code.prependRight(this.start, '!function');
				} else {
					code.prependRight(this.start, 'function ');
				}
			} else {
				Node$$1.prototype.transpile.call(this, code, transforms);
			}
	
			if (transforms.trailingFunctionCommas && this.params.length && !naked) {
				removeTrailingComma(code, this.params[this.params.length - 1].end);
			}
		};
	
		// Returns whether any transforms that will happen use `arguments`
		ArrowFunctionExpression.prototype.needsArguments = function needsArguments (transforms) {
			return (
				transforms.spreadRest &&
				this.params.filter(function (param) { return param.type === 'RestElement'; }).length > 0
			);
		};
	
		return ArrowFunctionExpression;
	}(Node));
	
	function checkConst(identifier, scope) {
		var declaration = scope.findDeclaration(identifier.name);
		if (declaration && declaration.kind === 'const') {
			throw new CompileError(((identifier.name) + " is read-only"), identifier);
		}
	}
	
	var AssignmentExpression = (function (Node$$1) {
		function AssignmentExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) AssignmentExpression.__proto__ = Node$$1;
		AssignmentExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		AssignmentExpression.prototype.constructor = AssignmentExpression;
	
		AssignmentExpression.prototype.initialise = function initialise (transforms) {
			if (this.left.type === 'Identifier') {
				var declaration = this.findScope(false).findDeclaration(this.left.name);
				// special case  https://gitlab.com/Rich-Harris/buble/issues/11
				var statement = declaration && declaration.node.ancestor(3);
				if (
					statement &&
					statement.type === 'ForStatement' &&
					statement.body.contains(this)
				) {
					statement.reassigned[this.left.name] = true;
				}
			}
	
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		AssignmentExpression.prototype.transpile = function transpile (code, transforms) {
			if (this.left.type === 'Identifier') {
				// Do this check after everything has been initialized to find
				// shadowing declarations after this expression
				checkConst(this.left, this.findScope(false));
			}
	
			if (this.operator === '**=' && transforms.exponentiation) {
				this.transpileExponentiation(code, transforms);
			} else if (/Pattern/.test(this.left.type) && transforms.destructuring) {
				this.transpileDestructuring(code, transforms);
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		AssignmentExpression.prototype.transpileDestructuring = function transpileDestructuring (code) {
			var this$1 = this;
	
			var writeScope = this.findScope(true);
			var lookupScope = this.findScope(false);
			var assign = writeScope.createDeclaration('assign');
			code.appendRight(this.left.end, ("(" + assign));
	
			code.appendLeft(this.right.end, ', ');
			var statementGenerators = [];
			destructure(
				code,
				function (id) { return writeScope.createDeclaration(id); },
				function (node) {
					var name = lookupScope.resolveName(node.name);
					checkConst(node, lookupScope);
					return name;
				},
				this.left,
				assign,
				true,
				statementGenerators
			);
	
			var suffix = ', ';
			statementGenerators.forEach(function (fn, j) {
				if (j === statementGenerators.length - 1) {
					suffix = '';
				}
	
				fn(this$1.end, '', suffix);
			});
	
			if (this.unparenthesizedParent().type === 'ExpressionStatement') {
				// no rvalue needed for expression statement
				code.appendRight(this.end, ")");
			} else {
				// destructuring is part of an expression - need an rvalue
				code.appendRight(this.end, (", " + assign + ")"));
			}
		};
	
		AssignmentExpression.prototype.transpileExponentiation = function transpileExponentiation (code) {
			var scope = this.findScope(false);
	
			// first, the easy part  `**=` -> `=`
			var charIndex = this.left.end;
			while (code.original[charIndex] !== '*') { charIndex += 1; }
			code.remove(charIndex, charIndex + 2);
	
			// how we do the next part depends on a number of factors  whether
			// this is a top-level statement, and whether we're updating a
			// simple or complex reference
			var base;
	
			var left = this.left.unparenthesize();
	
			if (left.type === 'Identifier') {
				base = scope.resolveName(left.name);
			} else if (left.type === 'MemberExpression') {
				var object;
				var needsObjectVar = false;
				var property;
				var needsPropertyVar = false;
	
				var statement = this.findNearest(/(?:Statement|Declaration)$/);
				var i0 = statement.getIndentation();
	
				if (left.property.type === 'Identifier') {
					property = left.computed
						? scope.resolveName(left.property.name)
						: left.property.name;
				} else {
					property = scope.createDeclaration('property');
					needsPropertyVar = true;
				}
	
				if (left.object.type === 'Identifier') {
					object = scope.resolveName(left.object.name);
				} else {
					object = scope.createDeclaration('object');
					needsObjectVar = true;
				}
	
				if (left.start === statement.start) {
					if (needsObjectVar && needsPropertyVar) {
						code.prependRight(statement.start, (object + " = "));
						code.overwrite(
							left.object.end,
							left.property.start,
							(";\n" + i0 + property + " = ")
						);
						code.overwrite(
							left.property.end,
							left.end,
							(";\n" + i0 + object + "[" + property + "]")
						);
					} else if (needsObjectVar) {
						code.prependRight(statement.start, (object + " = "));
						code.appendLeft(left.object.end, (";\n" + i0));
						code.appendLeft(left.object.end, object);
					} else if (needsPropertyVar) {
						code.prependRight(left.property.start, (property + " = "));
						code.appendLeft(left.property.end, (";\n" + i0));
						code.move(left.property.start, left.property.end, this.start);
	
						code.appendLeft(left.object.end, ("[" + property + "]"));
						code.remove(left.object.end, left.property.start);
						code.remove(left.property.end, left.end);
					}
				} else {
					if (needsObjectVar && needsPropertyVar) {
						code.prependRight(left.start, ("( " + object + " = "));
						code.overwrite(
							left.object.end,
							left.property.start,
							(", " + property + " = ")
						);
						code.overwrite(
							left.property.end,
							left.end,
							(", " + object + "[" + property + "]")
						);
					} else if (needsObjectVar) {
						code.prependRight(left.start, ("( " + object + " = "));
						code.appendLeft(left.object.end, (", " + object));
					} else if (needsPropertyVar) {
						code.prependRight(left.property.start, ("( " + property + " = "));
						code.appendLeft(left.property.end, ", ");
						code.move(left.property.start, left.property.end, left.start);
	
						code.overwrite(left.object.end, left.property.start, ("[" + property + "]"));
						code.remove(left.property.end, left.end);
					}
	
					if (needsPropertyVar) {
						code.appendLeft(this.end, " )");
					}
				}
	
				base =
					object +
					(left.computed || needsPropertyVar ? ("[" + property + "]") : ("." + property));
			}
	
			code.prependRight(this.right.start, ("Math.pow( " + base + ", "));
			code.appendLeft(this.right.end, " )");
		};
	
		return AssignmentExpression;
	}(Node));
	
	var BinaryExpression = (function (Node$$1) {
		function BinaryExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) BinaryExpression.__proto__ = Node$$1;
		BinaryExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		BinaryExpression.prototype.constructor = BinaryExpression;
	
		BinaryExpression.prototype.transpile = function transpile (code, transforms) {
			if (this.operator === '**' && transforms.exponentiation) {
				code.prependRight(this.start, "Math.pow( ");
				code.overwrite(this.left.end, this.right.start, ", ");
				code.appendLeft(this.end, " )");
			}
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return BinaryExpression;
	}(Node));
	
	var loopStatement = /(?:For(?:In|Of)?|While)Statement/;
	
	var BreakStatement = (function (Node$$1) {
		function BreakStatement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) BreakStatement.__proto__ = Node$$1;
		BreakStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		BreakStatement.prototype.constructor = BreakStatement;
	
		BreakStatement.prototype.initialise = function initialise () {
			var loop = this.findNearest(loopStatement);
			var switchCase = this.findNearest('SwitchCase');
	
			if (loop && (!switchCase || loop.depth > switchCase.depth)) {
				loop.canBreak = true;
				this.loop = loop;
			}
		};
	
		BreakStatement.prototype.transpile = function transpile (code) {
			if (this.loop && this.loop.shouldRewriteAsFunction) {
				if (this.label)
					{ throw new CompileError(
						'Labels are not currently supported in a loop with locally-scoped variables',
						this
					); }
				code.overwrite(this.start, this.start + 5, "return 'break'");
			}
		};
	
		return BreakStatement;
	}(Node));
	
	var CallExpression = (function (Node$$1) {
		function CallExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) CallExpression.__proto__ = Node$$1;
		CallExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		CallExpression.prototype.constructor = CallExpression;
	
		CallExpression.prototype.initialise = function initialise (transforms) {
			var this$1 = this;
	
			if (transforms.spreadRest && this.arguments.length > 1) {
				var lexicalBoundary = this.findLexicalBoundary();
	
				var i = this.arguments.length;
				while (i--) {
					var arg = this$1.arguments[i];
					if (arg.type === 'SpreadElement' && isArguments(arg.argument)) {
						this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();
					}
				}
			}
	
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		CallExpression.prototype.transpile = function transpile (code, transforms) {
			if (transforms.spreadRest && this.arguments.length) {
				var hasSpreadElements = false;
				var context;
	
				var firstArgument = this.arguments[0];
	
				if (this.arguments.length === 1) {
					if (firstArgument.type === 'SpreadElement') {
						code.remove(firstArgument.start, firstArgument.argument.start);
						hasSpreadElements = true;
					}
				} else {
					hasSpreadElements = spread(
						code,
						this.arguments,
						firstArgument.start,
						this.argumentsArrayAlias
					);
				}
	
				if (hasSpreadElements) {
					// we need to handle super() and super.method() differently
					// due to its instance
					var _super = null;
					if (this.callee.type === 'Super') {
						_super = this.callee;
					} else if (
						this.callee.type === 'MemberExpression' &&
						this.callee.object.type === 'Super'
					) {
						_super = this.callee.object;
					}
	
					if (!_super && this.callee.type === 'MemberExpression') {
						if (this.callee.object.type === 'Identifier') {
							context = this.callee.object.name;
						} else {
							context = this.findScope(true).createDeclaration('ref');
							var callExpression = this.callee.object;
							code.prependRight(callExpression.start, ("(" + context + " = "));
							code.appendLeft(callExpression.end, ")");
						}
					} else {
						context = 'void 0';
					}
	
					code.appendLeft(this.callee.end, '.apply');
	
					if (_super) {
						_super.noCall = true; // bit hacky...
	
						if (this.arguments.length > 1) {
							if (firstArgument.type !== 'SpreadElement') {
								code.prependRight(firstArgument.start, "[ ");
							}
	
							code.appendLeft(
								this.arguments[this.arguments.length - 1].end,
								' )'
							);
						}
					} else if (this.arguments.length === 1) {
						code.prependRight(firstArgument.start, (context + ", "));
					} else {
						if (firstArgument.type === 'SpreadElement') {
							code.appendLeft(firstArgument.start, (context + ", "));
						} else {
							code.appendLeft(firstArgument.start, (context + ", [ "));
						}
	
						code.appendLeft(this.arguments[this.arguments.length - 1].end, ' )');
					}
				}
			}
	
			if (transforms.trailingFunctionCommas && this.arguments.length) {
				removeTrailingComma(code, this.arguments[this.arguments.length - 1].end);
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return CallExpression;
	}(Node));
	
	// TODO this code is pretty wild, tidy it up
	var ClassBody = (function (Node$$1) {
		function ClassBody () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ClassBody.__proto__ = Node$$1;
		ClassBody.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ClassBody.prototype.constructor = ClassBody;
	
		ClassBody.prototype.transpile = function transpile (code, transforms, inFunctionExpression, superName) {
			var this$1 = this;
	
			if (transforms.classes) {
				var name = this.parent.name;
	
				var indentStr = code.getIndentString();
				var i0 =
					this.getIndentation() + (inFunctionExpression ? indentStr : '');
				var i1 = i0 + indentStr;
	
				var constructorIndex = findIndex(
					this.body,
					function (node) { return node.kind === 'constructor'; }
				);
				var constructor = this.body[constructorIndex];
	
				var introBlock = '';
				var outroBlock = '';
	
				if (this.body.length) {
					code.remove(this.start, this.body[0].start);
					code.remove(this.body[this.body.length - 1].end, this.end);
				} else {
					code.remove(this.start, this.end);
				}
	
				if (constructor) {
					constructor.value.body.isConstructorBody = true;
	
					var previousMethod = this.body[constructorIndex - 1];
					var nextMethod = this.body[constructorIndex + 1];
	
					// ensure constructor is first
					if (constructorIndex > 0) {
						code.remove(previousMethod.end, constructor.start);
						code.move(
							constructor.start,
							nextMethod ? nextMethod.start : this.end - 1,
							this.body[0].start
						);
					}
	
					if (!inFunctionExpression) { code.appendLeft(constructor.end, ';'); }
				}
	
				var namedFunctions =
					this.program.options.namedFunctionExpressions !== false;
				var namedConstructor =
					namedFunctions ||
					this.parent.superClass ||
					this.parent.type !== 'ClassDeclaration';
				if (this.parent.superClass) {
					var inheritanceBlock = "if ( " + superName + " ) " + name + ".__proto__ = " + superName + ";\n" + i0 + name + ".prototype = Object.create( " + superName + " && " + superName + ".prototype );\n" + i0 + name + ".prototype.constructor = " + name + ";";
	
					if (constructor) {
						introBlock += "\n\n" + i0 + inheritanceBlock;
					} else {
						var fn =
							"function " + name + " () {" +
							(superName
								? ("\n" + i1 + superName + ".apply(this, arguments);\n" + i0 + "}")
								: "}") +
							(inFunctionExpression ? '' : ';') +
							(this.body.length ? ("\n\n" + i0) : '');
	
						inheritanceBlock = fn + inheritanceBlock;
						introBlock += inheritanceBlock + "\n\n" + i0;
					}
				} else if (!constructor) {
					var fn$1 = 'function ' + (namedConstructor ? name + ' ' : '') + '() {}';
					if (this.parent.type === 'ClassDeclaration') { fn$1 += ';'; }
					if (this.body.length) { fn$1 += "\n\n" + i0; }
	
					introBlock += fn$1;
				}
	
				var scope = this.findScope(false);
	
				var prototypeGettersAndSetters = [];
				var staticGettersAndSetters = [];
				var prototypeAccessors;
				var staticAccessors;
	
				this.body.forEach(function (method, i) {
					if (method.kind === 'constructor') {
						var constructorName = namedConstructor ? ' ' + name : '';
						code.overwrite(
							method.key.start,
							method.key.end,
							("function" + constructorName)
						);
						return;
					}
	
					if (method.static) {
						var len = code.original[method.start + 6] == ' ' ? 7 : 6;
						code.remove(method.start, method.start + len);
					}
	
					var isAccessor = method.kind !== 'method';
					var lhs;
	
					var methodName = method.key.name;
					if (
						reserved[methodName] ||
						method.value.body.scope.references[methodName]
					) {
						methodName = scope.createIdentifier(methodName);
					}
	
					// when method name is a string or a number let's pretend it's a computed method
	
					var fake_computed = false;
					if (!method.computed && method.key.type === 'Literal') {
						fake_computed = true;
						method.computed = true;
					}
	
					if (isAccessor) {
						if (method.computed) {
							throw new Error(
								'Computed accessor properties are not currently supported'
							);
						}
	
						code.remove(method.start, method.key.start);
	
						if (method.static) {
							if (!~staticGettersAndSetters.indexOf(method.key.name))
								{ staticGettersAndSetters.push(method.key.name); }
							if (!staticAccessors)
								{ staticAccessors = scope.createIdentifier('staticAccessors'); }
	
							lhs = "" + staticAccessors;
						} else {
							if (!~prototypeGettersAndSetters.indexOf(method.key.name))
								{ prototypeGettersAndSetters.push(method.key.name); }
							if (!prototypeAccessors)
								{ prototypeAccessors = scope.createIdentifier('prototypeAccessors'); }
	
							lhs = "" + prototypeAccessors;
						}
					} else {
						lhs = method.static ? ("" + name) : (name + ".prototype");
					}
	
					if (!method.computed) { lhs += '.'; }
	
					var insertNewlines =
						(constructorIndex > 0 && i === constructorIndex + 1) ||
						(i === 0 && constructorIndex === this$1.body.length - 1);
	
					if (insertNewlines) { lhs = "\n\n" + i0 + lhs; }
	
					var c = method.key.end;
					if (method.computed) {
						if (fake_computed) {
							code.prependRight(method.key.start, '[');
							code.appendLeft(method.key.end, ']');
						} else {
							while (code.original[c] !== ']') { c += 1; }
							c += 1;
						}
					}
	
					var funcName =
						method.computed || isAccessor || !namedFunctions
							? ''
							: (methodName + " ");
					var rhs =
						(isAccessor ? ("." + (method.kind)) : '') +
						" = function" +
						(method.value.generator ? '* ' : ' ') +
						funcName;
					code.remove(c, method.value.start);
					code.prependRight(method.value.start, rhs);
					code.appendLeft(method.end, ';');
	
					if (method.value.generator) { code.remove(method.start, method.key.start); }
	
					code.prependRight(method.start, lhs);
				});
	
				if (prototypeGettersAndSetters.length || staticGettersAndSetters.length) {
					var intro = [];
					var outro = [];
	
					if (prototypeGettersAndSetters.length) {
						intro.push(
							("var " + prototypeAccessors + " = { " + (prototypeGettersAndSetters
								.map(function (name) { return (name + ": { configurable: true }"); })
								.join(',')) + " };")
						);
						outro.push(
							("Object.defineProperties( " + name + ".prototype, " + prototypeAccessors + " );")
						);
					}
	
					if (staticGettersAndSetters.length) {
						intro.push(
							("var " + staticAccessors + " = { " + (staticGettersAndSetters
								.map(function (name) { return (name + ": { configurable: true }"); })
								.join(',')) + " };")
						);
						outro.push(("Object.defineProperties( " + name + ", " + staticAccessors + " );"));
					}
	
					if (constructor) { introBlock += "\n\n" + i0; }
					introBlock += intro.join(("\n" + i0));
					if (!constructor) { introBlock += "\n\n" + i0; }
	
					outroBlock += "\n\n" + i0 + outro.join(("\n" + i0));
				}
	
				if (constructor) {
					code.appendLeft(constructor.end, introBlock);
				} else {
					code.prependRight(this.start, introBlock);
				}
	
				code.appendLeft(this.end, outroBlock);
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return ClassBody;
	}(Node));
	
	// TODO this function is slightly flawed  it works on the original string,
	// not its current edited state.
	// That's not a problem for the way that it's currently used, but it could
	// be in future...
	function deindent(node, code) {
		var start = node.start;
		var end = node.end;
	
		var indentStr = code.getIndentString();
		var indentStrLen = indentStr.length;
		var indentStart = start - indentStrLen;
	
		if (
			!node.program.indentExclusions[indentStart] &&
			code.original.slice(indentStart, start) === indentStr
		) {
			code.remove(indentStart, start);
		}
	
		var pattern = new RegExp(indentStr + '\\S', 'g');
		var slice = code.original.slice(start, end);
		var match;
	
		while ((match = pattern.exec(slice))) {
			var removeStart = start + match.index;
			if (!node.program.indentExclusions[removeStart]) {
				code.remove(removeStart, removeStart + indentStrLen);
			}
		}
	}
	
	var ClassDeclaration = (function (Node$$1) {
		function ClassDeclaration () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ClassDeclaration.__proto__ = Node$$1;
		ClassDeclaration.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ClassDeclaration.prototype.constructor = ClassDeclaration;
	
		ClassDeclaration.prototype.initialise = function initialise (transforms) {
			if (this.id) {
				this.name = this.id.name;
				this.findScope(true).addDeclaration(this.id, 'class');
			} else {
				this.name = this.findScope(true).createIdentifier("defaultExport");
			}
	
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		ClassDeclaration.prototype.transpile = function transpile (code, transforms) {
			if (transforms.classes) {
				if (!this.superClass) { deindent(this.body, code); }
	
				var superName =
					this.superClass && (this.superClass.name || 'superclass');
	
				var i0 = this.getIndentation();
				var i1 = i0 + code.getIndentString();
	
				// if this is an export default statement, we have to move the export to
				// after the declaration, because `export default var Foo = ...` is illegal
				var isExportDefaultDeclaration = this.parent.type === 'ExportDefaultDeclaration';
	
				if (isExportDefaultDeclaration) {
					code.remove(this.parent.start, this.start);
				}
	
				var c = this.start;
				if (this.id) {
					code.overwrite(c, this.id.start, 'var ');
					c = this.id.end;
				} else {
					code.prependLeft(c, ("var " + (this.name)));
				}
	
				if (this.superClass) {
					if (this.superClass.end === this.body.start) {
						code.remove(c, this.superClass.start);
						code.appendLeft(c, (" = (function (" + superName + ") {\n" + i1));
					} else {
						code.overwrite(c, this.superClass.start, ' = ');
						code.overwrite(
							this.superClass.end,
							this.body.start,
							("(function (" + superName + ") {\n" + i1)
						);
					}
				} else {
					if (c === this.body.start) {
						code.appendLeft(c, ' = ');
					} else {
						code.overwrite(c, this.body.start, ' = ');
					}
				}
	
				this.body.transpile(code, transforms, !!this.superClass, superName);
	
				var syntheticDefaultExport =
					isExportDefaultDeclaration
						? ("\n\n" + i0 + "export default " + (this.name) + ";")
						: '';
				if (this.superClass) {
					code.appendLeft(this.end, ("\n\n" + i1 + "return " + (this.name) + ";\n" + i0 + "}("));
					code.move(this.superClass.start, this.superClass.end, this.end);
					code.prependRight(this.end, ("));" + syntheticDefaultExport));
				} else if (syntheticDefaultExport) {
					code.prependRight(this.end, syntheticDefaultExport);
				}
			} else {
				this.body.transpile(code, transforms, false, null);
			}
		};
	
		return ClassDeclaration;
	}(Node));
	
	var ClassExpression = (function (Node$$1) {
		function ClassExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ClassExpression.__proto__ = Node$$1;
		ClassExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ClassExpression.prototype.constructor = ClassExpression;
	
		ClassExpression.prototype.initialise = function initialise (transforms) {
			this.name = ( this.id
				? this.id.name
				: this.parent.type === 'VariableDeclarator'
					? this.parent.id.name
					: this.parent.type !== 'AssignmentExpression'
						? null
						: this.parent.left.type === 'Identifier'
							? this.parent.left.name
							: this.parent.left.type === 'MemberExpression'
								? this.parent.left.property.name
								: null ) || this.findScope(true).createIdentifier('anonymous');
	
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		ClassExpression.prototype.transpile = function transpile (code, transforms) {
			if (transforms.classes) {
				var superName =
					this.superClass && (this.superClass.name || 'superclass');
	
				var i0 = this.getIndentation();
				var i1 = i0 + code.getIndentString();
	
				if (this.superClass) {
					code.remove(this.start, this.superClass.start);
					code.remove(this.superClass.end, this.body.start);
					code.appendLeft(this.start, ("(function (" + superName + ") {\n" + i1));
				} else {
					code.overwrite(this.start, this.body.start, ("(function () {\n" + i1));
				}
	
				this.body.transpile(code, transforms, true, superName);
	
				var outro = "\n\n" + i1 + "return " + (this.name) + ";\n" + i0 + "}(";
	
				if (this.superClass) {
					code.appendLeft(this.end, outro);
					code.move(this.superClass.start, this.superClass.end, this.end);
					code.prependRight(this.end, '))');
				} else {
					code.appendLeft(this.end, ("\n\n" + i1 + "return " + (this.name) + ";\n" + i0 + "}())"));
				}
			} else {
				this.body.transpile(code, transforms, false);
			}
		};
	
		return ClassExpression;
	}(Node));
	
	var ContinueStatement = (function (Node$$1) {
		function ContinueStatement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ContinueStatement.__proto__ = Node$$1;
		ContinueStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ContinueStatement.prototype.constructor = ContinueStatement;
	
		ContinueStatement.prototype.transpile = function transpile (code) {
			var loop = this.findNearest(loopStatement);
			if (loop.shouldRewriteAsFunction) {
				if (this.label)
					{ throw new CompileError(
						'Labels are not currently supported in a loop with locally-scoped variables',
						this
					); }
				code.overwrite(this.start, this.start + 8, 'return');
			}
		};
	
		return ContinueStatement;
	}(Node));
	
	var ExportDefaultDeclaration = (function (Node$$1) {
		function ExportDefaultDeclaration () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ExportDefaultDeclaration.__proto__ = Node$$1;
		ExportDefaultDeclaration.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ExportDefaultDeclaration.prototype.constructor = ExportDefaultDeclaration;
	
		ExportDefaultDeclaration.prototype.initialise = function initialise (transforms) {
			if (transforms.moduleExport)
				{ throw new CompileError('export is not supported', this); }
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		return ExportDefaultDeclaration;
	}(Node));
	
	var ExportNamedDeclaration = (function (Node$$1) {
		function ExportNamedDeclaration () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ExportNamedDeclaration.__proto__ = Node$$1;
		ExportNamedDeclaration.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ExportNamedDeclaration.prototype.constructor = ExportNamedDeclaration;
	
		ExportNamedDeclaration.prototype.initialise = function initialise (transforms) {
			if (transforms.moduleExport)
				{ throw new CompileError('export is not supported', this); }
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		return ExportNamedDeclaration;
	}(Node));
	
	var LoopStatement = (function (Node$$1) {
		function LoopStatement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) LoopStatement.__proto__ = Node$$1;
		LoopStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		LoopStatement.prototype.constructor = LoopStatement;
	
		LoopStatement.prototype.findScope = function findScope (functionScope) {
			return functionScope || !this.createdScope
				? this.parent.findScope(functionScope)
				: this.body.scope;
		};
	
		LoopStatement.prototype.initialise = function initialise (transforms) {
			var this$1 = this;
	
			this.body.createScope();
			this.createdScope = true;
	
			// this is populated as and when reassignments occur
			this.reassigned = Object.create(null);
			this.aliases = Object.create(null);
	
			Node$$1.prototype.initialise.call(this, transforms);
	
			if (transforms.letConst) {
				// see if any block-scoped declarations are referenced
				// inside function expressions
				var names = Object.keys(this.body.scope.declarations);
	
				var i = names.length;
				while (i--) {
					var name = names[i];
					var declaration = this$1.body.scope.declarations[name];
	
					var j = declaration.instances.length;
					while (j--) {
						var instance = declaration.instances[j];
						var nearestFunctionExpression = instance.findNearest(/Function/);
	
						if (
							nearestFunctionExpression &&
							nearestFunctionExpression.depth > this$1.depth
						) {
							this$1.shouldRewriteAsFunction = true;
							break;
						}
					}
	
					if (this$1.shouldRewriteAsFunction) { break; }
				}
			}
		};
	
		LoopStatement.prototype.transpile = function transpile (code, transforms) {
			var needsBlock =
				this.type != 'ForOfStatement' &&
				(this.body.type !== 'BlockStatement' ||
					(this.body.type === 'BlockStatement' && this.body.synthetic));
	
			if (this.shouldRewriteAsFunction) {
				var i0 = this.getIndentation();
				var i1 = i0 + code.getIndentString();
	
				var argString = this.args ? (" " + (this.args.join(', ')) + " ") : '';
				var paramString = this.params ? (" " + (this.params.join(', ')) + " ") : '';
	
				var functionScope = this.findScope(true);
				var loop = functionScope.createIdentifier('loop');
	
				var before =
					"var " + loop + " = function (" + paramString + ") " +
					(this.body.synthetic ? ("{\n" + i0 + (code.getIndentString())) : '');
				var after = (this.body.synthetic ? ("\n" + i0 + "}") : '') + ";\n\n" + i0;
	
				code.prependRight(this.body.start, before);
				code.appendLeft(this.body.end, after);
				code.move(this.start, this.body.start, this.body.end);
	
				if (this.canBreak || this.canReturn) {
					var returned = functionScope.createIdentifier('returned');
	
					var insert = "{\n" + i1 + "var " + returned + " = " + loop + "(" + argString + ");\n";
					if (this.canBreak)
						{ insert += "\n" + i1 + "if ( " + returned + " === 'break' ) break;"; }
					if (this.canReturn)
						{ insert += "\n" + i1 + "if ( " + returned + " ) return " + returned + ".v;"; }
					insert += "\n" + i0 + "}";
	
					code.prependRight(this.body.end, insert);
				} else {
					var callExpression = loop + "(" + argString + ");";
	
					if (this.type === 'DoWhileStatement') {
						code.overwrite(
							this.start,
							this.body.start,
							("do {\n" + i1 + callExpression + "\n" + i0 + "}")
						);
					} else {
						code.prependRight(this.body.end, callExpression);
					}
				}
			} else if (needsBlock) {
				code.appendLeft(this.body.start, '{ ');
				code.prependRight(this.body.end, ' }');
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return LoopStatement;
	}(Node));
	
	var ForStatement = (function (LoopStatement$$1) {
		function ForStatement () {
			LoopStatement$$1.apply(this, arguments);
		}
	
		if ( LoopStatement$$1 ) ForStatement.__proto__ = LoopStatement$$1;
		ForStatement.prototype = Object.create( LoopStatement$$1 && LoopStatement$$1.prototype );
		ForStatement.prototype.constructor = ForStatement;
	
		ForStatement.prototype.findScope = function findScope (functionScope) {
			return functionScope || !this.createdScope
				? this.parent.findScope(functionScope)
				: this.body.scope;
		};
	
		ForStatement.prototype.transpile = function transpile (code, transforms) {
			var this$1 = this;
	
			var i1 = this.getIndentation() + code.getIndentString();
	
			if (this.shouldRewriteAsFunction) {
				// which variables are declared in the init statement?
				var names =
					this.init.type === 'VariableDeclaration'
						? [].concat.apply(
								[],
								this.init.declarations.map(function (declarator) { return extractNames(declarator.id); }
								)
							)
						: [];
	
				var aliases = this.aliases;
	
				this.args = names.map(
					function (name) { return (name in this$1.aliases ? this$1.aliases[name].outer : name); }
				);
				this.params = names.map(
					function (name) { return (name in this$1.aliases ? this$1.aliases[name].inner : name); }
				);
	
				var updates = Object.keys(this.reassigned).map(
					function (name) { return ((aliases[name].outer) + " = " + (aliases[name].inner) + ";"); }
				);
	
				if (updates.length) {
					if (this.body.synthetic) {
						code.appendLeft(this.body.body[0].end, ("; " + (updates.join(" "))));
					} else {
						var lastStatement = this.body.body[this.body.body.length - 1];
						code.appendLeft(
							lastStatement.end,
							("\n\n" + i1 + (updates.join(("\n" + i1))))
						);
					}
				}
			}
	
			LoopStatement$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return ForStatement;
	}(LoopStatement));
	
	var ForInStatement = (function (LoopStatement$$1) {
		function ForInStatement () {
			LoopStatement$$1.apply(this, arguments);
		}
	
		if ( LoopStatement$$1 ) ForInStatement.__proto__ = LoopStatement$$1;
		ForInStatement.prototype = Object.create( LoopStatement$$1 && LoopStatement$$1.prototype );
		ForInStatement.prototype.constructor = ForInStatement;
	
		ForInStatement.prototype.findScope = function findScope (functionScope) {
			return functionScope || !this.createdScope
				? this.parent.findScope(functionScope)
				: this.body.scope;
		};
	
		ForInStatement.prototype.transpile = function transpile (code, transforms) {
			var this$1 = this;
	
			var hasDeclaration = this.left.type === 'VariableDeclaration';
	
			if (this.shouldRewriteAsFunction) {
				// which variables are declared in the init statement?
				var names =
					hasDeclaration
						? [].concat.apply(
								[],
								this.left.declarations.map(function (declarator) { return extractNames(declarator.id); }
								)
							)
						: [];
	
				this.args = names.map(
					function (name) { return (name in this$1.aliases ? this$1.aliases[name].outer : name); }
				);
				this.params = names.map(
					function (name) { return (name in this$1.aliases ? this$1.aliases[name].inner : name); }
				);
			}
	
			LoopStatement$$1.prototype.transpile.call(this, code, transforms);
	
			var maybePattern = hasDeclaration ? this.left.declarations[0].id : this.left;
			if (maybePattern.type !== 'Identifier') {
				this.destructurePattern(code, maybePattern, hasDeclaration);
			}
		};
	
		ForInStatement.prototype.destructurePattern = function destructurePattern (code, pattern, isDeclaration) {
			var scope = this.findScope(true);
			var i0 = this.getIndentation();
			var i1 = i0 + code.getIndentString();
	
			var ref = scope.createIdentifier('ref');
	
			var bodyStart = this.body.body.length ? this.body.body[0].start : this.body.start + 1;
	
			code.move(pattern.start, pattern.end, bodyStart);
	
			code.prependRight(pattern.end, isDeclaration ? ref : ("var " + ref));
	
			var statementGenerators = [];
			destructure(
				code,
				function (id) { return scope.createIdentifier(id); },
				function (ref) {
					var name = ref.name;
	
					return scope.resolveName(name);
			},
				pattern,
				ref,
				false,
				statementGenerators
			);
	
			var suffix = ";\n" + i1;
			statementGenerators.forEach(function (fn, i) {
				if (i === statementGenerators.length - 1) {
					suffix = ";\n\n" + i1;
				}
	
				fn(bodyStart, '', suffix);
			});
		};
	
		return ForInStatement;
	}(LoopStatement));
	
	var ForOfStatement = (function (LoopStatement$$1) {
		function ForOfStatement () {
			LoopStatement$$1.apply(this, arguments);
		}
	
		if ( LoopStatement$$1 ) ForOfStatement.__proto__ = LoopStatement$$1;
		ForOfStatement.prototype = Object.create( LoopStatement$$1 && LoopStatement$$1.prototype );
		ForOfStatement.prototype.constructor = ForOfStatement;
	
		ForOfStatement.prototype.initialise = function initialise (transforms) {
			if (transforms.forOf && !transforms.dangerousForOf)
				{ throw new CompileError(
					"for...of statements are not supported. Use `transforms: { forOf: false }` to skip transformation and disable this error, or `transforms: { dangerousForOf: true }` if you know what you're doing",
					this
				); }
			LoopStatement$$1.prototype.initialise.call(this, transforms);
		};
	
		ForOfStatement.prototype.transpile = function transpile (code, transforms) {
			LoopStatement$$1.prototype.transpile.call(this, code, transforms);
			if (!transforms.dangerousForOf) { return; }
	
			// edge case (#80)
			if (!this.body.body[0]) {
				if (
					this.left.type === 'VariableDeclaration' &&
					this.left.kind === 'var'
				) {
					code.remove(this.start, this.left.start);
					code.appendLeft(this.left.end, ';');
					code.remove(this.left.end, this.end);
				} else {
					code.remove(this.start, this.end);
				}
	
				return;
			}
	
			var scope = this.findScope(true);
			var i0 = this.getIndentation();
			var i1 = i0 + code.getIndentString();
	
			var key = scope.createIdentifier('i');
			var list = scope.createIdentifier('list');
	
			if (this.body.synthetic) {
				code.prependRight(this.left.start, ("{\n" + i1));
				code.appendLeft(this.body.body[0].end, ("\n" + i0 + "}"));
			}
	
			var bodyStart = this.body.body[0].start;
	
			code.remove(this.left.end, this.right.start);
			code.move(this.left.start, this.left.end, bodyStart);
	
			code.prependRight(this.right.start, ("var " + key + " = 0, " + list + " = "));
			code.appendLeft(this.right.end, ("; " + key + " < " + list + ".length; " + key + " += 1"));
	
			var isDeclaration = this.left.type === 'VariableDeclaration';
			var maybeDestructuring = isDeclaration ? this.left.declarations[0].id : this.left;
			if (maybeDestructuring.type !== 'Identifier') {
				var statementGenerators = [];
				var ref = scope.createIdentifier('ref');
				destructure(
					code,
					function (id) { return scope.createIdentifier(id); },
					function (ref) {
						var name = ref.name;
	
						return scope.resolveName(name);
				},
					maybeDestructuring,
					ref,
					!isDeclaration,
					statementGenerators
				);
	
				var suffix = ";\n" + i1;
				statementGenerators.forEach(function (fn, i) {
					if (i === statementGenerators.length - 1) {
						suffix = ";\n\n" + i1;
					}
	
					fn(bodyStart, '', suffix);
				});
	
				if (isDeclaration) {
					code.appendLeft(this.left.start + this.left.kind.length + 1, ref);
					code.appendLeft(this.left.end, (" = " + list + "[" + key + "];\n" + i1));
				} else {
					code.appendLeft(this.left.end, ("var " + ref + " = " + list + "[" + key + "];\n" + i1));
				}
			} else {
				code.appendLeft(this.left.end, (" = " + list + "[" + key + "];\n\n" + i1));
			}
		};
	
		return ForOfStatement;
	}(LoopStatement));
	
	var FunctionDeclaration = (function (Node$$1) {
		function FunctionDeclaration () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) FunctionDeclaration.__proto__ = Node$$1;
		FunctionDeclaration.prototype = Object.create( Node$$1 && Node$$1.prototype );
		FunctionDeclaration.prototype.constructor = FunctionDeclaration;
	
		FunctionDeclaration.prototype.initialise = function initialise (transforms) {
			if (this.generator && transforms.generator) {
				throw new CompileError('Generators are not supported', this);
			}
	
			this.body.createScope();
	
			if (this.id) {
				this.findScope(true).addDeclaration(this.id, 'function');
			}
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		FunctionDeclaration.prototype.transpile = function transpile (code, transforms) {
			Node$$1.prototype.transpile.call(this, code, transforms);
			if (transforms.trailingFunctionCommas && this.params.length) {
				removeTrailingComma(code, this.params[this.params.length - 1].end);
			}
		};
	
		return FunctionDeclaration;
	}(Node));
	
	var FunctionExpression = (function (Node$$1) {
		function FunctionExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) FunctionExpression.__proto__ = Node$$1;
		FunctionExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		FunctionExpression.prototype.constructor = FunctionExpression;
	
		FunctionExpression.prototype.initialise = function initialise (transforms) {
			var this$1 = this;
	
			if (this.generator && transforms.generator) {
				throw new CompileError('Generators are not supported', this);
			}
	
			this.body.createScope();
	
			if (this.id) {
				// function expression IDs belong to the child scope...
				this.body.scope.addDeclaration(this.id, 'function');
			}
	
			Node$$1.prototype.initialise.call(this, transforms);
	
			var parent = this.parent;
			var methodName;
	
			if (
				transforms.conciseMethodProperty &&
				parent.type === 'Property' &&
				parent.kind === 'init' &&
				parent.method &&
				parent.key.type === 'Identifier'
			) {
				// object literal concise method
				methodName = parent.key.name;
			} else if (
				transforms.classes &&
				parent.type === 'MethodDefinition' &&
				parent.kind === 'method' &&
				parent.key.type === 'Identifier'
			) {
				// method definition in a class
				methodName = parent.key.name;
			} else if (this.id && this.id.type === 'Identifier') {
				// naked function expression
				methodName = this.id.alias || this.id.name;
			}
	
			if (methodName) {
				for (var i$1 = 0, list$1 = this$1.params; i$1 < list$1.length; i$1 += 1) {
					var param = list$1[i$1];
	
					if (param.type === 'Identifier' && methodName === param.name) {
						// workaround for Safari 9/WebKit bug:
						// https://gitlab.com/Rich-Harris/buble/issues/154
						// change parameter name when same as method name
	
						var scope = this$1.body.scope;
						var declaration = scope.declarations[methodName];
	
						var alias = scope.createIdentifier(methodName);
						param.alias = alias;
	
						for (var i = 0, list = declaration.instances; i < list.length; i += 1) {
							var identifier = list[i];
	
							identifier.alias = alias;
						}
	
						break;
					}
				}
			}
		};
	
		FunctionExpression.prototype.transpile = function transpile (code, transforms) {
			Node$$1.prototype.transpile.call(this, code, transforms);
			if (transforms.trailingFunctionCommas && this.params.length) {
				removeTrailingComma(code, this.params[this.params.length - 1].end);
			}
		};
	
		return FunctionExpression;
	}(Node));
	
	function isReference(node, parent) {
		if (node.type === 'MemberExpression') {
			return !node.computed && isReference(node.object, node);
		}
	
		if (node.type === 'Identifier') {
			// the only time we could have an identifier node without a parent is
			// if it's the entire body of a function without a block statement 
			// i.e. an arrow function expression like `a => a`
			if (!parent) { return true; }
	
			if (/(Function|Class)Expression/.test(parent.type)) { return false; }
	
			if (parent.type === 'VariableDeclarator') { return node === parent.init; }
	
			// TODO is this right?
			if (
				parent.type === 'MemberExpression' ||
				parent.type === 'MethodDefinition'
			) {
				return parent.computed || node === parent.object;
			}
	
			if (parent.type === 'ArrayPattern') { return false; }
	
			// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
			if (parent.type === 'Property') {
				if (parent.parent.type === 'ObjectPattern') { return false; }
				return parent.computed || node === parent.value;
			}
	
			// disregard the `bar` in `class Foo { bar () {...} }`
			if (parent.type === 'MethodDefinition') { return false; }
	
			// disregard the `bar` in `export { foo as bar }`
			if (parent.type === 'ExportSpecifier' && node !== parent.local)
				{ return false; }
	
			return true;
		}
	}
	
	var Identifier = (function (Node$$1) {
		function Identifier () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) Identifier.__proto__ = Node$$1;
		Identifier.prototype = Object.create( Node$$1 && Node$$1.prototype );
		Identifier.prototype.constructor = Identifier;
	
		Identifier.prototype.findScope = function findScope (functionScope) {
			if (this.parent.params && ~this.parent.params.indexOf(this)) {
				return this.parent.body.scope;
			}
	
			if (this.parent.type === 'FunctionExpression' && this === this.parent.id) {
				return this.parent.body.scope;
			}
	
			return this.parent.findScope(functionScope);
		};
	
		Identifier.prototype.initialise = function initialise (transforms) {
			if (isReference(this, this.parent)) {
				if (
					transforms.arrow &&
					this.name === 'arguments' &&
					!this.findScope(false).contains(this.name)
				) {
					var lexicalBoundary = this.findLexicalBoundary();
					var arrowFunction = this.findNearest('ArrowFunctionExpression');
					var loop = this.findNearest(loopStatement);
	
					if (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {
						this.alias = lexicalBoundary.getArgumentsAlias();
					}
	
					if (
						loop &&
						loop.body.contains(this) &&
						loop.depth > lexicalBoundary.depth
					) {
						this.alias = lexicalBoundary.getArgumentsAlias();
					}
				}
	
				this.findScope(false).addReference(this);
			}
		};
	
		Identifier.prototype.transpile = function transpile (code) {
			if (this.alias) {
				code.overwrite(this.start, this.end, this.alias, {
					storeName: true,
					contentOnly: true
				});
			}
		};
	
		return Identifier;
	}(Node));
	
	var IfStatement = (function (Node$$1) {
		function IfStatement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) IfStatement.__proto__ = Node$$1;
		IfStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		IfStatement.prototype.constructor = IfStatement;
	
		IfStatement.prototype.initialise = function initialise (transforms) {
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		IfStatement.prototype.transpile = function transpile (code, transforms) {
			if (
				this.consequent.type !== 'BlockStatement' ||
				(this.consequent.type === 'BlockStatement' && this.consequent.synthetic)
			) {
				code.appendLeft(this.consequent.start, '{ ');
				code.prependRight(this.consequent.end, ' }');
			}
	
			if (
				this.alternate &&
				this.alternate.type !== 'IfStatement' &&
				(this.alternate.type !== 'BlockStatement' ||
					(this.alternate.type === 'BlockStatement' && this.alternate.synthetic))
			) {
				code.appendLeft(this.alternate.start, '{ ');
				code.prependRight(this.alternate.end, ' }');
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return IfStatement;
	}(Node));
	
	var ImportDeclaration = (function (Node$$1) {
		function ImportDeclaration () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ImportDeclaration.__proto__ = Node$$1;
		ImportDeclaration.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ImportDeclaration.prototype.constructor = ImportDeclaration;
	
		ImportDeclaration.prototype.initialise = function initialise (transforms) {
			if (transforms.moduleImport)
				{ throw new CompileError('import is not supported', this); }
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		return ImportDeclaration;
	}(Node));
	
	var ImportDefaultSpecifier = (function (Node$$1) {
		function ImportDefaultSpecifier () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ImportDefaultSpecifier.__proto__ = Node$$1;
		ImportDefaultSpecifier.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ImportDefaultSpecifier.prototype.constructor = ImportDefaultSpecifier;
	
		ImportDefaultSpecifier.prototype.initialise = function initialise (transforms) {
			this.findScope(true).addDeclaration(this.local, 'import');
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		return ImportDefaultSpecifier;
	}(Node));
	
	var ImportSpecifier = (function (Node$$1) {
		function ImportSpecifier () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ImportSpecifier.__proto__ = Node$$1;
		ImportSpecifier.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ImportSpecifier.prototype.constructor = ImportSpecifier;
	
		ImportSpecifier.prototype.initialise = function initialise (transforms) {
			this.findScope(true).addDeclaration(this.local, 'import');
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		return ImportSpecifier;
	}(Node));
	
	var hasDashes = function (val) { return /-/.test(val); };
	
	var formatKey = function (key) { return (hasDashes(key) ? ("'" + key + "'") : key); };
	
	var formatVal = function (val) { return (val ? '' : 'true'); };
	
	var JSXAttribute = (function (Node$$1) {
		function JSXAttribute () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) JSXAttribute.__proto__ = Node$$1;
		JSXAttribute.prototype = Object.create( Node$$1 && Node$$1.prototype );
		JSXAttribute.prototype.constructor = JSXAttribute;
	
		JSXAttribute.prototype.transpile = function transpile (code, transforms) {
			var ref = this.name;
			var start = ref.start;
			var name = ref.name;
	
			// Overwrite equals sign if value is present.
			var end = this.value ? this.value.start : this.name.end;
	
			code.overwrite(start, end, ((formatKey(name)) + ": " + (formatVal(this.value))));
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return JSXAttribute;
	}(Node));
	
	function containsNewLine(node) {
		return (
			node.type === 'JSXText' && !/\S/.test(node.value) && /\n/.test(node.value)
		);
	}
	
	var JSXClosingElement = (function (Node$$1) {
		function JSXClosingElement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) JSXClosingElement.__proto__ = Node$$1;
		JSXClosingElement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		JSXClosingElement.prototype.constructor = JSXClosingElement;
	
		JSXClosingElement.prototype.transpile = function transpile (code) {
			var spaceBeforeParen = true;
	
			var lastChild = this.parent.children[this.parent.children.length - 1];
	
			// omit space before closing paren if
			//   a) this is on a separate line, or
			//   b) there are no children but there are attributes
			if (
				(lastChild && containsNewLine(lastChild)) ||
				this.parent.openingElement.attributes.length
			) {
				spaceBeforeParen = false;
			}
	
			code.overwrite(this.start, this.end, spaceBeforeParen ? ' )' : ')');
		};
	
		return JSXClosingElement;
	}(Node));
	
	function containsNewLine$1(node) {
		return (
			node.type === 'JSXText' && !/\S/.test(node.value) && /\n/.test(node.value)
		);
	}
	
	var JSXClosingFragment = (function (Node$$1) {
		function JSXClosingFragment () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) JSXClosingFragment.__proto__ = Node$$1;
		JSXClosingFragment.prototype = Object.create( Node$$1 && Node$$1.prototype );
		JSXClosingFragment.prototype.constructor = JSXClosingFragment;
	
		JSXClosingFragment.prototype.transpile = function transpile (code) {
			var spaceBeforeParen = true;
	
			var lastChild = this.parent.children[this.parent.children.length - 1];
	
			// omit space before closing paren if this is on a separate line
			if (lastChild && containsNewLine$1(lastChild)) {
				spaceBeforeParen = false;
			}
	
			code.overwrite(this.start, this.end, spaceBeforeParen ? ' )' : ')');
		};
	
		return JSXClosingFragment;
	}(Node));
	
	function normalise(str, removeTrailingWhitespace) {
	
		str = str.replace(/\u00a0/g, '&nbsp;');
	
		if (removeTrailingWhitespace && /\n/.test(str)) {
			str = str.replace(/\s+$/, '');
		}
	
		str = str
			.replace(/^\n\r?\s+/, '') // remove leading newline + space
			.replace(/\s*\n\r?\s*/gm, ' '); // replace newlines with spaces
	
		// TODO prefer single quotes?
		return JSON.stringify(str);
	}
	
	var JSXElement = (function (Node$$1) {
		function JSXElement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) JSXElement.__proto__ = Node$$1;
		JSXElement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		JSXElement.prototype.constructor = JSXElement;
	
		JSXElement.prototype.transpile = function transpile (code, transforms) {
			Node$$1.prototype.transpile.call(this, code, transforms);
	
			var children = this.children.filter(function (child) {
				if (child.type !== 'JSXText') { return true; }
	
				// remove whitespace-only literals, unless on a single line
				return /\S/.test(child.raw) || !/\n/.test(child.raw);
			});
	
			if (children.length) {
				var c = this.openingElement.end;
	
				var i;
				for (i = 0; i < children.length; i += 1) {
					var child = children[i];
	
					if (
						child.type === 'JSXExpressionContainer' &&
						child.expression.type === 'JSXEmptyExpression'
					) {
						// empty block is a no op
					} else {
						var tail =
							code.original[c] === '\n' && child.type !== 'JSXText' ? '' : ' ';
						code.appendLeft(c, ("," + tail));
					}
	
					if (child.type === 'JSXText') {
						var str = normalise(child.value, i === children.length - 1);
						code.overwrite(child.start, child.end, str);
					}
	
					c = child.end;
				}
			}
		};
	
		return JSXElement;
	}(Node));
	
	var JSXExpressionContainer = (function (Node$$1) {
		function JSXExpressionContainer () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) JSXExpressionContainer.__proto__ = Node$$1;
		JSXExpressionContainer.prototype = Object.create( Node$$1 && Node$$1.prototype );
		JSXExpressionContainer.prototype.constructor = JSXExpressionContainer;
	
		JSXExpressionContainer.prototype.transpile = function transpile (code, transforms) {
			code.remove(this.start, this.expression.start);
			code.remove(this.expression.end, this.end);
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return JSXExpressionContainer;
	}(Node));
	
	var JSXFragment = (function (JSXElement$$1) {
		function JSXFragment () {
			JSXElement$$1.apply(this, arguments);
		}if ( JSXElement$$1 ) JSXFragment.__proto__ = JSXElement$$1;
		JSXFragment.prototype = Object.create( JSXElement$$1 && JSXElement$$1.prototype );
		JSXFragment.prototype.constructor = JSXFragment;
	
		
	
		return JSXFragment;
	}(JSXElement));
	
	var JSXOpeningElement = (function (Node$$1) {
		function JSXOpeningElement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) JSXOpeningElement.__proto__ = Node$$1;
		JSXOpeningElement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		JSXOpeningElement.prototype.constructor = JSXOpeningElement;
	
		JSXOpeningElement.prototype.transpile = function transpile (code, transforms) {
			var this$1 = this;
	
			Node$$1.prototype.transpile.call(this, code, transforms);
	
			code.overwrite(this.start, this.name.start, ((this.program.jsx) + "( "));
	
			var html =
				this.name.type === 'JSXIdentifier' &&
				this.name.name[0] === this.name.name[0].toLowerCase();
			if (html) { code.prependRight(this.name.start, "'"); }
	
			var len = this.attributes.length;
			var c = this.name.end;
	
			if (len) {
				var i;
	
				var hasSpread = false;
				for (i = 0; i < len; i += 1) {
					if (this$1.attributes[i].type === 'JSXSpreadAttribute') {
						hasSpread = true;
						break;
					}
				}
	
				c = this.attributes[0].end;
	
				for (i = 0; i < len; i += 1) {
					var attr = this$1.attributes[i];
	
					if (i > 0) {
						if (attr.start === c) { code.prependRight(c, ', '); }
						else { code.overwrite(c, attr.start, ', '); }
					}
	
					if (hasSpread && attr.type !== 'JSXSpreadAttribute') {
						var lastAttr = this$1.attributes[i - 1];
						var nextAttr = this$1.attributes[i + 1];
	
						if (!lastAttr || lastAttr.type === 'JSXSpreadAttribute') {
							code.prependRight(attr.start, '{ ');
						}
	
						if (!nextAttr || nextAttr.type === 'JSXSpreadAttribute') {
							code.appendLeft(attr.end, ' }');
						}
					}
	
					c = attr.end;
				}
	
				var after;
				var before;
				if (hasSpread) {
					if (len === 1) {
						before = html ? "'," : ',';
					} else {
						if (!this.program.options.objectAssign) {
							throw new CompileError(
								"Mixed JSX attributes ending in spread requires specified objectAssign option with 'Object.assign' or polyfill helper.",
								this
							);
						}
						before = html
							? ("', " + (this.program.options.objectAssign) + "({},")
							: (", " + (this.program.options.objectAssign) + "({},");
						after = ')';
					}
				} else {
					before = html ? "', {" : ', {';
					after = ' }';
				}
	
				code.prependRight(this.name.end, before);
	
				if (after) {
					code.appendLeft(this.attributes[len - 1].end, after);
				}
			} else {
				code.appendLeft(this.name.end, html ? "', null" : ", null");
				c = this.name.end;
			}
	
			if (this.selfClosing) {
				code.overwrite(c, this.end, this.attributes.length ? ")" : " )");
			} else {
				code.remove(c, this.end);
			}
		};
	
		return JSXOpeningElement;
	}(Node));
	
	var JSXOpeningFragment = (function (Node$$1) {
		function JSXOpeningFragment () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) JSXOpeningFragment.__proto__ = Node$$1;
		JSXOpeningFragment.prototype = Object.create( Node$$1 && Node$$1.prototype );
		JSXOpeningFragment.prototype.constructor = JSXOpeningFragment;
	
		JSXOpeningFragment.prototype.transpile = function transpile (code, transforms) {
			code.overwrite(this.start, this.end, ((this.program.jsx) + "( React.Fragment, null"));
		};
	
		return JSXOpeningFragment;
	}(Node));
	
	var JSXSpreadAttribute = (function (Node$$1) {
		function JSXSpreadAttribute () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) JSXSpreadAttribute.__proto__ = Node$$1;
		JSXSpreadAttribute.prototype = Object.create( Node$$1 && Node$$1.prototype );
		JSXSpreadAttribute.prototype.constructor = JSXSpreadAttribute;
	
		JSXSpreadAttribute.prototype.transpile = function transpile (code, transforms) {
			code.remove(this.start, this.argument.start);
			code.remove(this.argument.end, this.end);
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return JSXSpreadAttribute;
	}(Node));
	
	var regjsgen = createCommonjsModule(function (module, exports) {
	/*!
	 * regjsgen 0.3.0
	 * Copyright 2014-2016 Benjamin Tan <https://demoneaux.github.io/>
	 * Available under MIT license <https://github.com/demoneaux/regjsgen/blob/master/LICENSE>
	 */
	(function() {
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };
	
	  // Used as a reference to the global object.
	  var root = (objectTypes[typeof window] && window) || this;
	
	  // Detect free variable `exports`.
	  var freeExports = objectTypes['object'] && exports;
	
	  // Detect free variable `module`.
	  var freeModule = objectTypes['object'] && module && !module.nodeType && module;
	
	  // Detect free variable `global` from Node.js or Browserified code and use it as `root`.
	  var freeGlobal = freeExports && freeModule && typeof commonjsGlobal == 'object' && commonjsGlobal;
	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Used to check objects for own properties.
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  /*--------------------------------------------------------------------------*/
	
	  // Generates strings based on the given code points.
	  // Based on https://mths.be/fromcodepoint v0.2.0 by @mathias.
	  var stringFromCharCode = String.fromCharCode;
	  var floor = Math.floor;
	  function fromCodePoint() {
	    var MAX_SIZE = 0x4000;
	    var codeUnits = [];
	    var highSurrogate;
	    var lowSurrogate;
	    var index = -1;
	    var length = arguments.length;
	    if (!length) {
	      return '';
	    }
	    var result = '';
	    while (++index < length) {
	      var codePoint = Number(arguments[index]);
	      if (
	        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
	        codePoint < 0 || // not a valid Unicode code point
	        codePoint > 0x10FFFF || // not a valid Unicode code point
	        floor(codePoint) != codePoint // not an integer
	      ) {
	        throw RangeError('Invalid code point: ' + codePoint);
	      }
	      if (codePoint <= 0xFFFF) {
	        // BMP code point
	        codeUnits.push(codePoint);
	      } else {
	        // Astral code point; split in surrogate halves
	        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	        codePoint -= 0x10000;
	        highSurrogate = (codePoint >> 10) + 0xD800;
	        lowSurrogate = (codePoint % 0x400) + 0xDC00;
	        codeUnits.push(highSurrogate, lowSurrogate);
	      }
	      if (index + 1 == length || codeUnits.length > MAX_SIZE) {
	        result += stringFromCharCode.apply(null, codeUnits);
	        codeUnits.length = 0;
	      }
	    }
	    return result;
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  // Ensures that nodes have the correct types.
	  var assertTypeRegexMap = {};
	  function assertType(type, expected) {
	    if (expected.indexOf('|') == -1) {
	      if (type == expected) {
	        return;
	      }
	
	      throw Error('Invalid node type: ' + type + '; expected type: ' + expected);
	    }
	
	    expected = hasOwnProperty.call(assertTypeRegexMap, expected)
	      ? assertTypeRegexMap[expected]
	      : (assertTypeRegexMap[expected] = RegExp('^(?:' + expected + ')$'));
	
	    if (expected.test(type)) {
	      return;
	    }
	
	    throw Error('Invalid node type: ' + type + '; expected types: ' + expected);
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  // Generates a regular expression string based on an AST.
	  function generate(node) {
	    var type = node.type;
	
	    if (hasOwnProperty.call(generators, type)) {
	      return generators[type](node);
	    }
	
	    throw Error('Invalid node type: ' + type);
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  function generateAlternative(node) {
	    assertType(node.type, 'alternative');
	
	    var terms = node.body,
	        i = -1,
	        length = terms.length,
	        result = '';
	
	    while (++i < length) {
	      result += generateTerm(terms[i]);
	    }
	
	    return result;
	  }
	
	  function generateAnchor(node) {
	    assertType(node.type, 'anchor');
	
	    switch (node.kind) {
	      case 'start':
	        return '^';
	      case 'end':
	        return '$';
	      case 'boundary':
	        return '\\b';
	      case 'not-boundary':
	        return '\\B';
	      default:
	        throw Error('Invalid assertion');
	    }
	  }
	
	  function generateAtom(node) {
	    assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');
	
	    return generate(node);
	  }
	
	  function generateCharacterClass(node) {
	    assertType(node.type, 'characterClass');
	
	    var classRanges = node.body,
	        i = -1,
	        length = classRanges.length,
	        result = '';
	
	    if (node.negative) {
	      result += '^';
	    }
	
	    while (++i < length) {
	      result += generateClassAtom(classRanges[i]);
	    }
	
	    return '[' + result + ']';
	  }
	
	  function generateCharacterClassEscape(node) {
	    assertType(node.type, 'characterClassEscape');
	
	    return '\\' + node.value;
	  }
	
	  function generateUnicodePropertyEscape(node) {
	    assertType(node.type, 'unicodePropertyEscape');
	
	    return '\\' + (node.negative ? 'P' : 'p') + '{' + node.value + '}';
	  }
	
	  function generateCharacterClassRange(node) {
	    assertType(node.type, 'characterClassRange');
	
	    var min = node.min,
	        max = node.max;
	
	    if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
	      throw Error('Invalid character class range');
	    }
	
	    return generateClassAtom(min) + '-' + generateClassAtom(max);
	  }
	
	  function generateClassAtom(node) {
	    assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');
	
	    return generate(node);
	  }
	
	  function generateDisjunction(node) {
	    assertType(node.type, 'disjunction');
	
	    var body = node.body,
	        i = -1,
	        length = body.length,
	        result = '';
	
	    while (++i < length) {
	      if (i != 0) {
	        result += '|';
	      }
	      result += generate(body[i]);
	    }
	
	    return result;
	  }
	
	  function generateDot(node) {
	    assertType(node.type, 'dot');
	
	    return '.';
	  }
	
	  function generateGroup(node) {
	    assertType(node.type, 'group');
	
	    var result = '';
	
	    switch (node.behavior) {
	      case 'normal':
	        break;
	      case 'ignore':
	        result += '?:';
	        break;
	      case 'lookahead':
	        result += '?=';
	        break;
	      case 'negativeLookahead':
	        result += '?!';
	        break;
	      default:
	        throw Error('Invalid behaviour: ' + node.behaviour);
	    }
	
	    var body = node.body,
	        i = -1,
	        length = body.length;
	
	    while (++i < length) {
	      result += generate(body[i]);
	    }
	
	    return '(' + result + ')';
	  }
	
	  function generateQuantifier(node) {
	    assertType(node.type, 'quantifier');
	
	    var quantifier = '',
	        min = node.min,
	        max = node.max;
	
	    if (max == null) {
	      if (min == 0) {
	        quantifier = '*';
	      } else if (min == 1) {
	        quantifier = '+';
	      } else {
	        quantifier = '{' + min + ',}';
	      }
	    } else if (min == max) {
	      quantifier = '{' + min + '}';
	    } else if (min == 0 && max == 1) {
	      quantifier = '?';
	    } else {
	      quantifier = '{' + min + ',' + max + '}';
	    }
	
	    if (!node.greedy) {
	      quantifier += '?';
	    }
	
	    return generateAtom(node.body[0]) + quantifier;
	  }
	
	  function generateReference(node) {
	    assertType(node.type, 'reference');
	
	    return '\\' + node.matchIndex;
	  }
	
	  function generateTerm(node) {
	    assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|unicodePropertyEscape|value');
	
	    return generate(node);
	  }
	
	  function generateValue(node) {
	    assertType(node.type, 'value');
	
	    var kind = node.kind,
	        codePoint = node.codePoint;
	
	    switch (kind) {
	      case 'controlLetter':
	        return '\\c' + fromCodePoint(codePoint + 64);
	      case 'hexadecimalEscape':
	        return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);
	      case 'identifier':
	        return '\\' + fromCodePoint(codePoint);
	      case 'null':
	        return '\\' + codePoint;
	      case 'octal':
	        return '\\' + codePoint.toString(8);
	      case 'singleEscape':
	        switch (codePoint) {
	          case 0x0008:
	            return '\\b';
	          case 0x0009:
	            return '\\t';
	          case 0x000A:
	            return '\\n';
	          case 0x000B:
	            return '\\v';
	          case 0x000C:
	            return '\\f';
	          case 0x000D:
	            return '\\r';
	          default:
	            throw Error('Invalid codepoint: ' + codePoint);
	        }
	      case 'symbol':
	        return fromCodePoint(codePoint);
	      case 'unicodeEscape':
	        return '\\u' + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);
	      case 'unicodeCodePointEscape':
	        return '\\u{' + codePoint.toString(16).toUpperCase() + '}';
	      default:
	        throw Error('Unsupported node kind: ' + kind);
	    }
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  // Used to generate strings for each node type.
	  var generators = {
	    'alternative': generateAlternative,
	    'anchor': generateAnchor,
	    'characterClass': generateCharacterClass,
	    'characterClassEscape': generateCharacterClassEscape,
	    'characterClassRange': generateCharacterClassRange,
	    'unicodePropertyEscape': generateUnicodePropertyEscape,
	    'disjunction': generateDisjunction,
	    'dot': generateDot,
	    'group': generateGroup,
	    'quantifier': generateQuantifier,
	    'reference': generateReference,
	    'value': generateValue
	  };
	
	  /*--------------------------------------------------------------------------*/
	
	  // Export regjsgen.
	  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
	  if (false) {
	    // Define as an anonymous module so it can be aliased through path mapping.
	    undefined(function() {
	      return {
	        'generate': generate
	      };
	    });
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for CommonJS support.
	    freeExports.generate = generate;
	  }
	  else {
	    // Export to the global object.
	    root.regjsgen = {
	      'generate': generate
	    };
	  }
	}.call(commonjsGlobal));
	});
	
	var parser = createCommonjsModule(function (module) {
	// regjsparser
	//
	// ==================================================================
	//
	// See ECMA-262 Standard: 15.10.1
	//
	// NOTE: The ECMA-262 standard uses the term "Assertion" for /^/. Here the
	//   term "Anchor" is used.
	//
	// Pattern ::
	//      Disjunction
	//
	// Disjunction ::
	//      Alternative
	//      Alternative | Disjunction
	//
	// Alternative ::
	//      [empty]
	//      Alternative Term
	//
	// Term ::
	//      Anchor
	//      Atom
	//      Atom Quantifier
	//
	// Anchor ::
	//      ^
	//      $
	//      \ b
	//      \ B
	//      ( ? = Disjunction )
	//      ( ? ! Disjunction )
	//
	// Quantifier ::
	//      QuantifierPrefix
	//      QuantifierPrefix ?
	//
	// QuantifierPrefix ::
	//      *
	//      +
	//      ?
	//      { DecimalDigits }
	//      { DecimalDigits , }
	//      { DecimalDigits , DecimalDigits }
	//
	// Atom ::
	//      PatternCharacter
	//      .
	//      \ AtomEscape
	//      CharacterClass
	//      ( Disjunction )
	//      ( ? : Disjunction )
	//
	// PatternCharacter ::
	//      SourceCharacter but not any of: ^ $ \ . * + ? ( ) [ ] { } |
	//
	// AtomEscape ::
	//      DecimalEscape
	//      CharacterEscape
	//      CharacterClassEscape
	//
	// CharacterEscape[U] ::
	//      ControlEscape
	//      c ControlLetter
	//      HexEscapeSequence
	//      RegExpUnicodeEscapeSequence[?U] (ES6)
	//      IdentityEscape[?U]
	//
	// ControlEscape ::
	//      one of f n r t v
	// ControlLetter ::
	//      one of
	//          a b c d e f g h i j k l m n o p q r s t u v w x y z
	//          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
	//
	// IdentityEscape ::
	//      SourceCharacter but not IdentifierPart
	//      <ZWJ>
	//      <ZWNJ>
	//
	// DecimalEscape ::
	//      DecimalIntegerLiteral [lookahead  DecimalDigit]
	//
	// CharacterClassEscape ::
	//      one of d D s S w W
	//
	// CharacterClass ::
	//      [ [lookahead  {^}] ClassRanges ]
	//      [ ^ ClassRanges ]
	//
	// ClassRanges ::
	//      [empty]
	//      NonemptyClassRanges
	//
	// NonemptyClassRanges ::
	//      ClassAtom
	//      ClassAtom NonemptyClassRangesNoDash
	//      ClassAtom - ClassAtom ClassRanges
	//
	// NonemptyClassRangesNoDash ::
	//      ClassAtom
	//      ClassAtomNoDash NonemptyClassRangesNoDash
	//      ClassAtomNoDash - ClassAtom ClassRanges
	//
	// ClassAtom ::
	//      -
	//      ClassAtomNoDash
	//
	// ClassAtomNoDash ::
	//      SourceCharacter but not one of \ or ] or -
	//      \ ClassEscape
	//
	// ClassEscape ::
	//      DecimalEscape
	//      b
	//      CharacterEscape
	//      CharacterClassEscape
	
	(function() {
	
	  function parse(str, flags, features) {
	    if (!features) {
	      features = {};
	    }
	    function addRaw(node) {
	      node.raw = str.substring(node.range[0], node.range[1]);
	      return node;
	    }
	
	    function updateRawStart(node, start) {
	      node.range[0] = start;
	      return addRaw(node);
	    }
	
	    function createAnchor(kind, rawLength) {
	      return addRaw({
	        type: 'anchor',
	        kind: kind,
	        range: [
	          pos - rawLength,
	          pos
	        ]
	      });
	    }
	
	    function createValue(kind, codePoint, from, to) {
	      return addRaw({
	        type: 'value',
	        kind: kind,
	        codePoint: codePoint,
	        range: [from, to]
	      });
	    }
	
	    function createEscaped(kind, codePoint, value, fromOffset) {
	      fromOffset = fromOffset || 0;
	      return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
	    }
	
	    function createCharacter(matches) {
	      var _char = matches[0];
	      var first = _char.charCodeAt(0);
	      if (hasUnicodeFlag) {
	        var second;
	        if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
	          second = lookahead().charCodeAt(0);
	          if (second >= 0xDC00 && second <= 0xDFFF) {
	            // Unicode surrogate pair
	            pos++;
	            return createValue(
	                'symbol',
	                (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000,
	                pos - 2, pos);
	          }
	        }
	      }
	      return createValue('symbol', first, pos - 1, pos);
	    }
	
	    function createDisjunction(alternatives, from, to) {
	      return addRaw({
	        type: 'disjunction',
	        body: alternatives,
	        range: [
	          from,
	          to
	        ]
	      });
	    }
	
	    function createDot() {
	      return addRaw({
	        type: 'dot',
	        range: [
	          pos - 1,
	          pos
	        ]
	      });
	    }
	
	    function createCharacterClassEscape(value) {
	      return addRaw({
	        type: 'characterClassEscape',
	        value: value,
	        range: [
	          pos - 2,
	          pos
	        ]
	      });
	    }
	
	    function createReference(matchIndex) {
	      return addRaw({
	        type: 'reference',
	        matchIndex: parseInt(matchIndex, 10),
	        range: [
	          pos - 1 - matchIndex.length,
	          pos
	        ]
	      });
	    }
	
	    function createGroup(behavior, disjunction, from, to) {
	      return addRaw({
	        type: 'group',
	        behavior: behavior,
	        body: disjunction,
	        range: [
	          from,
	          to
	        ]
	      });
	    }
	
	    function createQuantifier(min, max, from, to) {
	      if (to == null) {
	        from = pos - 1;
	        to = pos;
	      }
	
	      return addRaw({
	        type: 'quantifier',
	        min: min,
	        max: max,
	        greedy: true,
	        body: null, // set later on
	        range: [
	          from,
	          to
	        ]
	      });
	    }
	
	    function createAlternative(terms, from, to) {
	      return addRaw({
	        type: 'alternative',
	        body: terms,
	        range: [
	          from,
	          to
	        ]
	      });
	    }
	
	    function createCharacterClass(classRanges, negative, from, to) {
	      return addRaw({
	        type: 'characterClass',
	        body: classRanges,
	        negative: negative,
	        range: [
	          from,
	          to
	        ]
	      });
	    }
	
	    function createClassRange(min, max, from, to) {
	      // See 15.10.2.15:
	      if (min.codePoint > max.codePoint) {
	        bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
	      }
	
	      return addRaw({
	        type: 'characterClassRange',
	        min: min,
	        max: max,
	        range: [
	          from,
	          to
	        ]
	      });
	    }
	
	    function flattenBody(body) {
	      if (body.type === 'alternative') {
	        return body.body;
	      } else {
	        return [body];
	      }
	    }
	
	    function incr(amount) {
	      amount = (amount || 1);
	      var res = str.substring(pos, pos + amount);
	      pos += (amount || 1);
	      return res;
	    }
	
	    function skip(value) {
	      if (!match(value)) {
	        bail('character', value);
	      }
	    }
	
	    function match(value) {
	      if (str.indexOf(value, pos) === pos) {
	        return incr(value.length);
	      }
	    }
	
	    function lookahead() {
	      return str[pos];
	    }
	
	    function current(value) {
	      return str.indexOf(value, pos) === pos;
	    }
	
	    function next(value) {
	      return str[pos + 1] === value;
	    }
	
	    function matchReg(regExp) {
	      var subStr = str.substring(pos);
	      var res = subStr.match(regExp);
	      if (res) {
	        res.range = [];
	        res.range[0] = pos;
	        incr(res[0].length);
	        res.range[1] = pos;
	      }
	      return res;
	    }
	
	    function parseDisjunction() {
	      // Disjunction ::
	      //      Alternative
	      //      Alternative | Disjunction
	      var res = [], from = pos;
	      res.push(parseAlternative());
	
	      while (match('|')) {
	        res.push(parseAlternative());
	      }
	
	      if (res.length === 1) {
	        return res[0];
	      }
	
	      return createDisjunction(res, from, pos);
	    }
	
	    function parseAlternative() {
	      var res = [], from = pos;
	      var term;
	
	      // Alternative ::
	      //      [empty]
	      //      Alternative Term
	      while (term = parseTerm()) {
	        res.push(term);
	      }
	
	      if (res.length === 1) {
	        return res[0];
	      }
	
	      return createAlternative(res, from, pos);
	    }
	
	    function parseTerm() {
	      // Term ::
	      //      Anchor
	      //      Atom
	      //      Atom Quantifier
	
	      if (pos >= str.length || current('|') || current(')')) {
	        return null; /* Means: The term is empty */
	      }
	
	      var anchor = parseAnchor();
	
	      if (anchor) {
	        return anchor;
	      }
	
	      var atom = parseAtom();
	      if (!atom) {
	        bail('Expected atom');
	      }
	      var quantifier = parseQuantifier() || false;
	      if (quantifier) {
	        quantifier.body = flattenBody(atom);
	        // The quantifier contains the atom. Therefore, the beginning of the
	        // quantifier range is given by the beginning of the atom.
	        updateRawStart(quantifier, atom.range[0]);
	        return quantifier;
	      }
	      return atom;
	    }
	
	    function parseGroup(matchA, typeA, matchB, typeB) {
	      var type = null, from = pos;
	
	      if (match(matchA)) {
	        type = typeA;
	      } else if (match(matchB)) {
	        type = typeB;
	      } else {
	        return false;
	      }
	
	      var body = parseDisjunction();
	      if (!body) {
	        bail('Expected disjunction');
	      }
	      skip(')');
	      var group = createGroup(type, flattenBody(body), from, pos);
	
	      if (type == 'normal') {
	        // Keep track of the number of closed groups. This is required for
	        // parseDecimalEscape(). In case the string is parsed a second time the
	        // value already holds the total count and no incrementation is required.
	        if (firstIteration) {
	          closedCaptureCounter++;
	        }
	      }
	      return group;
	    }
	
	    function parseAnchor() {
	      // Anchor ::
	      //      ^
	      //      $
	      //      \ b
	      //      \ B
	      //      ( ? = Disjunction )
	      //      ( ? ! Disjunction )
	      if (match('^')) {
	        return createAnchor('start', 1 /* rawLength */);
	      } else if (match('$')) {
	        return createAnchor('end', 1 /* rawLength */);
	      } else if (match('\\b')) {
	        return createAnchor('boundary', 2 /* rawLength */);
	      } else if (match('\\B')) {
	        return createAnchor('not-boundary', 2 /* rawLength */);
	      } else {
	        return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
	      }
	    }
	
	    function parseQuantifier() {
	      // Quantifier ::
	      //      QuantifierPrefix
	      //      QuantifierPrefix ?
	      //
	      // QuantifierPrefix ::
	      //      *
	      //      +
	      //      ?
	      //      { DecimalDigits }
	      //      { DecimalDigits , }
	      //      { DecimalDigits , DecimalDigits }
	
	      var res, from = pos;
	      var quantifier;
	      var min, max;
	
	      if (match('*')) {
	        quantifier = createQuantifier(0);
	      }
	      else if (match('+')) {
	        quantifier = createQuantifier(1);
	      }
	      else if (match('?')) {
	        quantifier = createQuantifier(0, 1);
	      }
	      else if (res = matchReg(/^\{([0-9]+)\}/)) {
	        min = parseInt(res[1], 10);
	        quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
	      }
	      else if (res = matchReg(/^\{([0-9]+),\}/)) {
	        min = parseInt(res[1], 10);
	        quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
	      }
	      else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
	        min = parseInt(res[1], 10);
	        max = parseInt(res[2], 10);
	        if (min > max) {
	          bail('numbers out of order in {} quantifier', '', from, pos);
	        }
	        quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
	      }
	
	      if (quantifier) {
	        if (match('?')) {
	          quantifier.greedy = false;
	          quantifier.range[1] += 1;
	        }
	      }
	
	      return quantifier;
	    }
	
	    function parseAtom() {
	      // Atom ::
	      //      PatternCharacter
	      //      .
	      //      \ AtomEscape
	      //      CharacterClass
	      //      ( Disjunction )
	      //      ( ? : Disjunction )
	
	      var res;
	
	      // jviereck: allow ']', '}' here as well to be compatible with browser's
	      //   implementations: ']'.match(/]/);
	      // if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
	      if (res = matchReg(/^[^^$\\.*+?(){[|]/)) {
	        //      PatternCharacter
	        return createCharacter(res);
	      }
	      else if (match('.')) {
	        //      .
	        return createDot();
	      }
	      else if (match('\\')) {
	        //      \ AtomEscape
	        res = parseAtomEscape();
	        if (!res) {
	          bail('atomEscape');
	        }
	        return res;
	      }
	      else if (res = parseCharacterClass()) {
	        return res;
	      }
	      else {
	        //      ( Disjunction )
	        //      ( ? : Disjunction )
	        return parseGroup('(?:', 'ignore', '(', 'normal');
	      }
	    }
	
	    function parseUnicodeSurrogatePairEscape(firstEscape) {
	      if (hasUnicodeFlag) {
	        var first, second;
	        if (firstEscape.kind == 'unicodeEscape' &&
	          (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF &&
	          current('\\') && next('u') ) {
	          var prevPos = pos;
	          pos++;
	          var secondEscape = parseClassEscape();
	          if (secondEscape.kind == 'unicodeEscape' &&
	            (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
	            // Unicode surrogate pair
	            firstEscape.range[1] = secondEscape.range[1];
	            firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            firstEscape.type = 'value';
	            firstEscape.kind = 'unicodeCodePointEscape';
	            addRaw(firstEscape);
	          }
	          else {
	            pos = prevPos;
	          }
	        }
	      }
	      return firstEscape;
	    }
	
	    function parseClassEscape() {
	      return parseAtomEscape(true);
	    }
	
	    function parseAtomEscape(insideCharacterClass) {
	      // AtomEscape ::
	      //      DecimalEscape
	      //      CharacterEscape
	      //      CharacterClassEscape
	
	      var res, from = pos;
	
	      res = parseDecimalEscape();
	      if (res) {
	        return res;
	      }
	
	      // For ClassEscape
	      if (insideCharacterClass) {
	        if (match('b')) {
	          // 15.10.2.19
	          // The production ClassEscape :: b evaluates by returning the
	          // CharSet containing the one character <BS> (Unicode value 0008).
	          return createEscaped('singleEscape', 0x0008, '\\b');
	        } else if (match('B')) {
	          bail('\\B not possible inside of CharacterClass', '', from);
	        }
	      }
	
	      res = parseCharacterEscape();
	
	      return res;
	    }
	
	
	    function parseDecimalEscape() {
	      // DecimalEscape ::
	      //      DecimalIntegerLiteral [lookahead  DecimalDigit]
	      //      CharacterClassEscape :: one of d D s S w W
	
	      var res, match;
	
	      if (res = matchReg(/^(?!0)\d+/)) {
	        match = res[0];
	        var refIdx = parseInt(res[0], 10);
	        if (refIdx <= closedCaptureCounter) {
	          // If the number is smaller than the normal-groups found so
	          // far, then it is a reference...
	          return createReference(res[0]);
	        } else {
	          // ... otherwise it needs to be interpreted as a octal (if the
	          // number is in an octal format). If it is NOT octal format,
	          // then the slash is ignored and the number is matched later
	          // as normal characters.
	
	          // Recall the negative decision to decide if the input must be parsed
	          // a second time with the total normal-groups.
	          backrefDenied.push(refIdx);
	
	          // Reset the position again, as maybe only parts of the previous
	          // matched numbers are actual octal numbers. E.g. in '019' only
	          // the '01' should be matched.
	          incr(-res[0].length);
	          if (res = matchReg(/^[0-7]{1,3}/)) {
	            return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
	          } else {
	            // If we end up here, we have a case like /\91/. Then the
	            // first slash is to be ignored and the 9 & 1 to be treated
	            // like ordinary characters. Create a character for the
	            // first number only here - other number-characters
	            // (if available) will be matched later.
	            res = createCharacter(matchReg(/^[89]/));
	            return updateRawStart(res, res.range[0] - 1);
	          }
	        }
	      }
	      // Only allow octal numbers in the following. All matched numbers start
	      // with a zero (if the do not, the previous if-branch is executed).
	      // If the number is not octal format and starts with zero (e.g. `091`)
	      // then only the zeros `0` is treated here and the `91` are ordinary
	      // characters.
	      // Example:
	      //   /\091/.exec('\091')[0].length === 3
	      else if (res = matchReg(/^[0-7]{1,3}/)) {
	        match = res[0];
	        if (/^0{1,3}$/.test(match)) {
	          // If they are all zeros, then only take the first one.
	          return createEscaped('null', 0x0000, '0', match.length + 1);
	        } else {
	          return createEscaped('octal', parseInt(match, 8), match, 1);
	        }
	      } else if (res = matchReg(/^[dDsSwW]/)) {
	        return createCharacterClassEscape(res[0]);
	      }
	      return false;
	    }
	
	    function parseCharacterEscape() {
	      // CharacterEscape ::
	      //      ControlEscape
	      //      c ControlLetter
	      //      HexEscapeSequence
	      //      UnicodeEscapeSequence
	      //      IdentityEscape
	
	      var res;
	      if (res = matchReg(/^[fnrtv]/)) {
	        // ControlEscape
	        var codePoint = 0;
	        switch (res[0]) {
	          case 't': codePoint = 0x009; break;
	          case 'n': codePoint = 0x00A; break;
	          case 'v': codePoint = 0x00B; break;
	          case 'f': codePoint = 0x00C; break;
	          case 'r': codePoint = 0x00D; break;
	        }
	        return createEscaped('singleEscape', codePoint, '\\' + res[0]);
	      } else if (res = matchReg(/^c([a-zA-Z])/)) {
	        // c ControlLetter
	        return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
	      } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
	        // HexEscapeSequence
	        return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
	      } else if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
	        // UnicodeEscapeSequence
	        return parseUnicodeSurrogatePairEscape(
	          createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2)
	        );
	      } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
	        // RegExpUnicodeEscapeSequence (ES6 Unicode code point escape)
	        return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
	      } else if (features.unicodePropertyEscape && hasUnicodeFlag && (res = matchReg(/^([pP])\{([^\}]+)\}/))) {
	        // https://github.com/jviereck/regjsparser/issues/77
	        return addRaw({
	          type: 'unicodePropertyEscape',
	          negative: res[1] === 'P',
	          value: res[2],
	          range: [res.range[0] - 1, res.range[1]],
	          raw: res[0]
	        });
	      } else {
	        // IdentityEscape
	        return parseIdentityEscape();
	      }
	    }
	
	    // Taken from the Esprima parser.
	    function isIdentifierPart(ch) {
	      // Generated by `tools/generate-identifier-regex.js`.
	      var NonAsciiIdentifierPart = new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]');
	
	      return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
	        (ch >= 65 && ch <= 90) ||         // A..Z
	        (ch >= 97 && ch <= 122) ||        // a..z
	        (ch >= 48 && ch <= 57) ||         // 0..9
	        (ch === 92) ||                    // \ (backslash)
	        ((ch >= 0x80) && NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
	    }
	
	    function parseIdentityEscape() {
	      // IdentityEscape ::
	      //      SourceCharacter but not IdentifierPart
	      //      <ZWJ>
	      //      <ZWNJ>
	
	      var ZWJ = '\u200C';
	      var ZWNJ = '\u200D';
	
	      var tmp;
	
	      if (!isIdentifierPart(lookahead())) {
	        tmp = incr();
	        return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
	      }
	
	      if (match(ZWJ)) {
	        // <ZWJ>
	        return createEscaped('identifier', 0x200C, ZWJ);
	      } else if (match(ZWNJ)) {
	        // <ZWNJ>
	        return createEscaped('identifier', 0x200D, ZWNJ);
	      }
	
	      return null;
	    }
	
	    function parseCharacterClass() {
	      // CharacterClass ::
	      //      [ [lookahead  {^}] ClassRanges ]
	      //      [ ^ ClassRanges ]
	
	      var res, from = pos;
	      if (res = matchReg(/^\[\^/)) {
	        res = parseClassRanges();
	        skip(']');
	        return createCharacterClass(res, true, from, pos);
	      } else if (match('[')) {
	        res = parseClassRanges();
	        skip(']');
	        return createCharacterClass(res, false, from, pos);
	      }
	
	      return null;
	    }
	
	    function parseClassRanges() {
	      // ClassRanges ::
	      //      [empty]
	      //      NonemptyClassRanges
	
	      var res;
	      if (current(']')) {
	        // Empty array means nothing insinde of the ClassRange.
	        return [];
	      } else {
	        res = parseNonemptyClassRanges();
	        if (!res) {
	          bail('nonEmptyClassRanges');
	        }
	        return res;
	      }
	    }
	
	    function parseHelperClassRanges(atom) {
	      var from, to, res;
	      if (current('-') && !next(']')) {
	        // ClassAtom - ClassAtom ClassRanges
	        skip('-');
	
	        res = parseClassAtom();
	        if (!res) {
	          bail('classAtom');
	        }
	        to = pos;
	        var classRanges = parseClassRanges();
	        if (!classRanges) {
	          bail('classRanges');
	        }
	        from = atom.range[0];
	        if (classRanges.type === 'empty') {
	          return [createClassRange(atom, res, from, to)];
	        }
	        return [createClassRange(atom, res, from, to)].concat(classRanges);
	      }
	
	      res = parseNonemptyClassRangesNoDash();
	      if (!res) {
	        bail('nonEmptyClassRangesNoDash');
	      }
	
	      return [atom].concat(res);
	    }
	
	    function parseNonemptyClassRanges() {
	      // NonemptyClassRanges ::
	      //      ClassAtom
	      //      ClassAtom NonemptyClassRangesNoDash
	      //      ClassAtom - ClassAtom ClassRanges
	
	      var atom = parseClassAtom();
	      if (!atom) {
	        bail('classAtom');
	      }
	
	      if (current(']')) {
	        // ClassAtom
	        return [atom];
	      }
	
	      // ClassAtom NonemptyClassRangesNoDash
	      // ClassAtom - ClassAtom ClassRanges
	      return parseHelperClassRanges(atom);
	    }
	
	    function parseNonemptyClassRangesNoDash() {
	      // NonemptyClassRangesNoDash ::
	      //      ClassAtom
	      //      ClassAtomNoDash NonemptyClassRangesNoDash
	      //      ClassAtomNoDash - ClassAtom ClassRanges
	
	      var res = parseClassAtom();
	      if (!res) {
	        bail('classAtom');
	      }
	      if (current(']')) {
	        //      ClassAtom
	        return res;
	      }
	
	      // ClassAtomNoDash NonemptyClassRangesNoDash
	      // ClassAtomNoDash - ClassAtom ClassRanges
	      return parseHelperClassRanges(res);
	    }
	
	    function parseClassAtom() {
	      // ClassAtom ::
	      //      -
	      //      ClassAtomNoDash
	      if (match('-')) {
	        return createCharacter('-');
	      } else {
	        return parseClassAtomNoDash();
	      }
	    }
	
	    function parseClassAtomNoDash() {
	      // ClassAtomNoDash ::
	      //      SourceCharacter but not one of \ or ] or -
	      //      \ ClassEscape
	
	      var res;
	      if (res = matchReg(/^[^\\\]-]/)) {
	        return createCharacter(res[0]);
	      } else if (match('\\')) {
	        res = parseClassEscape();
	        if (!res) {
	          bail('classEscape');
	        }
	
	        return parseUnicodeSurrogatePairEscape(res);
	      }
	    }
	
	    function bail(message, details, from, to) {
	      from = from == null ? pos : from;
	      to = to == null ? from : to;
	
	      var contextStart = Math.max(0, from - 10);
	      var contextEnd = Math.min(to + 10, str.length);
	
	      // Output a bit of context and a line pointing to where our error is.
	      //
	      // We are assuming that there are no actual newlines in the content as this is a regular expression.
	      var context = '    ' + str.substring(contextStart, contextEnd);
	      var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';
	
	      throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
	    }
	
	    var backrefDenied = [];
	    var closedCaptureCounter = 0;
	    var firstIteration = true;
	    var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
	    var pos = 0;
	
	    // Convert the input to a string and treat the empty string special.
	    str = String(str);
	    if (str === '') {
	      str = '(?:)';
	    }
	
	    var result = parseDisjunction();
	
	    if (result.range[1] !== str.length) {
	      bail('Could not parse entire input - got stuck', '', result.range[1]);
	    }
	
	    // The spec requires to interpret the `\2` in `/\2()()/` as backreference.
	    // As the parser collects the number of capture groups as the string is
	    // parsed it is impossible to make these decisions at the point when the
	    // `\2` is handled. In case the local decision turns out to be wrong after
	    // the parsing has finished, the input string is parsed a second time with
	    // the total number of capture groups set.
	    //
	    // SEE: https://github.com/jviereck/regjsparser/issues/70
	    for (var i = 0; i < backrefDenied.length; i++) {
	      if (backrefDenied[i] <= closedCaptureCounter) {
	        // Parse the input a second time.
	        pos = 0;
	        firstIteration = false;
	        return parseDisjunction();
	      }
	    }
	
	    return result;
	  }
	
	  var regjsparser = {
	    parse: parse
	  };
	
	  if ('object' !== 'undefined' && module.exports) {
	    module.exports = regjsparser;
	  } else {
	    window.regjsparser = regjsparser;
	  }
	
	}());
	});
	
	var regenerate = createCommonjsModule(function (module, exports) {
	/*! https://mths.be/regenerate v1.3.3 by @mathias | MIT license */
	(function(root) {
	
		// Detect free variables `exports`.
		var freeExports = 'object' == 'object' && exports;
	
		// Detect free variable `module`.
		var freeModule = 'object' == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js/io.js or Browserified code,
		// and use it as `root`.
		var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var ERRORS = {
			'rangeOrder': 'A range\u2019s `stop` value must be greater than or equal ' +
				'to the `start` value.',
			'codePointRange': 'Invalid code point value. Code points range from ' +
				'U+000000 to U+10FFFF.'
		};
	
		// https://mathiasbynens.be/notes/javascript-encoding#surrogate-pairs
		var HIGH_SURROGATE_MIN = 0xD800;
		var HIGH_SURROGATE_MAX = 0xDBFF;
		var LOW_SURROGATE_MIN = 0xDC00;
		var LOW_SURROGATE_MAX = 0xDFFF;
	
		// In Regenerate output, `\0` is never preceded by `\` because we sort by
		// code point value, so lets keep this regular expression simple.
		var regexNull = /\\x00([^0123456789]|$)/g;
	
		var object = {};
		var hasOwnProperty = object.hasOwnProperty;
		var extend = function(destination, source) {
			var key;
			for (key in source) {
				if (hasOwnProperty.call(source, key)) {
					destination[key] = source[key];
				}
			}
			return destination;
		};
	
		var forEach = function(array, callback) {
			var index = -1;
			var length = array.length;
			while (++index < length) {
				callback(array[index], index);
			}
		};
	
		var toString = object.toString;
		var isArray = function(value) {
			return toString.call(value) == '[object Array]';
		};
		var isNumber = function(value) {
			return typeof value == 'number' ||
				toString.call(value) == '[object Number]';
		};
	
		// This assumes that `number` is a positive integer that `toString()`s nicely
		// (which is the case for all code point values).
		var zeroes = '0000';
		var pad = function(number, totalCharacters) {
			var string = String(number);
			return string.length < totalCharacters
				? (zeroes + string).slice(-totalCharacters)
				: string;
		};
	
		var hex = function(number) {
			return Number(number).toString(16).toUpperCase();
		};
	
		var slice = [].slice;
	
		/*--------------------------------------------------------------------------*/
	
		var dataFromCodePoints = function(codePoints) {
			var index = -1;
			var length = codePoints.length;
			var max = length - 1;
			var result = [];
			var isStart = true;
			var tmp;
			var previous = 0;
			while (++index < length) {
				tmp = codePoints[index];
				if (isStart) {
					result.push(tmp);
					previous = tmp;
					isStart = false;
				} else {
					if (tmp == previous + 1) {
						if (index != max) {
							previous = tmp;
							continue;
						} else {
							isStart = true;
							result.push(tmp + 1);
						}
					} else {
						// End the previous range and start a new one.
						result.push(previous + 1, tmp);
						previous = tmp;
					}
				}
			}
			if (!isStart) {
				result.push(tmp + 1);
			}
			return result;
		};
	
		var dataRemove = function(data, codePoint) {
			// Iterate over the data per `(start, end)` pair.
			var index = 0;
			var start;
			var end;
			var length = data.length;
			while (index < length) {
				start = data[index];
				end = data[index + 1];
				if (codePoint >= start && codePoint < end) {
					// Modify this pair.
					if (codePoint == start) {
						if (end == start + 1) {
							// Just remove `start` and `end`.
							data.splice(index, 2);
							return data;
						} else {
							// Just replace `start` with a new value.
							data[index] = codePoint + 1;
							return data;
						}
					} else if (codePoint == end - 1) {
						// Just replace `end` with a new value.
						data[index + 1] = codePoint;
						return data;
					} else {
						// Replace `[start, end]` with `[startA, endA, startB, endB]`.
						data.splice(index, 2, start, codePoint, codePoint + 1, end);
						return data;
					}
				}
				index += 2;
			}
			return data;
		};
	
		var dataRemoveRange = function(data, rangeStart, rangeEnd) {
			if (rangeEnd < rangeStart) {
				throw Error(ERRORS.rangeOrder);
			}
			// Iterate over the data per `(start, end)` pair.
			var index = 0;
			var start;
			var end;
			while (index < data.length) {
				start = data[index];
				end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
	
				// Exit as soon as no more matching pairs can be found.
				if (start > rangeEnd) {
					return data;
				}
	
				// Check if this range pair is equal to, or forms a subset of, the range
				// to be removed.
				// E.g. we have `[0, 11, 40, 51]` and want to remove 0-10  `[40, 51]`.
				// E.g. we have `[40, 51]` and want to remove 0-100  `[]`.
				if (rangeStart <= start && rangeEnd >= end) {
					// Remove this pair.
					data.splice(index, 2);
					continue;
				}
	
				// Check if both `rangeStart` and `rangeEnd` are within the bounds of
				// this pair.
				// E.g. we have `[0, 11]` and want to remove 4-6  `[0, 4, 7, 11]`.
				if (rangeStart >= start && rangeEnd < end) {
					if (rangeStart == start) {
						// Replace `[start, end]` with `[startB, endB]`.
						data[index] = rangeEnd + 1;
						data[index + 1] = end + 1;
						return data;
					}
					// Replace `[start, end]` with `[startA, endA, startB, endB]`.
					data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
					return data;
				}
	
				// Check if only `rangeStart` is within the bounds of this pair.
				// E.g. we have `[0, 11]` and want to remove 4-20  `[0, 4]`.
				if (rangeStart >= start && rangeStart <= end) {
					// Replace `end` with `rangeStart`.
					data[index + 1] = rangeStart;
					// Note: we cannot `return` just yet, in case any following pairs still
					// contain matching code points.
					// E.g. we have `[0, 11, 14, 31]` and want to remove 4-20
					//  `[0, 4, 21, 31]`.
				}
	
				// Check if only `rangeEnd` is within the bounds of this pair.
				// E.g. we have `[14, 31]` and want to remove 4-20  `[21, 31]`.
				else if (rangeEnd >= start && rangeEnd <= end) {
					// Just replace `start`.
					data[index] = rangeEnd + 1;
					return data;
				}
	
				index += 2;
			}
			return data;
		};
	
		 var dataAdd = function(data, codePoint) {
			// Iterate over the data per `(start, end)` pair.
			var index = 0;
			var start;
			var end;
			var lastIndex = null;
			var length = data.length;
			if (codePoint < 0x0 || codePoint > 0x10FFFF) {
				throw RangeError(ERRORS.codePointRange);
			}
			while (index < length) {
				start = data[index];
				end = data[index + 1];
	
				// Check if the code point is already in the set.
				if (codePoint >= start && codePoint < end) {
					return data;
				}
	
				if (codePoint == start - 1) {
					// Just replace `start` with a new value.
					data[index] = codePoint;
					return data;
				}
	
				// At this point, if `start` is `greater` than `codePoint`, insert a new
				// `[start, end]` pair before the current pair, or after the current pair
				// if there is a known `lastIndex`.
				if (start > codePoint) {
					data.splice(
						lastIndex != null ? lastIndex + 2 : 0,
						0,
						codePoint,
						codePoint + 1
					);
					return data;
				}
	
				if (codePoint == end) {
					// Check if adding this code point causes two separate ranges to become
					// a single range, e.g. `dataAdd([0, 4, 5, 10], 4)`  `[0, 10]`.
					if (codePoint + 1 == data[index + 2]) {
						data.splice(index, 4, start, data[index + 3]);
						return data;
					}
					// Else, just replace `end` with a new value.
					data[index + 1] = codePoint + 1;
					return data;
				}
				lastIndex = index;
				index += 2;
			}
			// The loop has finished; add the new pair to the end of the data set.
			data.push(codePoint, codePoint + 1);
			return data;
		};
	
		var dataAddData = function(dataA, dataB) {
			// Iterate over the data per `(start, end)` pair.
			var index = 0;
			var start;
			var end;
			var data = dataA.slice();
			var length = dataB.length;
			while (index < length) {
				start = dataB[index];
				end = dataB[index + 1] - 1;
				if (start == end) {
					data = dataAdd(data, start);
				} else {
					data = dataAddRange(data, start, end);
				}
				index += 2;
			}
			return data;
		};
	
		var dataRemoveData = function(dataA, dataB) {
			// Iterate over the data per `(start, end)` pair.
			var index = 0;
			var start;
			var end;
			var data = dataA.slice();
			var length = dataB.length;
			while (index < length) {
				start = dataB[index];
				end = dataB[index + 1] - 1;
				if (start == end) {
					data = dataRemove(data, start);
				} else {
					data = dataRemoveRange(data, start, end);
				}
				index += 2;
			}
			return data;
		};
	
		var dataAddRange = function(data, rangeStart, rangeEnd) {
			if (rangeEnd < rangeStart) {
				throw Error(ERRORS.rangeOrder);
			}
			if (
				rangeStart < 0x0 || rangeStart > 0x10FFFF ||
				rangeEnd < 0x0 || rangeEnd > 0x10FFFF
			) {
				throw RangeError(ERRORS.codePointRange);
			}
			// Iterate over the data per `(start, end)` pair.
			var index = 0;
			var start;
			var end;
			var added = false;
			var length = data.length;
			while (index < length) {
				start = data[index];
				end = data[index + 1];
	
				if (added) {
					// The range has already been added to the set; at this point, we just
					// need to get rid of the following ranges in case they overlap.
	
					// Check if this range can be combined with the previous range.
					if (start == rangeEnd + 1) {
						data.splice(index - 1, 2);
						return data;
					}
	
					// Exit as soon as no more possibly overlapping pairs can be found.
					if (start > rangeEnd) {
						return data;
					}
	
					// E.g. `[0, 11, 12, 16]` and weve added 5-15, so we now have
					// `[0, 16, 12, 16]`. Remove the `12,16` part, as it lies within the
					// `0,16` range that was previously added.
					if (start >= rangeStart && start <= rangeEnd) {
						// `start` lies within the range that was previously added.
	
						if (end > rangeStart && end - 1 <= rangeEnd) {
							// `end` lies within the range that was previously added as well,
							// so remove this pair.
							data.splice(index, 2);
							index -= 2;
							// Note: we cannot `return` just yet, as there may still be other
							// overlapping pairs.
						} else {
							// `start` lies within the range that was previously added, but
							// `end` doesnt. E.g. `[0, 11, 12, 31]` and weve added 5-15, so
							// now we have `[0, 16, 12, 31]`. This must be written as `[0, 31]`.
							// Remove the previously added `end` and the current `start`.
							data.splice(index - 1, 2);
							index -= 2;
						}
	
						// Note: we cannot return yet.
					}
	
				}
	
				else if (start == rangeEnd + 1) {
					data[index] = rangeStart;
					return data;
				}
	
				// Check if a new pair must be inserted *before* the current one.
				else if (start > rangeEnd) {
					data.splice(index, 0, rangeStart, rangeEnd + 1);
					return data;
				}
	
				else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
					// The new range lies entirely within an existing range pair. No action
					// needed.
					return data;
				}
	
				else if (
					// E.g. `[0, 11]` and you add 5-15  `[0, 16]`.
					(rangeStart >= start && rangeStart < end) ||
					// E.g. `[0, 3]` and you add 3-6  `[0, 7]`.
					end == rangeStart
				) {
					// Replace `end` with the new value.
					data[index + 1] = rangeEnd + 1;
					// Make sure the next range pair doesnt overlap, e.g. `[0, 11, 12, 14]`
					// and you add 5-15  `[0, 16]`, i.e. remove the `12,14` part.
					added = true;
					// Note: we cannot `return` just yet.
				}
	
				else if (rangeStart <= start && rangeEnd + 1 >= end) {
					// The new range is a superset of the old range.
					data[index] = rangeStart;
					data[index + 1] = rangeEnd + 1;
					added = true;
				}
	
				index += 2;
			}
			// The loop has finished without doing anything; add the new pair to the end
			// of the data set.
			if (!added) {
				data.push(rangeStart, rangeEnd + 1);
			}
			return data;
		};
	
		var dataContains = function(data, codePoint) {
			var index = 0;
			var length = data.length;
			// Exit early if `codePoint` is not within `data`s overall range.
			var start = data[index];
			var end = data[length - 1];
			if (length >= 2) {
				if (codePoint < start || codePoint > end) {
					return false;
				}
			}
			// Iterate over the data per `(start, end)` pair.
			while (index < length) {
				start = data[index];
				end = data[index + 1];
				if (codePoint >= start && codePoint < end) {
					return true;
				}
				index += 2;
			}
			return false;
		};
	
		var dataIntersection = function(data, codePoints) {
			var index = 0;
			var length = codePoints.length;
			var codePoint;
			var result = [];
			while (index < length) {
				codePoint = codePoints[index];
				if (dataContains(data, codePoint)) {
					result.push(codePoint);
				}
				++index;
			}
			return dataFromCodePoints(result);
		};
	
		var dataIsEmpty = function(data) {
			return !data.length;
		};
	
		var dataIsSingleton = function(data) {
			// Check if the set only represents a single code point.
			return data.length == 2 && data[0] + 1 == data[1];
		};
	
		var dataToArray = function(data) {
			// Iterate over the data per `(start, end)` pair.
			var index = 0;
			var start;
			var end;
			var result = [];
			var length = data.length;
			while (index < length) {
				start = data[index];
				end = data[index + 1];
				while (start < end) {
					result.push(start);
					++start;
				}
				index += 2;
			}
			return result;
		};
	
		/*--------------------------------------------------------------------------*/
	
		// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
		var floor = Math.floor;
		var highSurrogate = function(codePoint) {
			return parseInt(
				floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN,
				10
			);
		};
	
		var lowSurrogate = function(codePoint) {
			return parseInt(
				(codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN,
				10
			);
		};
	
		var stringFromCharCode = String.fromCharCode;
		var codePointToString = function(codePoint) {
			var string;
			// https://mathiasbynens.be/notes/javascript-escapes#single
			// Note: the `\b` escape sequence for U+0008 BACKSPACE in strings has a
			// different meaning in regular expressions (word boundary), so it cannot
			// be used here.
			if (codePoint == 0x09) {
				string = '\\t';
			}
			// Note: IE < 9 treats `'\v'` as `'v'`, so avoid using it.
			// else if (codePoint == 0x0B) {
			// 	string = '\\v';
			// }
			else if (codePoint == 0x0A) {
				string = '\\n';
			}
			else if (codePoint == 0x0C) {
				string = '\\f';
			}
			else if (codePoint == 0x0D) {
				string = '\\r';
			}
			else if (codePoint == 0x5C) {
				string = '\\\\';
			}
			else if (
				codePoint == 0x24 ||
				(codePoint >= 0x28 && codePoint <= 0x2B) ||
				(codePoint >= 0x2D && codePoint <= 0x2F) ||
				codePoint == 0x3F ||
				(codePoint >= 0x5B && codePoint <= 0x5E) ||
				(codePoint >= 0x7B && codePoint <= 0x7D)
			) {
				// The code point maps to an unsafe printable ASCII character;
				// backslash-escape it. Heres the list of those symbols:
				//
				//     $()*+-./?[\]^{|}
				//
				// See #7 for more info.
				string = '\\' + stringFromCharCode(codePoint);
			}
			else if (codePoint >= 0x20 && codePoint <= 0x7E) {
				// The code point maps to one of these printable ASCII symbols
				// (including the space character):
				//
				//      !"#%&',/0123456789:;<=>@ABCDEFGHIJKLMNO
				//     PQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~
				//
				// These can safely be used directly.
				string = stringFromCharCode(codePoint);
			}
			else if (codePoint <= 0xFF) {
				// https://mathiasbynens.be/notes/javascript-escapes#hexadecimal
				string = '\\x' + pad(hex(codePoint), 2);
			}
			else { // `codePoint <= 0xFFFF` holds true.
				// https://mathiasbynens.be/notes/javascript-escapes#unicode
				string = '\\u' + pad(hex(codePoint), 4);
			}
	
			// Theres no need to account for astral symbols / surrogate pairs here,
			// since `codePointToString` is private and only used for BMP code points.
			// But if thats what you need, just add an `else` block with this code:
			//
			//     string = '\\u' + pad(hex(highSurrogate(codePoint)), 4)
			//     	+ '\\u' + pad(hex(lowSurrogate(codePoint)), 4);
	
			return string;
		};
	
		var codePointToStringUnicode = function(codePoint) {
			if (codePoint <= 0xFFFF) {
				return codePointToString(codePoint);
			}
			return '\\u{' + codePoint.toString(16).toUpperCase() + '}';
		};
	
		var symbolToCodePoint = function(symbol) {
			var length = symbol.length;
			var first = symbol.charCodeAt(0);
			var second;
			if (
				first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX &&
				length > 1 // There is a next code unit.
			) {
				// `first` is a high surrogate, and there is a next character. Assume
				// its a low surrogate (else its invalid usage of Regenerate anyway).
				second = symbol.charCodeAt(1);
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				return (first - HIGH_SURROGATE_MIN) * 0x400 +
					second - LOW_SURROGATE_MIN + 0x10000;
			}
			return first;
		};
	
		var createBMPCharacterClasses = function(data) {
			// Iterate over the data per `(start, end)` pair.
			var result = '';
			var index = 0;
			var start;
			var end;
			var length = data.length;
			if (dataIsSingleton(data)) {
				return codePointToString(data[0]);
			}
			while (index < length) {
				start = data[index];
				end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
				if (start == end) {
					result += codePointToString(start);
				} else if (start + 1 == end) {
					result += codePointToString(start) + codePointToString(end);
				} else {
					result += codePointToString(start) + '-' + codePointToString(end);
				}
				index += 2;
			}
			return '[' + result + ']';
		};
	
		var createUnicodeCharacterClasses = function(data) {
			// Iterate over the data per `(start, end)` pair.
			var result = '';
			var index = 0;
			var start;
			var end;
			var length = data.length;
			if (dataIsSingleton(data)) {
				return codePointToStringUnicode(data[0]);
			}
			while (index < length) {
				start = data[index];
				end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
				if (start == end) {
					result += codePointToStringUnicode(start);
				} else if (start + 1 == end) {
					result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
				} else {
					result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);
				}
				index += 2;
			}
			return '[' + result + ']';
		};
	
		var splitAtBMP = function(data) {
			// Iterate over the data per `(start, end)` pair.
			var loneHighSurrogates = [];
			var loneLowSurrogates = [];
			var bmp = [];
			var astral = [];
			var index = 0;
			var start;
			var end;
			var length = data.length;
			while (index < length) {
				start = data[index];
				end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
	
				if (start < HIGH_SURROGATE_MIN) {
	
					// The range starts and ends before the high surrogate range.
					// E.g. (0, 0x10).
					if (end < HIGH_SURROGATE_MIN) {
						bmp.push(start, end + 1);
					}
	
					// The range starts before the high surrogate range and ends within it.
					// E.g. (0, 0xD855).
					if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
						bmp.push(start, HIGH_SURROGATE_MIN);
						loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
					}
	
					// The range starts before the high surrogate range and ends in the low
					// surrogate range. E.g. (0, 0xDCFF).
					if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
						bmp.push(start, HIGH_SURROGATE_MIN);
						loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
						loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
					}
	
					// The range starts before the high surrogate range and ends after the
					// low surrogate range. E.g. (0, 0x10FFFF).
					if (end > LOW_SURROGATE_MAX) {
						bmp.push(start, HIGH_SURROGATE_MIN);
						loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
						loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
						if (end <= 0xFFFF) {
							bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
						} else {
							bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
							astral.push(0xFFFF + 1, end + 1);
						}
					}
	
				} else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
	
					// The range starts and ends in the high surrogate range.
					// E.g. (0xD855, 0xD866).
					if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
						loneHighSurrogates.push(start, end + 1);
					}
	
					// The range starts in the high surrogate range and ends in the low
					// surrogate range. E.g. (0xD855, 0xDCFF).
					if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
						loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
						loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
					}
	
					// The range starts in the high surrogate range and ends after the low
					// surrogate range. E.g. (0xD855, 0x10FFFF).
					if (end > LOW_SURROGATE_MAX) {
						loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
						loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
						if (end <= 0xFFFF) {
							bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
						} else {
							bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
							astral.push(0xFFFF + 1, end + 1);
						}
					}
	
				} else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
	
					// The range starts and ends in the low surrogate range.
					// E.g. (0xDCFF, 0xDDFF).
					if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
						loneLowSurrogates.push(start, end + 1);
					}
	
					// The range starts in the low surrogate range and ends after the low
					// surrogate range. E.g. (0xDCFF, 0x10FFFF).
					if (end > LOW_SURROGATE_MAX) {
						loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);
						if (end <= 0xFFFF) {
							bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
						} else {
							bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
							astral.push(0xFFFF + 1, end + 1);
						}
					}
	
				} else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {
	
					// The range starts and ends after the low surrogate range.
					// E.g. (0xFFAA, 0x10FFFF).
					if (end <= 0xFFFF) {
						bmp.push(start, end + 1);
					} else {
						bmp.push(start, 0xFFFF + 1);
						astral.push(0xFFFF + 1, end + 1);
					}
	
				} else {
	
					// The range starts and ends in the astral range.
					astral.push(start, end + 1);
	
				}
	
				index += 2;
			}
			return {
				'loneHighSurrogates': loneHighSurrogates,
				'loneLowSurrogates': loneLowSurrogates,
				'bmp': bmp,
				'astral': astral
			};
		};
	
		var optimizeSurrogateMappings = function(surrogateMappings) {
			var result = [];
			var tmpLow = [];
			var addLow = false;
			var mapping;
			var nextMapping;
			var highSurrogates;
			var lowSurrogates;
			var nextHighSurrogates;
			var nextLowSurrogates;
			var index = -1;
			var length = surrogateMappings.length;
			while (++index < length) {
				mapping = surrogateMappings[index];
				nextMapping = surrogateMappings[index + 1];
				if (!nextMapping) {
					result.push(mapping);
					continue;
				}
				highSurrogates = mapping[0];
				lowSurrogates = mapping[1];
				nextHighSurrogates = nextMapping[0];
				nextLowSurrogates = nextMapping[1];
	
				// Check for identical high surrogate ranges.
				tmpLow = lowSurrogates;
				while (
					nextHighSurrogates &&
					highSurrogates[0] == nextHighSurrogates[0] &&
					highSurrogates[1] == nextHighSurrogates[1]
				) {
					// Merge with the next item.
					if (dataIsSingleton(nextLowSurrogates)) {
						tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
					} else {
						tmpLow = dataAddRange(
							tmpLow,
							nextLowSurrogates[0],
							nextLowSurrogates[1] - 1
						);
					}
					++index;
					mapping = surrogateMappings[index];
					highSurrogates = mapping[0];
					lowSurrogates = mapping[1];
					nextMapping = surrogateMappings[index + 1];
					nextHighSurrogates = nextMapping && nextMapping[0];
					nextLowSurrogates = nextMapping && nextMapping[1];
					addLow = true;
				}
				result.push([
					highSurrogates,
					addLow ? tmpLow : lowSurrogates
				]);
				addLow = false;
			}
			return optimizeByLowSurrogates(result);
		};
	
		var optimizeByLowSurrogates = function(surrogateMappings) {
			if (surrogateMappings.length == 1) {
				return surrogateMappings;
			}
			var index = -1;
			var innerIndex = -1;
			while (++index < surrogateMappings.length) {
				var mapping = surrogateMappings[index];
				var lowSurrogates = mapping[1];
				var lowSurrogateStart = lowSurrogates[0];
				var lowSurrogateEnd = lowSurrogates[1];
				innerIndex = index; // Note: the loop starts at the next index.
				while (++innerIndex < surrogateMappings.length) {
					var otherMapping = surrogateMappings[innerIndex];
					var otherLowSurrogates = otherMapping[1];
					var otherLowSurrogateStart = otherLowSurrogates[0];
					var otherLowSurrogateEnd = otherLowSurrogates[1];
					if (
						lowSurrogateStart == otherLowSurrogateStart &&
						lowSurrogateEnd == otherLowSurrogateEnd
					) {
						// Add the code points in the other item to this one.
						if (dataIsSingleton(otherMapping[0])) {
							mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
						} else {
							mapping[0] = dataAddRange(
								mapping[0],
								otherMapping[0][0],
								otherMapping[0][1] - 1
							);
						}
						// Remove the other, now redundant, item.
						surrogateMappings.splice(innerIndex, 1);
						--innerIndex;
					}
				}
			}
			return surrogateMappings;
		};
	
		var surrogateSet = function(data) {
			// Exit early if `data` is an empty set.
			if (!data.length) {
				return [];
			}
	
			// Iterate over the data per `(start, end)` pair.
			var index = 0;
			var start;
			var end;
			var startHigh;
			var startLow;
			var endHigh;
			var endLow;
			var surrogateMappings = [];
			var length = data.length;
			while (index < length) {
				start = data[index];
				end = data[index + 1] - 1;
	
				startHigh = highSurrogate(start);
				startLow = lowSurrogate(start);
				endHigh = highSurrogate(end);
				endLow = lowSurrogate(end);
	
				var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
				var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
				var complete = false;
	
				// Append the previous high-surrogate-to-low-surrogate mappings.
				// Step 1: `(startHigh, startLow)` to `(startHigh, LOW_SURROGATE_MAX)`.
				if (
					startHigh == endHigh ||
					startsWithLowestLowSurrogate && endsWithHighestLowSurrogate
				) {
					surrogateMappings.push([
						[startHigh, endHigh + 1],
						[startLow, endLow + 1]
					]);
					complete = true;
				} else {
					surrogateMappings.push([
						[startHigh, startHigh + 1],
						[startLow, LOW_SURROGATE_MAX + 1]
					]);
				}
	
				// Step 2: `(startHigh + 1, LOW_SURROGATE_MIN)` to
				// `(endHigh - 1, LOW_SURROGATE_MAX)`.
				if (!complete && startHigh + 1 < endHigh) {
					if (endsWithHighestLowSurrogate) {
						// Combine step 2 and step 3.
						surrogateMappings.push([
							[startHigh + 1, endHigh + 1],
							[LOW_SURROGATE_MIN, endLow + 1]
						]);
						complete = true;
					} else {
						surrogateMappings.push([
							[startHigh + 1, endHigh],
							[LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]
						]);
					}
				}
	
				// Step 3. `(endHigh, LOW_SURROGATE_MIN)` to `(endHigh, endLow)`.
				if (!complete) {
					surrogateMappings.push([
						[endHigh, endHigh + 1],
						[LOW_SURROGATE_MIN, endLow + 1]
					]);
				}
	
				index += 2;
			}
	
			// The format of `surrogateMappings` is as follows:
			//
			//     [ surrogateMapping1, surrogateMapping2 ]
			//
			// i.e.:
			//
			//     [
			//       [ highSurrogates1, lowSurrogates1 ],
			//       [ highSurrogates2, lowSurrogates2 ]
			//     ]
			return optimizeSurrogateMappings(surrogateMappings);
		};
	
		var createSurrogateCharacterClasses = function(surrogateMappings) {
			var result = [];
			forEach(surrogateMappings, function(surrogateMapping) {
				var highSurrogates = surrogateMapping[0];
				var lowSurrogates = surrogateMapping[1];
				result.push(
					createBMPCharacterClasses(highSurrogates) +
					createBMPCharacterClasses(lowSurrogates)
				);
			});
			return result.join('|');
		};
	
		var createCharacterClassesFromData = function(data, bmpOnly, hasUnicodeFlag) {
			if (hasUnicodeFlag) {
				return createUnicodeCharacterClasses(data);
			}
			var result = [];
	
			var parts = splitAtBMP(data);
			var loneHighSurrogates = parts.loneHighSurrogates;
			var loneLowSurrogates = parts.loneLowSurrogates;
			var bmp = parts.bmp;
			var astral = parts.astral;
			var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
			var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
	
			var surrogateMappings = surrogateSet(astral);
	
			if (bmpOnly) {
				bmp = dataAddData(bmp, loneHighSurrogates);
				hasLoneHighSurrogates = false;
				bmp = dataAddData(bmp, loneLowSurrogates);
				hasLoneLowSurrogates = false;
			}
	
			if (!dataIsEmpty(bmp)) {
				// The data set contains BMP code points that are not high surrogates
				// needed for astral code points in the set.
				result.push(createBMPCharacterClasses(bmp));
			}
			if (surrogateMappings.length) {
				// The data set contains astral code points; append character classes
				// based on their surrogate pairs.
				result.push(createSurrogateCharacterClasses(surrogateMappings));
			}
			// https://gist.github.com/mathiasbynens/bbe7f870208abcfec860
			if (hasLoneHighSurrogates) {
				result.push(
					createBMPCharacterClasses(loneHighSurrogates) +
					// Make sure the high surrogates arent part of a surrogate pair.
					'(?![\\uDC00-\\uDFFF])'
				);
			}
			if (hasLoneLowSurrogates) {
				result.push(
					// It is not possible to accurately assert the low surrogates arent
					// part of a surrogate pair, since JavaScript regular expressions do
					// not support lookbehind.
					'(?:[^\\uD800-\\uDBFF]|^)' +
					createBMPCharacterClasses(loneLowSurrogates)
				);
			}
			return result.join('|');
		};
	
		/*--------------------------------------------------------------------------*/
	
		// `regenerate` can be used as a constructor (and new methods can be added to
		// its prototype) but also as a regular function, the latter of which is the
		// documented and most common usage. For that reason, its not capitalized.
		var regenerate = function(value) {
			if (arguments.length > 1) {
				value = slice.call(arguments);
			}
			if (this instanceof regenerate) {
				this.data = [];
				return value ? this.add(value) : this;
			}
			return (new regenerate).add(value);
		};
	
		regenerate.version = '1.3.3';
	
		var proto = regenerate.prototype;
		extend(proto, {
			'add': function(value) {
				var $this = this;
				if (value == null) {
					return $this;
				}
				if (value instanceof regenerate) {
					// Allow passing other Regenerate instances.
					$this.data = dataAddData($this.data, value.data);
					return $this;
				}
				if (arguments.length > 1) {
					value = slice.call(arguments);
				}
				if (isArray(value)) {
					forEach(value, function(item) {
						$this.add(item);
					});
					return $this;
				}
				$this.data = dataAdd(
					$this.data,
					isNumber(value) ? value : symbolToCodePoint(value)
				);
				return $this;
			},
			'remove': function(value) {
				var $this = this;
				if (value == null) {
					return $this;
				}
				if (value instanceof regenerate) {
					// Allow passing other Regenerate instances.
					$this.data = dataRemoveData($this.data, value.data);
					return $this;
				}
				if (arguments.length > 1) {
					value = slice.call(arguments);
				}
				if (isArray(value)) {
					forEach(value, function(item) {
						$this.remove(item);
					});
					return $this;
				}
				$this.data = dataRemove(
					$this.data,
					isNumber(value) ? value : symbolToCodePoint(value)
				);
				return $this;
			},
			'addRange': function(start, end) {
				var $this = this;
				$this.data = dataAddRange($this.data,
					isNumber(start) ? start : symbolToCodePoint(start),
					isNumber(end) ? end : symbolToCodePoint(end)
				);
				return $this;
			},
			'removeRange': function(start, end) {
				var $this = this;
				var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
				var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
				$this.data = dataRemoveRange(
					$this.data,
					startCodePoint,
					endCodePoint
				);
				return $this;
			},
			'intersection': function(argument) {
				var $this = this;
				// Allow passing other Regenerate instances.
				// TODO: Optimize this by writing and using `dataIntersectionData()`.
				var array = argument instanceof regenerate ?
					dataToArray(argument.data) :
					argument;
				$this.data = dataIntersection($this.data, array);
				return $this;
			},
			'contains': function(codePoint) {
				return dataContains(
					this.data,
					isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint)
				);
			},
			'clone': function() {
				var set = new regenerate;
				set.data = this.data.slice(0);
				return set;
			},
			'toString': function(options) {
				var result = createCharacterClassesFromData(
					this.data,
					options ? options.bmpOnly : false,
					options ? options.hasUnicodeFlag : false
				);
				if (!result) {
					// For an empty set, return something that can be inserted `/here/` to
					// form a valid regular expression. Avoid `(?:)` since that matches the
					// empty string.
					return '[]';
				}
				// Use `\0` instead of `\x00` where possible.
				return result.replace(regexNull, '\\0$1');
			},
			'toRegExp': function(flags) {
				var pattern = this.toString(
					flags && flags.indexOf('u') != -1 ?
						{ 'hasUnicodeFlag': true } :
						null
				);
				return RegExp(pattern, flags || '');
			},
			'valueOf': function() { // Note: `valueOf` is aliased as `toArray`.
				return dataToArray(this.data);
			}
		});
	
		proto.toArray = proto.valueOf;
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			false
		) {
			undefined(function() {
				return regenerate;
			});
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
				freeModule.exports = regenerate;
			} else { // in Narwhal or RingoJS v0.7.0-
				freeExports.regenerate = regenerate;
			}
		} else { // in Rhino or a web browser
			root.regenerate = regenerate;
		}
	
	}(commonjsGlobal));
	});
	
	var unicodeCanonicalPropertyNamesEcmascript = new Set([
		// Non-binary properties:
		'General_Category',
		'Script',
		'Script_Extensions',
		// Binary properties:
		'Alphabetic',
		'Any',
		'ASCII',
		'ASCII_Hex_Digit',
		'Assigned',
		'Bidi_Control',
		'Bidi_Mirrored',
		'Case_Ignorable',
		'Cased',
		'Changes_When_Casefolded',
		'Changes_When_Casemapped',
		'Changes_When_Lowercased',
		'Changes_When_NFKC_Casefolded',
		'Changes_When_Titlecased',
		'Changes_When_Uppercased',
		'Dash',
		'Default_Ignorable_Code_Point',
		'Deprecated',
		'Diacritic',
		'Emoji',
		'Emoji_Component',
		'Emoji_Modifier',
		'Emoji_Modifier_Base',
		'Emoji_Presentation',
		'Extender',
		'Grapheme_Base',
		'Grapheme_Extend',
		'Hex_Digit',
		'ID_Continue',
		'ID_Start',
		'Ideographic',
		'IDS_Binary_Operator',
		'IDS_Trinary_Operator',
		'Join_Control',
		'Logical_Order_Exception',
		'Lowercase',
		'Math',
		'Noncharacter_Code_Point',
		'Pattern_Syntax',
		'Pattern_White_Space',
		'Quotation_Mark',
		'Radical',
		'Regional_Indicator',
		'Sentence_Terminal',
		'Soft_Dotted',
		'Terminal_Punctuation',
		'Unified_Ideograph',
		'Uppercase',
		'Variation_Selector',
		'White_Space',
		'XID_Continue',
		'XID_Start'
	]);
	
	// Generated using `npm run build`. Do not edit!
	var unicodePropertyAliasesEcmascript = new Map([
		['scx', 'Script_Extensions'],
		['sc', 'Script'],
		['gc', 'General_Category'],
		['AHex', 'ASCII_Hex_Digit'],
		['Alpha', 'Alphabetic'],
		['Bidi_C', 'Bidi_Control'],
		['Bidi_M', 'Bidi_Mirrored'],
		['Cased', 'Cased'],
		['CI', 'Case_Ignorable'],
		['CWCF', 'Changes_When_Casefolded'],
		['CWCM', 'Changes_When_Casemapped'],
		['CWKCF', 'Changes_When_NFKC_Casefolded'],
		['CWL', 'Changes_When_Lowercased'],
		['CWT', 'Changes_When_Titlecased'],
		['CWU', 'Changes_When_Uppercased'],
		['Dash', 'Dash'],
		['Dep', 'Deprecated'],
		['DI', 'Default_Ignorable_Code_Point'],
		['Dia', 'Diacritic'],
		['Ext', 'Extender'],
		['Gr_Base', 'Grapheme_Base'],
		['Gr_Ext', 'Grapheme_Extend'],
		['Hex', 'Hex_Digit'],
		['IDC', 'ID_Continue'],
		['Ideo', 'Ideographic'],
		['IDS', 'ID_Start'],
		['IDSB', 'IDS_Binary_Operator'],
		['IDST', 'IDS_Trinary_Operator'],
		['Join_C', 'Join_Control'],
		['LOE', 'Logical_Order_Exception'],
		['Lower', 'Lowercase'],
		['Math', 'Math'],
		['NChar', 'Noncharacter_Code_Point'],
		['Pat_Syn', 'Pattern_Syntax'],
		['Pat_WS', 'Pattern_White_Space'],
		['QMark', 'Quotation_Mark'],
		['Radical', 'Radical'],
		['RI', 'Regional_Indicator'],
		['SD', 'Soft_Dotted'],
		['STerm', 'Sentence_Terminal'],
		['Term', 'Terminal_Punctuation'],
		['UIdeo', 'Unified_Ideograph'],
		['Upper', 'Uppercase'],
		['VS', 'Variation_Selector'],
		['WSpace', 'White_Space'],
		['space', 'White_Space'],
		['XIDC', 'XID_Continue'],
		['XIDS', 'XID_Start']
	]);
	
	var matchProperty = function(property) {
		if (unicodeCanonicalPropertyNamesEcmascript.has(property)) {
			return property;
		}
		if (unicodePropertyAliasesEcmascript.has(property)) {
			return unicodePropertyAliasesEcmascript.get(property);
		}
		throw new Error(("Unknown property: " + property));
	};
	
	var unicodeMatchPropertyEcmascript = matchProperty;
	
	var mappings = new Map([
		['General_Category', new Map([
			['C', 'Other'],
			['Cc', 'Control'],
			['cntrl', 'Control'],
			['Cf', 'Format'],
			['Cn', 'Unassigned'],
			['Co', 'Private_Use'],
			['Cs', 'Surrogate'],
			['L', 'Letter'],
			['LC', 'Cased_Letter'],
			['Ll', 'Lowercase_Letter'],
			['Lm', 'Modifier_Letter'],
			['Lo', 'Other_Letter'],
			['Lt', 'Titlecase_Letter'],
			['Lu', 'Uppercase_Letter'],
			['M', 'Mark'],
			['Combining_Mark', 'Mark'],
			['Mc', 'Spacing_Mark'],
			['Me', 'Enclosing_Mark'],
			['Mn', 'Nonspacing_Mark'],
			['N', 'Number'],
			['Nd', 'Decimal_Number'],
			['digit', 'Decimal_Number'],
			['Nl', 'Letter_Number'],
			['No', 'Other_Number'],
			['P', 'Punctuation'],
			['punct', 'Punctuation'],
			['Pc', 'Connector_Punctuation'],
			['Pd', 'Dash_Punctuation'],
			['Pe', 'Close_Punctuation'],
			['Pf', 'Final_Punctuation'],
			['Pi', 'Initial_Punctuation'],
			['Po', 'Other_Punctuation'],
			['Ps', 'Open_Punctuation'],
			['S', 'Symbol'],
			['Sc', 'Currency_Symbol'],
			['Sk', 'Modifier_Symbol'],
			['Sm', 'Math_Symbol'],
			['So', 'Other_Symbol'],
			['Z', 'Separator'],
			['Zl', 'Line_Separator'],
			['Zp', 'Paragraph_Separator'],
			['Zs', 'Space_Separator'],
			['Other', 'Other'],
			['Control', 'Control'],
			['Format', 'Format'],
			['Unassigned', 'Unassigned'],
			['Private_Use', 'Private_Use'],
			['Surrogate', 'Surrogate'],
			['Letter', 'Letter'],
			['Cased_Letter', 'Cased_Letter'],
			['Lowercase_Letter', 'Lowercase_Letter'],
			['Modifier_Letter', 'Modifier_Letter'],
			['Other_Letter', 'Other_Letter'],
			['Titlecase_Letter', 'Titlecase_Letter'],
			['Uppercase_Letter', 'Uppercase_Letter'],
			['Mark', 'Mark'],
			['Spacing_Mark', 'Spacing_Mark'],
			['Enclosing_Mark', 'Enclosing_Mark'],
			['Nonspacing_Mark', 'Nonspacing_Mark'],
			['Number', 'Number'],
			['Decimal_Number', 'Decimal_Number'],
			['Letter_Number', 'Letter_Number'],
			['Other_Number', 'Other_Number'],
			['Punctuation', 'Punctuation'],
			['Connector_Punctuation', 'Connector_Punctuation'],
			['Dash_Punctuation', 'Dash_Punctuation'],
			['Close_Punctuation', 'Close_Punctuation'],
			['Final_Punctuation', 'Final_Punctuation'],
			['Initial_Punctuation', 'Initial_Punctuation'],
			['Other_Punctuation', 'Other_Punctuation'],
			['Open_Punctuation', 'Open_Punctuation'],
			['Symbol', 'Symbol'],
			['Currency_Symbol', 'Currency_Symbol'],
			['Modifier_Symbol', 'Modifier_Symbol'],
			['Math_Symbol', 'Math_Symbol'],
			['Other_Symbol', 'Other_Symbol'],
			['Separator', 'Separator'],
			['Line_Separator', 'Line_Separator'],
			['Paragraph_Separator', 'Paragraph_Separator'],
			['Space_Separator', 'Space_Separator']
		])],
		['Script', new Map([
			['Adlm', 'Adlam'],
			['Aghb', 'Caucasian_Albanian'],
			['Ahom', 'Ahom'],
			['Arab', 'Arabic'],
			['Armi', 'Imperial_Aramaic'],
			['Armn', 'Armenian'],
			['Avst', 'Avestan'],
			['Bali', 'Balinese'],
			['Bamu', 'Bamum'],
			['Bass', 'Bassa_Vah'],
			['Batk', 'Batak'],
			['Beng', 'Bengali'],
			['Bhks', 'Bhaiksuki'],
			['Bopo', 'Bopomofo'],
			['Brah', 'Brahmi'],
			['Brai', 'Braille'],
			['Bugi', 'Buginese'],
			['Buhd', 'Buhid'],
			['Cakm', 'Chakma'],
			['Cans', 'Canadian_Aboriginal'],
			['Cari', 'Carian'],
			['Cham', 'Cham'],
			['Cher', 'Cherokee'],
			['Copt', 'Coptic'],
			['Qaac', 'Coptic'],
			['Cprt', 'Cypriot'],
			['Cyrl', 'Cyrillic'],
			['Deva', 'Devanagari'],
			['Dsrt', 'Deseret'],
			['Dupl', 'Duployan'],
			['Egyp', 'Egyptian_Hieroglyphs'],
			['Elba', 'Elbasan'],
			['Ethi', 'Ethiopic'],
			['Geor', 'Georgian'],
			['Glag', 'Glagolitic'],
			['Gonm', 'Masaram_Gondi'],
			['Goth', 'Gothic'],
			['Gran', 'Grantha'],
			['Grek', 'Greek'],
			['Gujr', 'Gujarati'],
			['Guru', 'Gurmukhi'],
			['Hang', 'Hangul'],
			['Hani', 'Han'],
			['Hano', 'Hanunoo'],
			['Hatr', 'Hatran'],
			['Hebr', 'Hebrew'],
			['Hira', 'Hiragana'],
			['Hluw', 'Anatolian_Hieroglyphs'],
			['Hmng', 'Pahawh_Hmong'],
			['Hrkt', 'Katakana_Or_Hiragana'],
			['Hung', 'Old_Hungarian'],
			['Ital', 'Old_Italic'],
			['Java', 'Javanese'],
			['Kali', 'Kayah_Li'],
			['Kana', 'Katakana'],
			['Khar', 'Kharoshthi'],
			['Khmr', 'Khmer'],
			['Khoj', 'Khojki'],
			['Knda', 'Kannada'],
			['Kthi', 'Kaithi'],
			['Lana', 'Tai_Tham'],
			['Laoo', 'Lao'],
			['Latn', 'Latin'],
			['Lepc', 'Lepcha'],
			['Limb', 'Limbu'],
			['Lina', 'Linear_A'],
			['Linb', 'Linear_B'],
			['Lisu', 'Lisu'],
			['Lyci', 'Lycian'],
			['Lydi', 'Lydian'],
			['Mahj', 'Mahajani'],
			['Mand', 'Mandaic'],
			['Mani', 'Manichaean'],
			['Marc', 'Marchen'],
			['Mend', 'Mende_Kikakui'],
			['Merc', 'Meroitic_Cursive'],
			['Mero', 'Meroitic_Hieroglyphs'],
			['Mlym', 'Malayalam'],
			['Modi', 'Modi'],
			['Mong', 'Mongolian'],
			['Mroo', 'Mro'],
			['Mtei', 'Meetei_Mayek'],
			['Mult', 'Multani'],
			['Mymr', 'Myanmar'],
			['Narb', 'Old_North_Arabian'],
			['Nbat', 'Nabataean'],
			['Newa', 'Newa'],
			['Nkoo', 'Nko'],
			['Nshu', 'Nushu'],
			['Ogam', 'Ogham'],
			['Olck', 'Ol_Chiki'],
			['Orkh', 'Old_Turkic'],
			['Orya', 'Oriya'],
			['Osge', 'Osage'],
			['Osma', 'Osmanya'],
			['Palm', 'Palmyrene'],
			['Pauc', 'Pau_Cin_Hau'],
			['Perm', 'Old_Permic'],
			['Phag', 'Phags_Pa'],
			['Phli', 'Inscriptional_Pahlavi'],
			['Phlp', 'Psalter_Pahlavi'],
			['Phnx', 'Phoenician'],
			['Plrd', 'Miao'],
			['Prti', 'Inscriptional_Parthian'],
			['Rjng', 'Rejang'],
			['Runr', 'Runic'],
			['Samr', 'Samaritan'],
			['Sarb', 'Old_South_Arabian'],
			['Saur', 'Saurashtra'],
			['Sgnw', 'SignWriting'],
			['Shaw', 'Shavian'],
			['Shrd', 'Sharada'],
			['Sidd', 'Siddham'],
			['Sind', 'Khudawadi'],
			['Sinh', 'Sinhala'],
			['Sora', 'Sora_Sompeng'],
			['Soyo', 'Soyombo'],
			['Sund', 'Sundanese'],
			['Sylo', 'Syloti_Nagri'],
			['Syrc', 'Syriac'],
			['Tagb', 'Tagbanwa'],
			['Takr', 'Takri'],
			['Tale', 'Tai_Le'],
			['Talu', 'New_Tai_Lue'],
			['Taml', 'Tamil'],
			['Tang', 'Tangut'],
			['Tavt', 'Tai_Viet'],
			['Telu', 'Telugu'],
			['Tfng', 'Tifinagh'],
			['Tglg', 'Tagalog'],
			['Thaa', 'Thaana'],
			['Thai', 'Thai'],
			['Tibt', 'Tibetan'],
			['Tirh', 'Tirhuta'],
			['Ugar', 'Ugaritic'],
			['Vaii', 'Vai'],
			['Wara', 'Warang_Citi'],
			['Xpeo', 'Old_Persian'],
			['Xsux', 'Cuneiform'],
			['Yiii', 'Yi'],
			['Zanb', 'Zanabazar_Square'],
			['Zinh', 'Inherited'],
			['Qaai', 'Inherited'],
			['Zyyy', 'Common'],
			['Zzzz', 'Unknown'],
			['Adlam', 'Adlam'],
			['Caucasian_Albanian', 'Caucasian_Albanian'],
			['Arabic', 'Arabic'],
			['Imperial_Aramaic', 'Imperial_Aramaic'],
			['Armenian', 'Armenian'],
			['Avestan', 'Avestan'],
			['Balinese', 'Balinese'],
			['Bamum', 'Bamum'],
			['Bassa_Vah', 'Bassa_Vah'],
			['Batak', 'Batak'],
			['Bengali', 'Bengali'],
			['Bhaiksuki', 'Bhaiksuki'],
			['Bopomofo', 'Bopomofo'],
			['Brahmi', 'Brahmi'],
			['Braille', 'Braille'],
			['Buginese', 'Buginese'],
			['Buhid', 'Buhid'],
			['Chakma', 'Chakma'],
			['Canadian_Aboriginal', 'Canadian_Aboriginal'],
			['Carian', 'Carian'],
			['Cherokee', 'Cherokee'],
			['Coptic', 'Coptic'],
			['Cypriot', 'Cypriot'],
			['Cyrillic', 'Cyrillic'],
			['Devanagari', 'Devanagari'],
			['Deseret', 'Deseret'],
			['Duployan', 'Duployan'],
			['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'],
			['Elbasan', 'Elbasan'],
			['Ethiopic', 'Ethiopic'],
			['Georgian', 'Georgian'],
			['Glagolitic', 'Glagolitic'],
			['Masaram_Gondi', 'Masaram_Gondi'],
			['Gothic', 'Gothic'],
			['Grantha', 'Grantha'],
			['Greek', 'Greek'],
			['Gujarati', 'Gujarati'],
			['Gurmukhi', 'Gurmukhi'],
			['Hangul', 'Hangul'],
			['Han', 'Han'],
			['Hanunoo', 'Hanunoo'],
			['Hatran', 'Hatran'],
			['Hebrew', 'Hebrew'],
			['Hiragana', 'Hiragana'],
			['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'],
			['Pahawh_Hmong', 'Pahawh_Hmong'],
			['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'],
			['Old_Hungarian', 'Old_Hungarian'],
			['Old_Italic', 'Old_Italic'],
			['Javanese', 'Javanese'],
			['Kayah_Li', 'Kayah_Li'],
			['Katakana', 'Katakana'],
			['Kharoshthi', 'Kharoshthi'],
			['Khmer', 'Khmer'],
			['Khojki', 'Khojki'],
			['Kannada', 'Kannada'],
			['Kaithi', 'Kaithi'],
			['Tai_Tham', 'Tai_Tham'],
			['Lao', 'Lao'],
			['Latin', 'Latin'],
			['Lepcha', 'Lepcha'],
			['Limbu', 'Limbu'],
			['Linear_A', 'Linear_A'],
			['Linear_B', 'Linear_B'],
			['Lycian', 'Lycian'],
			['Lydian', 'Lydian'],
			['Mahajani', 'Mahajani'],
			['Mandaic', 'Mandaic'],
			['Manichaean', 'Manichaean'],
			['Marchen', 'Marchen'],
			['Mende_Kikakui', 'Mende_Kikakui'],
			['Meroitic_Cursive', 'Meroitic_Cursive'],
			['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'],
			['Malayalam', 'Malayalam'],
			['Mongolian', 'Mongolian'],
			['Mro', 'Mro'],
			['Meetei_Mayek', 'Meetei_Mayek'],
			['Multani', 'Multani'],
			['Myanmar', 'Myanmar'],
			['Old_North_Arabian', 'Old_North_Arabian'],
			['Nabataean', 'Nabataean'],
			['Nko', 'Nko'],
			['Nushu', 'Nushu'],
			['Ogham', 'Ogham'],
			['Ol_Chiki', 'Ol_Chiki'],
			['Old_Turkic', 'Old_Turkic'],
			['Oriya', 'Oriya'],
			['Osage', 'Osage'],
			['Osmanya', 'Osmanya'],
			['Palmyrene', 'Palmyrene'],
			['Pau_Cin_Hau', 'Pau_Cin_Hau'],
			['Old_Permic', 'Old_Permic'],
			['Phags_Pa', 'Phags_Pa'],
			['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'],
			['Psalter_Pahlavi', 'Psalter_Pahlavi'],
			['Phoenician', 'Phoenician'],
			['Miao', 'Miao'],
			['Inscriptional_Parthian', 'Inscriptional_Parthian'],
			['Rejang', 'Rejang'],
			['Runic', 'Runic'],
			['Samaritan', 'Samaritan'],
			['Old_South_Arabian', 'Old_South_Arabian'],
			['Saurashtra', 'Saurashtra'],
			['SignWriting', 'SignWriting'],
			['Shavian', 'Shavian'],
			['Sharada', 'Sharada'],
			['Siddham', 'Siddham'],
			['Khudawadi', 'Khudawadi'],
			['Sinhala', 'Sinhala'],
			['Sora_Sompeng', 'Sora_Sompeng'],
			['Soyombo', 'Soyombo'],
			['Sundanese', 'Sundanese'],
			['Syloti_Nagri', 'Syloti_Nagri'],
			['Syriac', 'Syriac'],
			['Tagbanwa', 'Tagbanwa'],
			['Takri', 'Takri'],
			['Tai_Le', 'Tai_Le'],
			['New_Tai_Lue', 'New_Tai_Lue'],
			['Tamil', 'Tamil'],
			['Tangut', 'Tangut'],
			['Tai_Viet', 'Tai_Viet'],
			['Telugu', 'Telugu'],
			['Tifinagh', 'Tifinagh'],
			['Tagalog', 'Tagalog'],
			['Thaana', 'Thaana'],
			['Tibetan', 'Tibetan'],
			['Tirhuta', 'Tirhuta'],
			['Ugaritic', 'Ugaritic'],
			['Vai', 'Vai'],
			['Warang_Citi', 'Warang_Citi'],
			['Old_Persian', 'Old_Persian'],
			['Cuneiform', 'Cuneiform'],
			['Yi', 'Yi'],
			['Zanabazar_Square', 'Zanabazar_Square'],
			['Inherited', 'Inherited'],
			['Common', 'Common'],
			['Unknown', 'Unknown']
		])],
		['Script_Extensions', new Map([
			['Adlm', 'Adlam'],
			['Aghb', 'Caucasian_Albanian'],
			['Ahom', 'Ahom'],
			['Arab', 'Arabic'],
			['Armi', 'Imperial_Aramaic'],
			['Armn', 'Armenian'],
			['Avst', 'Avestan'],
			['Bali', 'Balinese'],
			['Bamu', 'Bamum'],
			['Bass', 'Bassa_Vah'],
			['Batk', 'Batak'],
			['Beng', 'Bengali'],
			['Bhks', 'Bhaiksuki'],
			['Bopo', 'Bopomofo'],
			['Brah', 'Brahmi'],
			['Brai', 'Braille'],
			['Bugi', 'Buginese'],
			['Buhd', 'Buhid'],
			['Cakm', 'Chakma'],
			['Cans', 'Canadian_Aboriginal'],
			['Cari', 'Carian'],
			['Cham', 'Cham'],
			['Cher', 'Cherokee'],
			['Copt', 'Coptic'],
			['Qaac', 'Coptic'],
			['Cprt', 'Cypriot'],
			['Cyrl', 'Cyrillic'],
			['Deva', 'Devanagari'],
			['Dsrt', 'Deseret'],
			['Dupl', 'Duployan'],
			['Egyp', 'Egyptian_Hieroglyphs'],
			['Elba', 'Elbasan'],
			['Ethi', 'Ethiopic'],
			['Geor', 'Georgian'],
			['Glag', 'Glagolitic'],
			['Gonm', 'Masaram_Gondi'],
			['Goth', 'Gothic'],
			['Gran', 'Grantha'],
			['Grek', 'Greek'],
			['Gujr', 'Gujarati'],
			['Guru', 'Gurmukhi'],
			['Hang', 'Hangul'],
			['Hani', 'Han'],
			['Hano', 'Hanunoo'],
			['Hatr', 'Hatran'],
			['Hebr', 'Hebrew'],
			['Hira', 'Hiragana'],
			['Hluw', 'Anatolian_Hieroglyphs'],
			['Hmng', 'Pahawh_Hmong'],
			['Hrkt', 'Katakana_Or_Hiragana'],
			['Hung', 'Old_Hungarian'],
			['Ital', 'Old_Italic'],
			['Java', 'Javanese'],
			['Kali', 'Kayah_Li'],
			['Kana', 'Katakana'],
			['Khar', 'Kharoshthi'],
			['Khmr', 'Khmer'],
			['Khoj', 'Khojki'],
			['Knda', 'Kannada'],
			['Kthi', 'Kaithi'],
			['Lana', 'Tai_Tham'],
			['Laoo', 'Lao'],
			['Latn', 'Latin'],
			['Lepc', 'Lepcha'],
			['Limb', 'Limbu'],
			['Lina', 'Linear_A'],
			['Linb', 'Linear_B'],
			['Lisu', 'Lisu'],
			['Lyci', 'Lycian'],
			['Lydi', 'Lydian'],
			['Mahj', 'Mahajani'],
			['Mand', 'Mandaic'],
			['Mani', 'Manichaean'],
			['Marc', 'Marchen'],
			['Mend', 'Mende_Kikakui'],
			['Merc', 'Meroitic_Cursive'],
			['Mero', 'Meroitic_Hieroglyphs'],
			['Mlym', 'Malayalam'],
			['Modi', 'Modi'],
			['Mong', 'Mongolian'],
			['Mroo', 'Mro'],
			['Mtei', 'Meetei_Mayek'],
			['Mult', 'Multani'],
			['Mymr', 'Myanmar'],
			['Narb', 'Old_North_Arabian'],
			['Nbat', 'Nabataean'],
			['Newa', 'Newa'],
			['Nkoo', 'Nko'],
			['Nshu', 'Nushu'],
			['Ogam', 'Ogham'],
			['Olck', 'Ol_Chiki'],
			['Orkh', 'Old_Turkic'],
			['Orya', 'Oriya'],
			['Osge', 'Osage'],
			['Osma', 'Osmanya'],
			['Palm', 'Palmyrene'],
			['Pauc', 'Pau_Cin_Hau'],
			['Perm', 'Old_Permic'],
			['Phag', 'Phags_Pa'],
			['Phli', 'Inscriptional_Pahlavi'],
			['Phlp', 'Psalter_Pahlavi'],
			['Phnx', 'Phoenician'],
			['Plrd', 'Miao'],
			['Prti', 'Inscriptional_Parthian'],
			['Rjng', 'Rejang'],
			['Runr', 'Runic'],
			['Samr', 'Samaritan'],
			['Sarb', 'Old_South_Arabian'],
			['Saur', 'Saurashtra'],
			['Sgnw', 'SignWriting'],
			['Shaw', 'Shavian'],
			['Shrd', 'Sharada'],
			['Sidd', 'Siddham'],
			['Sind', 'Khudawadi'],
			['Sinh', 'Sinhala'],
			['Sora', 'Sora_Sompeng'],
			['Soyo', 'Soyombo'],
			['Sund', 'Sundanese'],
			['Sylo', 'Syloti_Nagri'],
			['Syrc', 'Syriac'],
			['Tagb', 'Tagbanwa'],
			['Takr', 'Takri'],
			['Tale', 'Tai_Le'],
			['Talu', 'New_Tai_Lue'],
			['Taml', 'Tamil'],
			['Tang', 'Tangut'],
			['Tavt', 'Tai_Viet'],
			['Telu', 'Telugu'],
			['Tfng', 'Tifinagh'],
			['Tglg', 'Tagalog'],
			['Thaa', 'Thaana'],
			['Thai', 'Thai'],
			['Tibt', 'Tibetan'],
			['Tirh', 'Tirhuta'],
			['Ugar', 'Ugaritic'],
			['Vaii', 'Vai'],
			['Wara', 'Warang_Citi'],
			['Xpeo', 'Old_Persian'],
			['Xsux', 'Cuneiform'],
			['Yiii', 'Yi'],
			['Zanb', 'Zanabazar_Square'],
			['Zinh', 'Inherited'],
			['Qaai', 'Inherited'],
			['Zyyy', 'Common'],
			['Zzzz', 'Unknown'],
			['Adlam', 'Adlam'],
			['Caucasian_Albanian', 'Caucasian_Albanian'],
			['Arabic', 'Arabic'],
			['Imperial_Aramaic', 'Imperial_Aramaic'],
			['Armenian', 'Armenian'],
			['Avestan', 'Avestan'],
			['Balinese', 'Balinese'],
			['Bamum', 'Bamum'],
			['Bassa_Vah', 'Bassa_Vah'],
			['Batak', 'Batak'],
			['Bengali', 'Bengali'],
			['Bhaiksuki', 'Bhaiksuki'],
			['Bopomofo', 'Bopomofo'],
			['Brahmi', 'Brahmi'],
			['Braille', 'Braille'],
			['Buginese', 'Buginese'],
			['Buhid', 'Buhid'],
			['Chakma', 'Chakma'],
			['Canadian_Aboriginal', 'Canadian_Aboriginal'],
			['Carian', 'Carian'],
			['Cherokee', 'Cherokee'],
			['Coptic', 'Coptic'],
			['Cypriot', 'Cypriot'],
			['Cyrillic', 'Cyrillic'],
			['Devanagari', 'Devanagari'],
			['Deseret', 'Deseret'],
			['Duployan', 'Duployan'],
			['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'],
			['Elbasan', 'Elbasan'],
			['Ethiopic', 'Ethiopic'],
			['Georgian', 'Georgian'],
			['Glagolitic', 'Glagolitic'],
			['Masaram_Gondi', 'Masaram_Gondi'],
			['Gothic', 'Gothic'],
			['Grantha', 'Grantha'],
			['Greek', 'Greek'],
			['Gujarati', 'Gujarati'],
			['Gurmukhi', 'Gurmukhi'],
			['Hangul', 'Hangul'],
			['Han', 'Han'],
			['Hanunoo', 'Hanunoo'],
			['Hatran', 'Hatran'],
			['Hebrew', 'Hebrew'],
			['Hiragana', 'Hiragana'],
			['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'],
			['Pahawh_Hmong', 'Pahawh_Hmong'],
			['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'],
			['Old_Hungarian', 'Old_Hungarian'],
			['Old_Italic', 'Old_Italic'],
			['Javanese', 'Javanese'],
			['Kayah_Li', 'Kayah_Li'],
			['Katakana', 'Katakana'],
			['Kharoshthi', 'Kharoshthi'],
			['Khmer', 'Khmer'],
			['Khojki', 'Khojki'],
			['Kannada', 'Kannada'],
			['Kaithi', 'Kaithi'],
			['Tai_Tham', 'Tai_Tham'],
			['Lao', 'Lao'],
			['Latin', 'Latin'],
			['Lepcha', 'Lepcha'],
			['Limbu', 'Limbu'],
			['Linear_A', 'Linear_A'],
			['Linear_B', 'Linear_B'],
			['Lycian', 'Lycian'],
			['Lydian', 'Lydian'],
			['Mahajani', 'Mahajani'],
			['Mandaic', 'Mandaic'],
			['Manichaean', 'Manichaean'],
			['Marchen', 'Marchen'],
			['Mende_Kikakui', 'Mende_Kikakui'],
			['Meroitic_Cursive', 'Meroitic_Cursive'],
			['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'],
			['Malayalam', 'Malayalam'],
			['Mongolian', 'Mongolian'],
			['Mro', 'Mro'],
			['Meetei_Mayek', 'Meetei_Mayek'],
			['Multani', 'Multani'],
			['Myanmar', 'Myanmar'],
			['Old_North_Arabian', 'Old_North_Arabian'],
			['Nabataean', 'Nabataean'],
			['Nko', 'Nko'],
			['Nushu', 'Nushu'],
			['Ogham', 'Ogham'],
			['Ol_Chiki', 'Ol_Chiki'],
			['Old_Turkic', 'Old_Turkic'],
			['Oriya', 'Oriya'],
			['Osage', 'Osage'],
			['Osmanya', 'Osmanya'],
			['Palmyrene', 'Palmyrene'],
			['Pau_Cin_Hau', 'Pau_Cin_Hau'],
			['Old_Permic', 'Old_Permic'],
			['Phags_Pa', 'Phags_Pa'],
			['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'],
			['Psalter_Pahlavi', 'Psalter_Pahlavi'],
			['Phoenician', 'Phoenician'],
			['Miao', 'Miao'],
			['Inscriptional_Parthian', 'Inscriptional_Parthian'],
			['Rejang', 'Rejang'],
			['Runic', 'Runic'],
			['Samaritan', 'Samaritan'],
			['Old_South_Arabian', 'Old_South_Arabian'],
			['Saurashtra', 'Saurashtra'],
			['SignWriting', 'SignWriting'],
			['Shavian', 'Shavian'],
			['Sharada', 'Sharada'],
			['Siddham', 'Siddham'],
			['Khudawadi', 'Khudawadi'],
			['Sinhala', 'Sinhala'],
			['Sora_Sompeng', 'Sora_Sompeng'],
			['Soyombo', 'Soyombo'],
			['Sundanese', 'Sundanese'],
			['Syloti_Nagri', 'Syloti_Nagri'],
			['Syriac', 'Syriac'],
			['Tagbanwa', 'Tagbanwa'],
			['Takri', 'Takri'],
			['Tai_Le', 'Tai_Le'],
			['New_Tai_Lue', 'New_Tai_Lue'],
			['Tamil', 'Tamil'],
			['Tangut', 'Tangut'],
			['Tai_Viet', 'Tai_Viet'],
			['Telugu', 'Telugu'],
			['Tifinagh', 'Tifinagh'],
			['Tagalog', 'Tagalog'],
			['Thaana', 'Thaana'],
			['Tibetan', 'Tibetan'],
			['Tirhuta', 'Tirhuta'],
			['Ugaritic', 'Ugaritic'],
			['Vai', 'Vai'],
			['Warang_Citi', 'Warang_Citi'],
			['Old_Persian', 'Old_Persian'],
			['Cuneiform', 'Cuneiform'],
			['Yi', 'Yi'],
			['Zanabazar_Square', 'Zanabazar_Square'],
			['Inherited', 'Inherited'],
			['Common', 'Common'],
			['Unknown', 'Unknown']
		])]
	]);
	
	var matchPropertyValue = function(property, value) {
		var aliasToValue = mappings.get(property);
		if (!aliasToValue) {
			throw new Error(("Unknown property `" + property + "`."));
		}
		var canonicalValue = aliasToValue.get(value);
		if (canonicalValue) {
			return canonicalValue;
		}
		throw new Error(
			("Unknown value `" + value + "` for property `" + property + "`.")
		);
	};
	
	var unicodeMatchPropertyValueEcmascript = matchPropertyValue;
	
	var iuMappings = new Map([
		[0x4B, 0x212A],
		[0x53, 0x17F],
		[0x6B, 0x212A],
		[0x73, 0x17F],
		[0xB5, 0x39C],
		[0xC5, 0x212B],
		[0xDF, 0x1E9E],
		[0xE5, 0x212B],
		[0x17F, 0x53],
		[0x1C4, 0x1C5],
		[0x1C5, 0x1C4],
		[0x1C7, 0x1C8],
		[0x1C8, 0x1C7],
		[0x1CA, 0x1CB],
		[0x1CB, 0x1CA],
		[0x1F1, 0x1F2],
		[0x1F2, 0x1F1],
		[0x26A, 0xA7AE],
		[0x29D, 0xA7B2],
		[0x345, 0x1FBE],
		[0x392, 0x3D0],
		[0x395, 0x3F5],
		[0x398, 0x3F4],
		[0x399, 0x1FBE],
		[0x39A, 0x3F0],
		[0x39C, 0xB5],
		[0x3A0, 0x3D6],
		[0x3A1, 0x3F1],
		[0x3A3, 0x3C2],
		[0x3A6, 0x3D5],
		[0x3A9, 0x2126],
		[0x3B8, 0x3F4],
		[0x3C2, 0x3A3],
		[0x3C9, 0x2126],
		[0x3D0, 0x392],
		[0x3D1, 0x3F4],
		[0x3D5, 0x3A6],
		[0x3D6, 0x3A0],
		[0x3F0, 0x39A],
		[0x3F1, 0x3A1],
		[0x3F4, [
			0x398,
			0x3D1,
			0x3B8
		]],
		[0x3F5, 0x395],
		[0x412, 0x1C80],
		[0x414, 0x1C81],
		[0x41E, 0x1C82],
		[0x421, 0x1C83],
		[0x422, 0x1C85],
		[0x42A, 0x1C86],
		[0x432, 0x1C80],
		[0x434, 0x1C81],
		[0x43E, 0x1C82],
		[0x441, 0x1C83],
		[0x442, [
			0x1C84,
			0x1C85
		]],
		[0x44A, 0x1C86],
		[0x462, 0x1C87],
		[0x463, 0x1C87],
		[0x13A0, 0xAB70],
		[0x13A1, 0xAB71],
		[0x13A2, 0xAB72],
		[0x13A3, 0xAB73],
		[0x13A4, 0xAB74],
		[0x13A5, 0xAB75],
		[0x13A6, 0xAB76],
		[0x13A7, 0xAB77],
		[0x13A8, 0xAB78],
		[0x13A9, 0xAB79],
		[0x13AA, 0xAB7A],
		[0x13AB, 0xAB7B],
		[0x13AC, 0xAB7C],
		[0x13AD, 0xAB7D],
		[0x13AE, 0xAB7E],
		[0x13AF, 0xAB7F],
		[0x13B0, 0xAB80],
		[0x13B1, 0xAB81],
		[0x13B2, 0xAB82],
		[0x13B3, 0xAB83],
		[0x13B4, 0xAB84],
		[0x13B5, 0xAB85],
		[0x13B6, 0xAB86],
		[0x13B7, 0xAB87],
		[0x13B8, 0xAB88],
		[0x13B9, 0xAB89],
		[0x13BA, 0xAB8A],
		[0x13BB, 0xAB8B],
		[0x13BC, 0xAB8C],
		[0x13BD, 0xAB8D],
		[0x13BE, 0xAB8E],
		[0x13BF, 0xAB8F],
		[0x13C0, 0xAB90],
		[0x13C1, 0xAB91],
		[0x13C2, 0xAB92],
		[0x13C3, 0xAB93],
		[0x13C4, 0xAB94],
		[0x13C5, 0xAB95],
		[0x13C6, 0xAB96],
		[0x13C7, 0xAB97],
		[0x13C8, 0xAB98],
		[0x13C9, 0xAB99],
		[0x13CA, 0xAB9A],
		[0x13CB, 0xAB9B],
		[0x13CC, 0xAB9C],
		[0x13CD, 0xAB9D],
		[0x13CE, 0xAB9E],
		[0x13CF, 0xAB9F],
		[0x13D0, 0xABA0],
		[0x13D1, 0xABA1],
		[0x13D2, 0xABA2],
		[0x13D3, 0xABA3],
		[0x13D4, 0xABA4],
		[0x13D5, 0xABA5],
		[0x13D6, 0xABA6],
		[0x13D7, 0xABA7],
		[0x13D8, 0xABA8],
		[0x13D9, 0xABA9],
		[0x13DA, 0xABAA],
		[0x13DB, 0xABAB],
		[0x13DC, 0xABAC],
		[0x13DD, 0xABAD],
		[0x13DE, 0xABAE],
		[0x13DF, 0xABAF],
		[0x13E0, 0xABB0],
		[0x13E1, 0xABB1],
		[0x13E2, 0xABB2],
		[0x13E3, 0xABB3],
		[0x13E4, 0xABB4],
		[0x13E5, 0xABB5],
		[0x13E6, 0xABB6],
		[0x13E7, 0xABB7],
		[0x13E8, 0xABB8],
		[0x13E9, 0xABB9],
		[0x13EA, 0xABBA],
		[0x13EB, 0xABBB],
		[0x13EC, 0xABBC],
		[0x13ED, 0xABBD],
		[0x13EE, 0xABBE],
		[0x13EF, 0xABBF],
		[0x13F0, 0x13F8],
		[0x13F1, 0x13F9],
		[0x13F2, 0x13FA],
		[0x13F3, 0x13FB],
		[0x13F4, 0x13FC],
		[0x13F5, 0x13FD],
		[0x13F8, 0x13F0],
		[0x13F9, 0x13F1],
		[0x13FA, 0x13F2],
		[0x13FB, 0x13F3],
		[0x13FC, 0x13F4],
		[0x13FD, 0x13F5],
		[0x1C80, [
			0x412,
			0x432
		]],
		[0x1C81, [
			0x414,
			0x434
		]],
		[0x1C82, [
			0x41E,
			0x43E
		]],
		[0x1C83, [
			0x421,
			0x441
		]],
		[0x1C84, [
			0x1C85,
			0x442
		]],
		[0x1C85, [
			0x422,
			0x1C84,
			0x442
		]],
		[0x1C86, [
			0x42A,
			0x44A
		]],
		[0x1C87, [
			0x462,
			0x463
		]],
		[0x1C88, [
			0xA64A,
			0xA64B
		]],
		[0x1E60, 0x1E9B],
		[0x1E9B, 0x1E60],
		[0x1E9E, 0xDF],
		[0x1F80, 0x1F88],
		[0x1F81, 0x1F89],
		[0x1F82, 0x1F8A],
		[0x1F83, 0x1F8B],
		[0x1F84, 0x1F8C],
		[0x1F85, 0x1F8D],
		[0x1F86, 0x1F8E],
		[0x1F87, 0x1F8F],
		[0x1F88, 0x1F80],
		[0x1F89, 0x1F81],
		[0x1F8A, 0x1F82],
		[0x1F8B, 0x1F83],
		[0x1F8C, 0x1F84],
		[0x1F8D, 0x1F85],
		[0x1F8E, 0x1F86],
		[0x1F8F, 0x1F87],
		[0x1F90, 0x1F98],
		[0x1F91, 0x1F99],
		[0x1F92, 0x1F9A],
		[0x1F93, 0x1F9B],
		[0x1F94, 0x1F9C],
		[0x1F95, 0x1F9D],
		[0x1F96, 0x1F9E],
		[0x1F97, 0x1F9F],
		[0x1F98, 0x1F90],
		[0x1F99, 0x1F91],
		[0x1F9A, 0x1F92],
		[0x1F9B, 0x1F93],
		[0x1F9C, 0x1F94],
		[0x1F9D, 0x1F95],
		[0x1F9E, 0x1F96],
		[0x1F9F, 0x1F97],
		[0x1FA0, 0x1FA8],
		[0x1FA1, 0x1FA9],
		[0x1FA2, 0x1FAA],
		[0x1FA3, 0x1FAB],
		[0x1FA4, 0x1FAC],
		[0x1FA5, 0x1FAD],
		[0x1FA6, 0x1FAE],
		[0x1FA7, 0x1FAF],
		[0x1FA8, 0x1FA0],
		[0x1FA9, 0x1FA1],
		[0x1FAA, 0x1FA2],
		[0x1FAB, 0x1FA3],
		[0x1FAC, 0x1FA4],
		[0x1FAD, 0x1FA5],
		[0x1FAE, 0x1FA6],
		[0x1FAF, 0x1FA7],
		[0x1FB3, 0x1FBC],
		[0x1FBC, 0x1FB3],
		[0x1FBE, [
			0x345,
			0x399
		]],
		[0x1FC3, 0x1FCC],
		[0x1FCC, 0x1FC3],
		[0x1FF3, 0x1FFC],
		[0x1FFC, 0x1FF3],
		[0x2126, [
			0x3A9,
			0x3C9
		]],
		[0x212A, 0x4B],
		[0x212B, [
			0xC5,
			0xE5
		]],
		[0xA64A, 0x1C88],
		[0xA64B, 0x1C88],
		[0xA7AE, 0x26A],
		[0xA7B2, 0x29D],
		[0xA7B3, 0xAB53],
		[0xA7B4, 0xA7B5],
		[0xA7B5, 0xA7B4],
		[0xA7B6, 0xA7B7],
		[0xA7B7, 0xA7B6],
		[0xAB53, 0xA7B3],
		[0xAB70, 0x13A0],
		[0xAB71, 0x13A1],
		[0xAB72, 0x13A2],
		[0xAB73, 0x13A3],
		[0xAB74, 0x13A4],
		[0xAB75, 0x13A5],
		[0xAB76, 0x13A6],
		[0xAB77, 0x13A7],
		[0xAB78, 0x13A8],
		[0xAB79, 0x13A9],
		[0xAB7A, 0x13AA],
		[0xAB7B, 0x13AB],
		[0xAB7C, 0x13AC],
		[0xAB7D, 0x13AD],
		[0xAB7E, 0x13AE],
		[0xAB7F, 0x13AF],
		[0xAB80, 0x13B0],
		[0xAB81, 0x13B1],
		[0xAB82, 0x13B2],
		[0xAB83, 0x13B3],
		[0xAB84, 0x13B4],
		[0xAB85, 0x13B5],
		[0xAB86, 0x13B6],
		[0xAB87, 0x13B7],
		[0xAB88, 0x13B8],
		[0xAB89, 0x13B9],
		[0xAB8A, 0x13BA],
		[0xAB8B, 0x13BB],
		[0xAB8C, 0x13BC],
		[0xAB8D, 0x13BD],
		[0xAB8E, 0x13BE],
		[0xAB8F, 0x13BF],
		[0xAB90, 0x13C0],
		[0xAB91, 0x13C1],
		[0xAB92, 0x13C2],
		[0xAB93, 0x13C3],
		[0xAB94, 0x13C4],
		[0xAB95, 0x13C5],
		[0xAB96, 0x13C6],
		[0xAB97, 0x13C7],
		[0xAB98, 0x13C8],
		[0xAB99, 0x13C9],
		[0xAB9A, 0x13CA],
		[0xAB9B, 0x13CB],
		[0xAB9C, 0x13CC],
		[0xAB9D, 0x13CD],
		[0xAB9E, 0x13CE],
		[0xAB9F, 0x13CF],
		[0xABA0, 0x13D0],
		[0xABA1, 0x13D1],
		[0xABA2, 0x13D2],
		[0xABA3, 0x13D3],
		[0xABA4, 0x13D4],
		[0xABA5, 0x13D5],
		[0xABA6, 0x13D6],
		[0xABA7, 0x13D7],
		[0xABA8, 0x13D8],
		[0xABA9, 0x13D9],
		[0xABAA, 0x13DA],
		[0xABAB, 0x13DB],
		[0xABAC, 0x13DC],
		[0xABAD, 0x13DD],
		[0xABAE, 0x13DE],
		[0xABAF, 0x13DF],
		[0xABB0, 0x13E0],
		[0xABB1, 0x13E1],
		[0xABB2, 0x13E2],
		[0xABB3, 0x13E3],
		[0xABB4, 0x13E4],
		[0xABB5, 0x13E5],
		[0xABB6, 0x13E6],
		[0xABB7, 0x13E7],
		[0xABB8, 0x13E8],
		[0xABB9, 0x13E9],
		[0xABBA, 0x13EA],
		[0xABBB, 0x13EB],
		[0xABBC, 0x13EC],
		[0xABBD, 0x13ED],
		[0xABBE, 0x13EE],
		[0xABBF, 0x13EF],
		[0x10400, 0x10428],
		[0x10401, 0x10429],
		[0x10402, 0x1042A],
		[0x10403, 0x1042B],
		[0x10404, 0x1042C],
		[0x10405, 0x1042D],
		[0x10406, 0x1042E],
		[0x10407, 0x1042F],
		[0x10408, 0x10430],
		[0x10409, 0x10431],
		[0x1040A, 0x10432],
		[0x1040B, 0x10433],
		[0x1040C, 0x10434],
		[0x1040D, 0x10435],
		[0x1040E, 0x10436],
		[0x1040F, 0x10437],
		[0x10410, 0x10438],
		[0x10411, 0x10439],
		[0x10412, 0x1043A],
		[0x10413, 0x1043B],
		[0x10414, 0x1043C],
		[0x10415, 0x1043D],
		[0x10416, 0x1043E],
		[0x10417, 0x1043F],
		[0x10418, 0x10440],
		[0x10419, 0x10441],
		[0x1041A, 0x10442],
		[0x1041B, 0x10443],
		[0x1041C, 0x10444],
		[0x1041D, 0x10445],
		[0x1041E, 0x10446],
		[0x1041F, 0x10447],
		[0x10420, 0x10448],
		[0x10421, 0x10449],
		[0x10422, 0x1044A],
		[0x10423, 0x1044B],
		[0x10424, 0x1044C],
		[0x10425, 0x1044D],
		[0x10426, 0x1044E],
		[0x10427, 0x1044F],
		[0x10428, 0x10400],
		[0x10429, 0x10401],
		[0x1042A, 0x10402],
		[0x1042B, 0x10403],
		[0x1042C, 0x10404],
		[0x1042D, 0x10405],
		[0x1042E, 0x10406],
		[0x1042F, 0x10407],
		[0x10430, 0x10408],
		[0x10431, 0x10409],
		[0x10432, 0x1040A],
		[0x10433, 0x1040B],
		[0x10434, 0x1040C],
		[0x10435, 0x1040D],
		[0x10436, 0x1040E],
		[0x10437, 0x1040F],
		[0x10438, 0x10410],
		[0x10439, 0x10411],
		[0x1043A, 0x10412],
		[0x1043B, 0x10413],
		[0x1043C, 0x10414],
		[0x1043D, 0x10415],
		[0x1043E, 0x10416],
		[0x1043F, 0x10417],
		[0x10440, 0x10418],
		[0x10441, 0x10419],
		[0x10442, 0x1041A],
		[0x10443, 0x1041B],
		[0x10444, 0x1041C],
		[0x10445, 0x1041D],
		[0x10446, 0x1041E],
		[0x10447, 0x1041F],
		[0x10448, 0x10420],
		[0x10449, 0x10421],
		[0x1044A, 0x10422],
		[0x1044B, 0x10423],
		[0x1044C, 0x10424],
		[0x1044D, 0x10425],
		[0x1044E, 0x10426],
		[0x1044F, 0x10427],
		[0x104B0, 0x104D8],
		[0x104B1, 0x104D9],
		[0x104B2, 0x104DA],
		[0x104B3, 0x104DB],
		[0x104B4, 0x104DC],
		[0x104B5, 0x104DD],
		[0x104B6, 0x104DE],
		[0x104B7, 0x104DF],
		[0x104B8, 0x104E0],
		[0x104B9, 0x104E1],
		[0x104BA, 0x104E2],
		[0x104BB, 0x104E3],
		[0x104BC, 0x104E4],
		[0x104BD, 0x104E5],
		[0x104BE, 0x104E6],
		[0x104BF, 0x104E7],
		[0x104C0, 0x104E8],
		[0x104C1, 0x104E9],
		[0x104C2, 0x104EA],
		[0x104C3, 0x104EB],
		[0x104C4, 0x104EC],
		[0x104C5, 0x104ED],
		[0x104C6, 0x104EE],
		[0x104C7, 0x104EF],
		[0x104C8, 0x104F0],
		[0x104C9, 0x104F1],
		[0x104CA, 0x104F2],
		[0x104CB, 0x104F3],
		[0x104CC, 0x104F4],
		[0x104CD, 0x104F5],
		[0x104CE, 0x104F6],
		[0x104CF, 0x104F7],
		[0x104D0, 0x104F8],
		[0x104D1, 0x104F9],
		[0x104D2, 0x104FA],
		[0x104D3, 0x104FB],
		[0x104D8, 0x104B0],
		[0x104D9, 0x104B1],
		[0x104DA, 0x104B2],
		[0x104DB, 0x104B3],
		[0x104DC, 0x104B4],
		[0x104DD, 0x104B5],
		[0x104DE, 0x104B6],
		[0x104DF, 0x104B7],
		[0x104E0, 0x104B8],
		[0x104E1, 0x104B9],
		[0x104E2, 0x104BA],
		[0x104E3, 0x104BB],
		[0x104E4, 0x104BC],
		[0x104E5, 0x104BD],
		[0x104E6, 0x104BE],
		[0x104E7, 0x104BF],
		[0x104E8, 0x104C0],
		[0x104E9, 0x104C1],
		[0x104EA, 0x104C2],
		[0x104EB, 0x104C3],
		[0x104EC, 0x104C4],
		[0x104ED, 0x104C5],
		[0x104EE, 0x104C6],
		[0x104EF, 0x104C7],
		[0x104F0, 0x104C8],
		[0x104F1, 0x104C9],
		[0x104F2, 0x104CA],
		[0x104F3, 0x104CB],
		[0x104F4, 0x104CC],
		[0x104F5, 0x104CD],
		[0x104F6, 0x104CE],
		[0x104F7, 0x104CF],
		[0x104F8, 0x104D0],
		[0x104F9, 0x104D1],
		[0x104FA, 0x104D2],
		[0x104FB, 0x104D3],
		[0x10C80, 0x10CC0],
		[0x10C81, 0x10CC1],
		[0x10C82, 0x10CC2],
		[0x10C83, 0x10CC3],
		[0x10C84, 0x10CC4],
		[0x10C85, 0x10CC5],
		[0x10C86, 0x10CC6],
		[0x10C87, 0x10CC7],
		[0x10C88, 0x10CC8],
		[0x10C89, 0x10CC9],
		[0x10C8A, 0x10CCA],
		[0x10C8B, 0x10CCB],
		[0x10C8C, 0x10CCC],
		[0x10C8D, 0x10CCD],
		[0x10C8E, 0x10CCE],
		[0x10C8F, 0x10CCF],
		[0x10C90, 0x10CD0],
		[0x10C91, 0x10CD1],
		[0x10C92, 0x10CD2],
		[0x10C93, 0x10CD3],
		[0x10C94, 0x10CD4],
		[0x10C95, 0x10CD5],
		[0x10C96, 0x10CD6],
		[0x10C97, 0x10CD7],
		[0x10C98, 0x10CD8],
		[0x10C99, 0x10CD9],
		[0x10C9A, 0x10CDA],
		[0x10C9B, 0x10CDB],
		[0x10C9C, 0x10CDC],
		[0x10C9D, 0x10CDD],
		[0x10C9E, 0x10CDE],
		[0x10C9F, 0x10CDF],
		[0x10CA0, 0x10CE0],
		[0x10CA1, 0x10CE1],
		[0x10CA2, 0x10CE2],
		[0x10CA3, 0x10CE3],
		[0x10CA4, 0x10CE4],
		[0x10CA5, 0x10CE5],
		[0x10CA6, 0x10CE6],
		[0x10CA7, 0x10CE7],
		[0x10CA8, 0x10CE8],
		[0x10CA9, 0x10CE9],
		[0x10CAA, 0x10CEA],
		[0x10CAB, 0x10CEB],
		[0x10CAC, 0x10CEC],
		[0x10CAD, 0x10CED],
		[0x10CAE, 0x10CEE],
		[0x10CAF, 0x10CEF],
		[0x10CB0, 0x10CF0],
		[0x10CB1, 0x10CF1],
		[0x10CB2, 0x10CF2],
		[0x10CC0, 0x10C80],
		[0x10CC1, 0x10C81],
		[0x10CC2, 0x10C82],
		[0x10CC3, 0x10C83],
		[0x10CC4, 0x10C84],
		[0x10CC5, 0x10C85],
		[0x10CC6, 0x10C86],
		[0x10CC7, 0x10C87],
		[0x10CC8, 0x10C88],
		[0x10CC9, 0x10C89],
		[0x10CCA, 0x10C8A],
		[0x10CCB, 0x10C8B],
		[0x10CCC, 0x10C8C],
		[0x10CCD, 0x10C8D],
		[0x10CCE, 0x10C8E],
		[0x10CCF, 0x10C8F],
		[0x10CD0, 0x10C90],
		[0x10CD1, 0x10C91],
		[0x10CD2, 0x10C92],
		[0x10CD3, 0x10C93],
		[0x10CD4, 0x10C94],
		[0x10CD5, 0x10C95],
		[0x10CD6, 0x10C96],
		[0x10CD7, 0x10C97],
		[0x10CD8, 0x10C98],
		[0x10CD9, 0x10C99],
		[0x10CDA, 0x10C9A],
		[0x10CDB, 0x10C9B],
		[0x10CDC, 0x10C9C],
		[0x10CDD, 0x10C9D],
		[0x10CDE, 0x10C9E],
		[0x10CDF, 0x10C9F],
		[0x10CE0, 0x10CA0],
		[0x10CE1, 0x10CA1],
		[0x10CE2, 0x10CA2],
		[0x10CE3, 0x10CA3],
		[0x10CE4, 0x10CA4],
		[0x10CE5, 0x10CA5],
		[0x10CE6, 0x10CA6],
		[0x10CE7, 0x10CA7],
		[0x10CE8, 0x10CA8],
		[0x10CE9, 0x10CA9],
		[0x10CEA, 0x10CAA],
		[0x10CEB, 0x10CAB],
		[0x10CEC, 0x10CAC],
		[0x10CED, 0x10CAD],
		[0x10CEE, 0x10CAE],
		[0x10CEF, 0x10CAF],
		[0x10CF0, 0x10CB0],
		[0x10CF1, 0x10CB1],
		[0x10CF2, 0x10CB2],
		[0x118A0, 0x118C0],
		[0x118A1, 0x118C1],
		[0x118A2, 0x118C2],
		[0x118A3, 0x118C3],
		[0x118A4, 0x118C4],
		[0x118A5, 0x118C5],
		[0x118A6, 0x118C6],
		[0x118A7, 0x118C7],
		[0x118A8, 0x118C8],
		[0x118A9, 0x118C9],
		[0x118AA, 0x118CA],
		[0x118AB, 0x118CB],
		[0x118AC, 0x118CC],
		[0x118AD, 0x118CD],
		[0x118AE, 0x118CE],
		[0x118AF, 0x118CF],
		[0x118B0, 0x118D0],
		[0x118B1, 0x118D1],
		[0x118B2, 0x118D2],
		[0x118B3, 0x118D3],
		[0x118B4, 0x118D4],
		[0x118B5, 0x118D5],
		[0x118B6, 0x118D6],
		[0x118B7, 0x118D7],
		[0x118B8, 0x118D8],
		[0x118B9, 0x118D9],
		[0x118BA, 0x118DA],
		[0x118BB, 0x118DB],
		[0x118BC, 0x118DC],
		[0x118BD, 0x118DD],
		[0x118BE, 0x118DE],
		[0x118BF, 0x118DF],
		[0x118C0, 0x118A0],
		[0x118C1, 0x118A1],
		[0x118C2, 0x118A2],
		[0x118C3, 0x118A3],
		[0x118C4, 0x118A4],
		[0x118C5, 0x118A5],
		[0x118C6, 0x118A6],
		[0x118C7, 0x118A7],
		[0x118C8, 0x118A8],
		[0x118C9, 0x118A9],
		[0x118CA, 0x118AA],
		[0x118CB, 0x118AB],
		[0x118CC, 0x118AC],
		[0x118CD, 0x118AD],
		[0x118CE, 0x118AE],
		[0x118CF, 0x118AF],
		[0x118D0, 0x118B0],
		[0x118D1, 0x118B1],
		[0x118D2, 0x118B2],
		[0x118D3, 0x118B3],
		[0x118D4, 0x118B4],
		[0x118D5, 0x118B5],
		[0x118D6, 0x118B6],
		[0x118D7, 0x118B7],
		[0x118D8, 0x118B8],
		[0x118D9, 0x118B9],
		[0x118DA, 0x118BA],
		[0x118DB, 0x118BB],
		[0x118DC, 0x118BC],
		[0x118DD, 0x118BD],
		[0x118DE, 0x118BE],
		[0x118DF, 0x118BF],
		[0x1E900, 0x1E922],
		[0x1E901, 0x1E923],
		[0x1E902, 0x1E924],
		[0x1E903, 0x1E925],
		[0x1E904, 0x1E926],
		[0x1E905, 0x1E927],
		[0x1E906, 0x1E928],
		[0x1E907, 0x1E929],
		[0x1E908, 0x1E92A],
		[0x1E909, 0x1E92B],
		[0x1E90A, 0x1E92C],
		[0x1E90B, 0x1E92D],
		[0x1E90C, 0x1E92E],
		[0x1E90D, 0x1E92F],
		[0x1E90E, 0x1E930],
		[0x1E90F, 0x1E931],
		[0x1E910, 0x1E932],
		[0x1E911, 0x1E933],
		[0x1E912, 0x1E934],
		[0x1E913, 0x1E935],
		[0x1E914, 0x1E936],
		[0x1E915, 0x1E937],
		[0x1E916, 0x1E938],
		[0x1E917, 0x1E939],
		[0x1E918, 0x1E93A],
		[0x1E919, 0x1E93B],
		[0x1E91A, 0x1E93C],
		[0x1E91B, 0x1E93D],
		[0x1E91C, 0x1E93E],
		[0x1E91D, 0x1E93F],
		[0x1E91E, 0x1E940],
		[0x1E91F, 0x1E941],
		[0x1E920, 0x1E942],
		[0x1E921, 0x1E943],
		[0x1E922, 0x1E900],
		[0x1E923, 0x1E901],
		[0x1E924, 0x1E902],
		[0x1E925, 0x1E903],
		[0x1E926, 0x1E904],
		[0x1E927, 0x1E905],
		[0x1E928, 0x1E906],
		[0x1E929, 0x1E907],
		[0x1E92A, 0x1E908],
		[0x1E92B, 0x1E909],
		[0x1E92C, 0x1E90A],
		[0x1E92D, 0x1E90B],
		[0x1E92E, 0x1E90C],
		[0x1E92F, 0x1E90D],
		[0x1E930, 0x1E90E],
		[0x1E931, 0x1E90F],
		[0x1E932, 0x1E910],
		[0x1E933, 0x1E911],
		[0x1E934, 0x1E912],
		[0x1E935, 0x1E913],
		[0x1E936, 0x1E914],
		[0x1E937, 0x1E915],
		[0x1E938, 0x1E916],
		[0x1E939, 0x1E917],
		[0x1E93A, 0x1E918],
		[0x1E93B, 0x1E919],
		[0x1E93C, 0x1E91A],
		[0x1E93D, 0x1E91B],
		[0x1E93E, 0x1E91C],
		[0x1E93F, 0x1E91D],
		[0x1E940, 0x1E91E],
		[0x1E941, 0x1E91F],
		[0x1E942, 0x1E920],
		[0x1E943, 0x1E921]
	]);
	
	var REGULAR = new Map([
		['d', regenerate()
			.addRange(0x30, 0x39)],
		['D', regenerate()
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0xFFFF)],
		['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF)
			.addRange(0x9, 0xD)
			.addRange(0x2000, 0x200A)
			.addRange(0x2028, 0x2029)],
		['S', regenerate()
			.addRange(0x0, 0x8)
			.addRange(0xE, 0x1F)
			.addRange(0x21, 0x9F)
			.addRange(0xA1, 0x167F)
			.addRange(0x1681, 0x1FFF)
			.addRange(0x200B, 0x2027)
			.addRange(0x202A, 0x202E)
			.addRange(0x2030, 0x205E)
			.addRange(0x2060, 0x2FFF)
			.addRange(0x3001, 0xFEFE)
			.addRange(0xFF00, 0xFFFF)],
		['w', regenerate(0x5F)
			.addRange(0x30, 0x39)
			.addRange(0x41, 0x5A)
			.addRange(0x61, 0x7A)],
		['W', regenerate(0x60)
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x40)
			.addRange(0x5B, 0x5E)
			.addRange(0x7B, 0xFFFF)]
	]);
	
	var UNICODE = new Map([
		['d', regenerate()
			.addRange(0x30, 0x39)],
		['D', regenerate()
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x10FFFF)],
		['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF)
			.addRange(0x9, 0xD)
			.addRange(0x2000, 0x200A)
			.addRange(0x2028, 0x2029)],
		['S', regenerate()
			.addRange(0x0, 0x8)
			.addRange(0xE, 0x1F)
			.addRange(0x21, 0x9F)
			.addRange(0xA1, 0x167F)
			.addRange(0x1681, 0x1FFF)
			.addRange(0x200B, 0x2027)
			.addRange(0x202A, 0x202E)
			.addRange(0x2030, 0x205E)
			.addRange(0x2060, 0x2FFF)
			.addRange(0x3001, 0xFEFE)
			.addRange(0xFF00, 0x10FFFF)],
		['w', regenerate(0x5F)
			.addRange(0x30, 0x39)
			.addRange(0x41, 0x5A)
			.addRange(0x61, 0x7A)],
		['W', regenerate(0x60)
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x40)
			.addRange(0x5B, 0x5E)
			.addRange(0x7B, 0x10FFFF)]
	]);
	
	var UNICODE_IGNORE_CASE = new Map([
		['d', regenerate()
			.addRange(0x30, 0x39)],
		['D', regenerate()
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x10FFFF)],
		['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF)
			.addRange(0x9, 0xD)
			.addRange(0x2000, 0x200A)
			.addRange(0x2028, 0x2029)],
		['S', regenerate()
			.addRange(0x0, 0x8)
			.addRange(0xE, 0x1F)
			.addRange(0x21, 0x9F)
			.addRange(0xA1, 0x167F)
			.addRange(0x1681, 0x1FFF)
			.addRange(0x200B, 0x2027)
			.addRange(0x202A, 0x202E)
			.addRange(0x2030, 0x205E)
			.addRange(0x2060, 0x2FFF)
			.addRange(0x3001, 0xFEFE)
			.addRange(0xFF00, 0x10FFFF)],
		['w', regenerate(0x5F, 0x17F, 0x212A)
			.addRange(0x30, 0x39)
			.addRange(0x41, 0x5A)
			.addRange(0x61, 0x7A)],
		['W', regenerate(0x60)
			.addRange(0x0, 0x2F)
			.addRange(0x3A, 0x40)
			.addRange(0x5B, 0x5E)
			.addRange(0x7B, 0x17E)
			.addRange(0x180, 0x2129)
			.addRange(0x212B, 0x10FFFF)]
	]);
	
	var characterClassEscapeSets = {
		REGULAR: REGULAR,
		UNICODE: UNICODE,
		UNICODE_IGNORE_CASE: UNICODE_IGNORE_CASE
	};
	
	var rewritePattern_1 = createCommonjsModule(function (module) {
	var generate = regjsgen.generate;
	var parse = parser.parse;
	
	
	
	
	
	
	// Prepare a Regenerate set containing all code points, used for negative
	// character classes (if any).
	var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
	// Without the `u` flag, the range stops at 0xFFFF.
	// https://mths.be/es6#sec-pattern-semantics
	var BMP_SET = regenerate().addRange(0x0, 0xFFFF);
	
	// Prepare a Regenerate set containing all code points that are supposed to be
	// matched by `/./u`. https://mths.be/es6#sec-atom
	var DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points
		.remove(
			// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):
			0x000A, // Line Feed <LF>
			0x000D, // Carriage Return <CR>
			0x2028, // Line Separator <LS>
			0x2029  // Paragraph Separator <PS>
		);
	// Prepare a Regenerate set containing all code points that are supposed to be
	// matched by `/./` (only BMP code points).
	var DOT_SET = DOT_SET_UNICODE.clone()
		.intersection(BMP_SET);
	
	var getCharacterClassEscapeSet = function (character, unicode, ignoreCase) {
		if (unicode) {
			if (ignoreCase) {
				return characterClassEscapeSets.UNICODE_IGNORE_CASE.get(character);
			}
			return characterClassEscapeSets.UNICODE.get(character);
		}
		return characterClassEscapeSets.REGULAR.get(character);
	};
	
	var getDotSet = function (unicode, dotAll) {
		if (dotAll) {
			return unicode ? UNICODE_SET : BMP_SET;
		}
		return unicode ? DOT_SET_UNICODE : DOT_SET;
	};
	
	var getUnicodePropertyValueSet = function (property, value) {
		var path = value ?
			(property + "/" + value) :
			("Binary_Property/" + property);
		try {
			return commonjsRequire(("regenerate-unicode-properties/" + path + ".js"));
		} catch (exception) {
			throw new Error(
				"Failed to recognize value `" + value + "` for property " +
				"`" + property + "`."
			);
		}
	};
	
	var handleLoneUnicodePropertyNameOrValue = function (value) {
		// It could be a `General_Category` value or a binary property.
		// Note: `unicodeMatchPropertyValue` throws on invalid values.
		try {
			var property$1 = 'General_Category';
			var category = unicodeMatchPropertyValueEcmascript(property$1, value);
			return getUnicodePropertyValueSet(property$1, category);
		} catch (exception) {}
		// Its not a `General_Category` value, so check if its a binary
		// property. Note: `unicodeMatchProperty` throws on invalid properties.
		var property = unicodeMatchPropertyEcmascript(value);
		return getUnicodePropertyValueSet(property);
	};
	
	var getUnicodePropertyEscapeSet = function (value, isNegative) {
		var parts = value.split('=');
		var firstPart = parts[0];
		var set;
		if (parts.length == 1) {
			set = handleLoneUnicodePropertyNameOrValue(firstPart);
		} else {
			// The pattern consists of two parts, i.e. `Property=Value`.
			var property = unicodeMatchPropertyEcmascript(firstPart);
			var value$1 = unicodeMatchPropertyValueEcmascript(property, parts[1]);
			set = getUnicodePropertyValueSet(property, value$1);
		}
		if (isNegative) {
			return UNICODE_SET.clone().remove(set);
		}
		return set.clone();
	};
	
	// Given a range of code points, add any case-folded code points in that range
	// to a set.
	regenerate.prototype.iuAddRange = function(min, max) {
		var $this = this;
		do {
			var folded = caseFold(min);
			if (folded) {
				$this.add(folded);
			}
		} while (++min <= max);
		return $this;
	};
	
	var update = function (item, pattern) {
		var tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');
		switch (tree.type) {
			case 'characterClass':
			case 'group':
			case 'value':
				// No wrapping needed.
				break;
			default:
				// Wrap the pattern in a non-capturing group.
				tree = wrap(tree, pattern);
		}
		Object.assign(item, tree);
	};
	
	var wrap = function (tree, pattern) {
		// Wrap the pattern in a non-capturing group.
		return {
			'type': 'group',
			'behavior': 'ignore',
			'body': [tree],
			'raw': ("(?:" + pattern + ")")
		};
	};
	
	var caseFold = function (codePoint) {
		return iuMappings.get(codePoint) || false;
	};
	
	var processCharacterClass = function (characterClassItem, regenerateOptions) {
		var set = regenerate();
		for (var i = 0, list = characterClassItem.body; i < list.length; i += 1) {
			var item = list[i];
	
			switch (item.type) {
				case 'value':
					set.add(item.codePoint);
					if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
						var folded = caseFold(item.codePoint);
						if (folded) {
							set.add(folded);
						}
					}
					break;
				case 'characterClassRange':
					var min = item.min.codePoint;
					var max = item.max.codePoint;
					set.addRange(min, max);
					if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
						set.iuAddRange(min, max);
					}
					break;
				case 'characterClassEscape':
					set.add(getCharacterClassEscapeSet(
						item.value,
						config.unicode,
						config.ignoreCase
					));
					break;
				case 'unicodePropertyEscape':
					set.add(getUnicodePropertyEscapeSet(item.value, item.negative));
					break;
				// The `default` clause is only here as a safeguard; it should never be
				// reached. Code coverage tools should ignore it.
				/* istanbul ignore next */
				default:
					throw new Error(("Unknown term type: " + (item.type)));
			}
		}
		if (characterClassItem.negative) {
			set = (config.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);
		}
		update(characterClassItem, set.toString(regenerateOptions));
		return characterClassItem;
	};
	
	var processTerm = function (item, regenerateOptions) {
		switch (item.type) {
			case 'dot':
				update(
					item,
					getDotSet(config.unicode, config.dotAll).toString(regenerateOptions)
				);
				break;
			case 'characterClass':
				item = processCharacterClass(item, regenerateOptions);
				break;
			case 'unicodePropertyEscape':
				update(
					item,
					getUnicodePropertyEscapeSet(item.value, item.negative)
						.toString(regenerateOptions)
				);
				break;
			case 'characterClassEscape':
				update(
					item,
					getCharacterClassEscapeSet(
						item.value,
						config.unicode,
						config.ignoreCase
					).toString(regenerateOptions)
				);
				break;
			case 'alternative':
			case 'disjunction':
			case 'group':
			case 'quantifier':
				item.body = item.body.map(function (term) {
					return processTerm(term, regenerateOptions);
				});
				break;
			case 'value':
				var codePoint = item.codePoint;
				var set = regenerate(codePoint);
				if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
					var folded = caseFold(codePoint);
					if (folded) {
						set.add(folded);
					}
				}
				update(item, set.toString(regenerateOptions));
				break;
			case 'anchor':
			case 'empty':
			case 'group':
			case 'reference':
				// Nothing to do here.
				break;
			// The `default` clause is only here as a safeguard; it should never be
			// reached. Code coverage tools should ignore it.
			/* istanbul ignore next */
			default:
				throw new Error(("Unknown term type: " + (item.type)));
		}
		return item;
	};
	
	var config = {
		'ignoreCase': false,
		'unicode': false,
		'dotAll': false,
		'useUnicodeFlag': false
	};
	var rewritePattern = function (pattern, flags, options) {
		var regjsparserFeatures = {
			'unicodePropertyEscape': options && options.unicodePropertyEscape
		};
		config.ignoreCase = flags && flags.includes('i');
		config.unicode = flags && flags.includes('u');
		var supportDotAllFlag = options && options.dotAllFlag;
		config.dotAll = supportDotAllFlag && flags && flags.includes('s');
		config.useUnicodeFlag = options && options.useUnicodeFlag;
		var regenerateOptions = {
			'hasUnicodeFlag': config.useUnicodeFlag,
			'bmpOnly': !config.unicode
		};
		var tree = parse(pattern, flags, regjsparserFeatures);
		// Note: `processTerm` mutates `tree`.
		processTerm(tree, regenerateOptions);
		return generate(tree);
	};
	
	module.exports = rewritePattern;
	});
	
	var Literal = (function (Node$$1) {
		function Literal () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) Literal.__proto__ = Node$$1;
		Literal.prototype = Object.create( Node$$1 && Node$$1.prototype );
		Literal.prototype.constructor = Literal;
	
		Literal.prototype.initialise = function initialise () {
			if (typeof this.value === 'string') {
				this.program.indentExclusionElements.push(this);
			}
		};
	
		Literal.prototype.transpile = function transpile (code, transforms) {
			if (transforms.numericLiteral) {
				var leading = this.raw.slice(0, 2);
				if (leading === '0b' || leading === '0o') {
					code.overwrite(this.start, this.end, String(this.value), {
						storeName: true,
						contentOnly: true
					});
				}
			}
	
			if (this.regex) {
				var ref = this.regex;
				var pattern = ref.pattern;
				var flags = ref.flags;
	
				if (transforms.stickyRegExp && /y/.test(flags))
					{ throw new CompileError(
						'Regular expression sticky flag is not supported',
						this
					); }
				if (transforms.unicodeRegExp && /u/.test(flags)) {
					code.overwrite(
						this.start,
						this.end,
						("/" + (rewritePattern_1(pattern, flags)) + "/" + (flags.replace('u', ''))),
						{
							contentOnly: true
						}
					);
				}
			}
		};
	
		return Literal;
	}(Node));
	
	var MemberExpression = (function (Node$$1) {
		function MemberExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) MemberExpression.__proto__ = Node$$1;
		MemberExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		MemberExpression.prototype.constructor = MemberExpression;
	
		MemberExpression.prototype.transpile = function transpile (code, transforms) {
			if (transforms.reservedProperties && reserved[this.property.name]) {
				code.overwrite(this.object.end, this.property.start, "['");
				code.appendLeft(this.property.end, "']");
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return MemberExpression;
	}(Node));
	
	var NewExpression = (function (Node$$1) {
		function NewExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) NewExpression.__proto__ = Node$$1;
		NewExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		NewExpression.prototype.constructor = NewExpression;
	
		NewExpression.prototype.initialise = function initialise (transforms) {
			var this$1 = this;
	
			if (transforms.spreadRest && this.arguments.length) {
				var lexicalBoundary = this.findLexicalBoundary();
	
				var i = this.arguments.length;
				while (i--) {
					var arg = this$1.arguments[i];
					if (arg.type === 'SpreadElement' && isArguments(arg.argument)) {
						this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();
						break;
					}
				}
			}
	
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		NewExpression.prototype.transpile = function transpile (code, transforms) {
			Node$$1.prototype.transpile.call(this, code, transforms);
	
			if (transforms.spreadRest && this.arguments.length) {
				var firstArgument = this.arguments[0];
				var isNew = true;
				var hasSpreadElements = spread(
					code,
					this.arguments,
					firstArgument.start,
					this.argumentsArrayAlias,
					isNew
				);
	
				if (hasSpreadElements) {
					code.prependRight(
						this.start + 'new'.length,
						' (Function.prototype.bind.apply('
					);
					code.overwrite(
						this.callee.end,
						firstArgument.start,
						', [ null ].concat( '
					);
					code.appendLeft(this.end, ' ))');
				}
			}
	
			if (this.arguments.length) {
				removeTrailingComma(code, this.arguments[this.arguments.length - 1].end);
			}
		};
	
		return NewExpression;
	}(Node));
	
	var ObjectExpression = (function (Node$$1) {
		function ObjectExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ObjectExpression.__proto__ = Node$$1;
		ObjectExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ObjectExpression.prototype.constructor = ObjectExpression;
	
		ObjectExpression.prototype.transpile = function transpile (code, transforms) {
			var this$1 = this;
	
			Node$$1.prototype.transpile.call(this, code, transforms);
	
			var firstPropertyStart = this.start + 1;
			var regularPropertyCount = 0;
			var spreadPropertyCount = 0;
			var computedPropertyCount = 0;
			var firstSpreadProperty = null;
			var firstComputedProperty = null;
	
			for (var i = 0; i < this.properties.length; ++i) {
				var prop = this$1.properties[i];
				if (prop.type === 'SpreadElement') {
					spreadPropertyCount += 1;
					if (firstSpreadProperty === null) { firstSpreadProperty = i; }
				} else if (prop.computed) {
					computedPropertyCount += 1;
					if (firstComputedProperty === null) { firstComputedProperty = i; }
				} else if (prop.type === 'Property') {
					regularPropertyCount += 1;
				}
			}
	
			if (spreadPropertyCount) {
				if (!this.program.options.objectAssign) {
					throw new CompileError(
						"Object spread operator requires specified objectAssign option with 'Object.assign' or polyfill helper.",
						this
					);
				}
				// enclose run of non-spread properties in curlies
				var i$1 = this.properties.length;
				if (regularPropertyCount && !computedPropertyCount) {
					while (i$1--) {
						var prop$1 = this$1.properties[i$1];
	
						if (prop$1.type === 'Property' && !prop$1.computed) {
							var lastProp = this$1.properties[i$1 - 1];
							var nextProp = this$1.properties[i$1 + 1];
	
							if (
								!lastProp ||
								lastProp.type !== 'Property' ||
								lastProp.computed
							) {
								code.prependRight(prop$1.start, '{');
							}
	
							if (
								!nextProp ||
								nextProp.type !== 'Property' ||
								nextProp.computed
							) {
								code.appendLeft(prop$1.end, '}');
							}
						}
					}
				}
	
				// wrap the whole thing in Object.assign
				firstPropertyStart = this.properties[0].start;
				if (!computedPropertyCount) {
					code.overwrite(
						this.start,
						firstPropertyStart,
						((this.program.options.objectAssign) + "({}, ")
					);
					code.overwrite(
						this.properties[this.properties.length - 1].end,
						this.end,
						')'
					);
				} else if (this.properties[0].type === 'SpreadElement') {
					code.overwrite(
						this.start,
						firstPropertyStart,
						((this.program.options.objectAssign) + "({}, ")
					);
					code.remove(this.end - 1, this.end);
					code.appendRight(this.end, ')');
				} else {
					code.prependLeft(this.start, ((this.program.options.objectAssign) + "("));
					code.appendRight(this.end, ')');
				}
			}
	
			if (computedPropertyCount && transforms.computedProperty) {
				var i0 = this.getIndentation();
	
				var isSimpleAssignment;
				var name;
	
				if (
					this.parent.type === 'VariableDeclarator' &&
					this.parent.parent.declarations.length === 1 &&
					this.parent.id.type === 'Identifier'
				) {
					isSimpleAssignment = true;
					name = this.parent.id.alias || this.parent.id.name; // TODO is this right?
				} else if (
					this.parent.type === 'AssignmentExpression' &&
					this.parent.parent.type === 'ExpressionStatement' &&
					this.parent.left.type === 'Identifier'
				) {
					isSimpleAssignment = true;
					name = this.parent.left.alias || this.parent.left.name; // TODO is this right?
				} else if (
					this.parent.type === 'AssignmentPattern' &&
					this.parent.left.type === 'Identifier'
				) {
					isSimpleAssignment = true;
					name = this.parent.left.alias || this.parent.left.name; // TODO is this right?
				}
	
				if (spreadPropertyCount) { isSimpleAssignment = false; }
	
				// handle block scoping
				name = this.findScope(false).resolveName(name);
	
				var start = firstPropertyStart;
				var end = this.end;
	
				if (isSimpleAssignment) {
					// ???
				} else {
					if (
						firstSpreadProperty === null ||
						firstComputedProperty < firstSpreadProperty
					) {
						name = this.findScope(true).createDeclaration('obj');
	
						code.prependRight(this.start, ("( " + name + " = "));
					} else { name = null; } // We don't actually need this variable
				}
	
				var len = this.properties.length;
				var lastComputedProp;
				var sawNonComputedProperty = false;
				var isFirst = true;
	
				for (var i$2 = 0; i$2 < len; i$2 += 1) {
					var prop$2 = this$1.properties[i$2];
					var moveStart = i$2 > 0 ? this$1.properties[i$2 - 1].end : start;
	
					if (
						prop$2.type === 'Property' &&
						(prop$2.computed || (lastComputedProp && !spreadPropertyCount))
					) {
						if (i$2 === 0) { moveStart = this$1.start + 1; } // Trim leading whitespace
						lastComputedProp = prop$2;
	
						if (!name) {
							name = this$1.findScope(true).createDeclaration('obj');
	
							var propId = name + (prop$2.computed ? '' : '.');
							code.appendRight(prop$2.start, ("( " + name + " = {}, " + propId));
						} else {
							var propId$1 =
								(isSimpleAssignment ? (";\n" + i0 + name) : (", " + name)) +
								(prop$2.key.type === 'Literal' || prop$2.computed ? '' : '.');
	
							if (moveStart < prop$2.start) {
								code.overwrite(moveStart, prop$2.start, propId$1);
							} else {
								code.prependRight(prop$2.start, propId$1);
							}
						}
	
						var c = prop$2.key.end;
						if (prop$2.computed) {
							while (code.original[c] !== ']') { c += 1; }
							c += 1;
						}
						if (prop$2.key.type === 'Literal' && !prop$2.computed) {
							code.overwrite(
								prop$2.start,
								prop$2.key.end + 1,
								'[' + code.slice(prop$2.start, prop$2.key.end) + '] = '
							);
						} else if (prop$2.shorthand || (prop$2.method && !prop$2.computed && transforms.conciseMethodProperty)) {
							// Replace : with = if Property::transpile inserted the :
							code.overwrite(
								prop$2.key.start,
								prop$2.key.end,
								code.slice(prop$2.key.start, prop$2.key.end).replace(/:/, ' =')
							);
						} else {
							if (prop$2.value.start > c) { code.remove(c, prop$2.value.start); }
							code.prependLeft(c, ' = ');
						}
	
						// This duplicates behavior from Property::transpile which is disabled
						// for computed properties or if conciseMethodProperty is false
						if (prop$2.method && (prop$2.computed || !transforms.conciseMethodProperty)) {
							if (prop$2.value.generator) { code.remove(prop$2.start, prop$2.key.start); }
							code.prependRight(prop$2.value.start, ("function" + (prop$2.value.generator ? '*' : '') + " "));
						}
					} else if (prop$2.type === 'SpreadElement') {
						if (name && i$2 > 0) {
							if (!lastComputedProp) {
								lastComputedProp = this$1.properties[i$2 - 1];
							}
							code.appendLeft(lastComputedProp.end, (", " + name + " )"));
	
							lastComputedProp = null;
							name = null;
						}
					} else {
						if (!isFirst && spreadPropertyCount) {
							// We are in an Object.assign context, so we need to wrap regular properties
							code.prependRight(prop$2.start, '{');
							code.appendLeft(prop$2.end, '}');
						}
						sawNonComputedProperty = true;
					}
					if (isFirst && (prop$2.type === 'SpreadElement' || prop$2.computed)) {
						var beginEnd = sawNonComputedProperty
							? this$1.properties[this$1.properties.length - 1].end
							: this$1.end - 1;
						// Trim trailing comma because it can easily become a leading comma which is illegal
						if (code.original[beginEnd] == ',') { ++beginEnd; }
						var closing = code.slice(beginEnd, end);
						code.prependLeft(moveStart, closing);
						code.remove(beginEnd, end);
						isFirst = false;
					}
	
					// Clean up some extranous whitespace
					var c$1 = prop$2.end;
					if (i$2 < len - 1 && !sawNonComputedProperty) {
						while (code.original[c$1] !== ',') { c$1 += 1; }
					} else if (i$2 == len - 1) { c$1 = this$1.end; }
					code.remove(prop$2.end, c$1);
				}
	
				// special case
				if (computedPropertyCount === len) {
					code.remove(this.properties[len - 1].end, this.end - 1);
				}
	
				if (!isSimpleAssignment && name) {
					code.appendLeft(lastComputedProp.end, (", " + name + " )"));
				}
			}
		};
	
		return ObjectExpression;
	}(Node));
	
	var Property = (function (Node$$1) {
		function Property () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) Property.__proto__ = Node$$1;
		Property.prototype = Object.create( Node$$1 && Node$$1.prototype );
		Property.prototype.constructor = Property;
	
		Property.prototype.transpile = function transpile (code, transforms) {
			Node$$1.prototype.transpile.call(this, code, transforms);
	
			if (
				transforms.conciseMethodProperty &&
				!this.computed &&
				this.parent.type !== 'ObjectPattern'
			) {
				if (this.shorthand) {
					code.prependRight(this.start, ((this.key.name) + ": "));
				} else if (this.method) {
					var name = '';
					if (this.program.options.namedFunctionExpressions !== false) {
						if (
							this.key.type === 'Literal' &&
							typeof this.key.value === 'number'
						) {
							name = '';
						} else if (this.key.type === 'Identifier') {
							if (
								reserved[this.key.name] ||
								!/^[a-z_$][a-z0-9_$]*$/i.test(this.key.name) ||
								this.value.body.scope.references[this.key.name]
							) {
								name = this.findScope(true).createIdentifier(this.key.name);
							} else {
								name = this.key.name;
							}
						} else {
							name = this.findScope(true).createIdentifier(this.key.value);
						}
						name = ' ' + name;
					}
	
					if (this.value.generator) { code.remove(this.start, this.key.start); }
					code.appendLeft(
						this.key.end,
						(": function" + (this.value.generator ? '*' : '') + name)
					);
				}
			}
	
			if (transforms.reservedProperties && reserved[this.key.name]) {
				code.prependRight(this.key.start, "'");
				code.appendLeft(this.key.end, "'");
			}
		};
	
		return Property;
	}(Node));
	
	var ReturnStatement = (function (Node$$1) {
		function ReturnStatement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ReturnStatement.__proto__ = Node$$1;
		ReturnStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ReturnStatement.prototype.constructor = ReturnStatement;
	
		ReturnStatement.prototype.initialise = function initialise (transforms) {
			this.loop = this.findNearest(loopStatement);
			this.nearestFunction = this.findNearest(/Function/);
	
			if (
				this.loop &&
				(!this.nearestFunction || this.loop.depth > this.nearestFunction.depth)
			) {
				this.loop.canReturn = true;
				this.shouldWrap = true;
			}
	
			if (this.argument) { this.argument.initialise(transforms); }
		};
	
		ReturnStatement.prototype.transpile = function transpile (code, transforms) {
			var shouldWrap =
				this.shouldWrap && this.loop && this.loop.shouldRewriteAsFunction;
	
			if (this.argument) {
				if (shouldWrap) { code.prependRight(this.argument.start, "{ v: "); }
				this.argument.transpile(code, transforms);
				if (shouldWrap) { code.appendLeft(this.argument.end, " }"); }
			} else if (shouldWrap) {
				code.appendLeft(this.start + 6, ' {}');
			}
		};
	
		return ReturnStatement;
	}(Node));
	
	var SpreadElement = (function (Node$$1) {
		function SpreadElement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) SpreadElement.__proto__ = Node$$1;
		SpreadElement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		SpreadElement.prototype.constructor = SpreadElement;
	
		SpreadElement.prototype.transpile = function transpile (code, transforms) {
			if (this.parent.type == 'ObjectExpression') {
				code.remove(this.start, this.argument.start);
				code.remove(this.argument.end, this.end);
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return SpreadElement;
	}(Node));
	
	var Super = (function (Node$$1) {
		function Super () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) Super.__proto__ = Node$$1;
		Super.prototype = Object.create( Node$$1 && Node$$1.prototype );
		Super.prototype.constructor = Super;
	
		Super.prototype.initialise = function initialise (transforms) {
			if (transforms.classes) {
				this.method = this.findNearest('MethodDefinition');
				if (!this.method)
					{ throw new CompileError('use of super outside class method', this); }
	
				var parentClass = this.findNearest('ClassBody').parent;
				this.superClassName =
					parentClass.superClass && (parentClass.superClass.name || 'superclass');
	
				if (!this.superClassName)
					{ throw new CompileError('super used in base class', this); }
	
				this.isCalled =
					this.parent.type === 'CallExpression' && this === this.parent.callee;
	
				if (this.method.kind !== 'constructor' && this.isCalled) {
					throw new CompileError(
						'super() not allowed outside class constructor',
						this
					);
				}
	
				this.isMember = this.parent.type === 'MemberExpression';
	
				if (!this.isCalled && !this.isMember) {
					throw new CompileError(
						'Unexpected use of `super` (expected `super(...)` or `super.*`)',
						this
					);
				}
			}
	
			if (transforms.arrow) {
				var lexicalBoundary = this.findLexicalBoundary();
				var arrowFunction = this.findNearest('ArrowFunctionExpression');
				var loop = this.findNearest(loopStatement);
	
				if (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {
					this.thisAlias = lexicalBoundary.getThisAlias();
				}
	
				if (
					loop &&
					loop.body.contains(this) &&
					loop.depth > lexicalBoundary.depth
				) {
					this.thisAlias = lexicalBoundary.getThisAlias();
				}
			}
		};
	
		Super.prototype.transpile = function transpile (code, transforms) {
			if (transforms.classes) {
				var expression =
					this.isCalled || this.method.static
						? this.superClassName
						: ((this.superClassName) + ".prototype");
	
				code.overwrite(this.start, this.end, expression, {
					storeName: true,
					contentOnly: true
				});
	
				var callExpression = this.isCalled ? this.parent : this.parent.parent;
	
				if (callExpression && callExpression.type === 'CallExpression') {
					if (!this.noCall) {
						// special case  `super( ...args )`
						code.appendLeft(callExpression.callee.end, '.call');
					}
	
					var thisAlias = this.thisAlias || 'this';
	
					if (callExpression.arguments.length) {
						code.appendLeft(callExpression.arguments[0].start, (thisAlias + ", "));
					} else {
						code.appendLeft(callExpression.end - 1, ("" + thisAlias));
					}
				}
			}
		};
	
		return Super;
	}(Node));
	
	var TaggedTemplateExpression = (function (Node$$1) {
		function TaggedTemplateExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) TaggedTemplateExpression.__proto__ = Node$$1;
		TaggedTemplateExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		TaggedTemplateExpression.prototype.constructor = TaggedTemplateExpression;
	
		TaggedTemplateExpression.prototype.initialise = function initialise (transforms) {
			if (
				transforms.templateString &&
				!transforms.dangerousTaggedTemplateString
			) {
				throw new CompileError(
					"Tagged template strings are not supported. Use `transforms: { templateString: false }` to skip transformation and disable this error, or `transforms: { dangerousTaggedTemplateString: true }` if you know what you're doing",
					this
				);
			}
	
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		TaggedTemplateExpression.prototype.transpile = function transpile (code, transforms) {
			if (transforms.templateString && transforms.dangerousTaggedTemplateString) {
				var ordered = this.quasi.expressions
					.concat(this.quasi.quasis)
					.sort(function (a, b) { return a.start - b.start; });
	
				var program = this.program;
				var rootScope = program.body.scope;
	
				// insert strings at start
				var templateStrings = this.quasi.quasis.map(function (quasi) { return JSON.stringify(quasi.value.cooked); }
				).join(', ');
	
				var templateObject = this.program.templateLiteralQuasis[templateStrings];
				if (!templateObject) {
					templateObject = rootScope.createIdentifier('templateObject');
					code.prependRight(this.program.prependAt, ("var " + templateObject + " = Object.freeze([" + templateStrings + "]);\n"));
	
					this.program.templateLiteralQuasis[templateStrings] = templateObject;
				}
	
				code.overwrite(
					this.tag.end,
					ordered[0].start,
					("(" + templateObject)
				);
	
				var lastIndex = ordered[0].start;
				ordered.forEach(function (node) {
					if (node.type === 'TemplateElement') {
						code.remove(lastIndex, node.end);
					} else {
						code.overwrite(lastIndex, node.start, ', ');
					}
	
					lastIndex = node.end;
				});
	
				code.overwrite(lastIndex, this.end, ')');
			}
	
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return TaggedTemplateExpression;
	}(Node));
	
	var TemplateElement = (function (Node$$1) {
		function TemplateElement () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) TemplateElement.__proto__ = Node$$1;
		TemplateElement.prototype = Object.create( Node$$1 && Node$$1.prototype );
		TemplateElement.prototype.constructor = TemplateElement;
	
		TemplateElement.prototype.initialise = function initialise () {
			this.program.indentExclusionElements.push(this);
		};
	
		return TemplateElement;
	}(Node));
	
	var TemplateLiteral = (function (Node$$1) {
		function TemplateLiteral () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) TemplateLiteral.__proto__ = Node$$1;
		TemplateLiteral.prototype = Object.create( Node$$1 && Node$$1.prototype );
		TemplateLiteral.prototype.constructor = TemplateLiteral;
	
		TemplateLiteral.prototype.transpile = function transpile (code, transforms) {
			Node$$1.prototype.transpile.call(this, code, transforms);
	
			if (
				transforms.templateString &&
				this.parent.type !== 'TaggedTemplateExpression'
			) {
				var ordered = this.expressions
					.concat(this.quasis)
					.sort(function (a, b) { return a.start - b.start || a.end - b.end; })
					.filter(function (node, i) {
						// include all expressions
						if (node.type !== 'TemplateElement') { return true; }
	
						// include all non-empty strings
						if (node.value.raw) { return true; }
	
						// exclude all empty strings not at the head
						return !i;
					});
	
				// special case  we may be able to skip the first element,
				// if it's the empty string, but only if the second and
				// third elements aren't both expressions (since they maybe
				// be numeric, and `1 + 2 + '3' === '33'`)
				if (ordered.length >= 3) {
					var first = ordered[0];
					var third = ordered[2];
					if (
						first.type === 'TemplateElement' &&
						first.value.raw === '' &&
						third.type === 'TemplateElement'
					) {
						ordered.shift();
					}
				}
	
				var parenthesise =
					(this.quasis.length !== 1 || this.expressions.length !== 0) &&
					this.parent.type !== 'TemplateLiteral' &&
					this.parent.type !== 'AssignmentExpression' &&
					this.parent.type !== 'AssignmentPattern' &&
					this.parent.type !== 'VariableDeclarator' &&
					(this.parent.type !== 'BinaryExpression' ||
						this.parent.operator !== '+');
	
				if (parenthesise) { code.appendRight(this.start, '('); }
	
				var lastIndex = this.start;
	
				ordered.forEach(function (node, i) {
					var prefix = i === 0 ? (parenthesise ? '(' : '') : ' + ';
	
					if (node.type === 'TemplateElement') {
						code.overwrite(
							lastIndex,
							node.end,
							prefix + JSON.stringify(node.value.cooked)
						);
					} else {
						var parenthesise$1 = node.type !== 'Identifier'; // TODO other cases where it's safe
	
						if (parenthesise$1) { prefix += '('; }
	
						code.remove(lastIndex, node.start);
	
						if (prefix) { code.prependRight(node.start, prefix); }
						if (parenthesise$1) { code.appendLeft(node.end, ')'); }
					}
	
					lastIndex = node.end;
				});
	
				if (parenthesise) { code.appendLeft(lastIndex, ')'); }
				code.overwrite(lastIndex, this.end, "", { contentOnly: true } );
			}
		};
	
		return TemplateLiteral;
	}(Node));
	
	var ThisExpression = (function (Node$$1) {
		function ThisExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) ThisExpression.__proto__ = Node$$1;
		ThisExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		ThisExpression.prototype.constructor = ThisExpression;
	
		ThisExpression.prototype.initialise = function initialise (transforms) {
			if (transforms.arrow) {
				var lexicalBoundary = this.findLexicalBoundary();
				var arrowFunction = this.findNearest('ArrowFunctionExpression');
				var loop = this.findNearest(loopStatement);
	
				if (
					(arrowFunction && arrowFunction.depth > lexicalBoundary.depth) ||
					(loop &&
						loop.body.contains(this) &&
						loop.depth > lexicalBoundary.depth) ||
					(loop && loop.right && loop.right.contains(this))
				) {
					this.alias = lexicalBoundary.getThisAlias();
				}
			}
		};
	
		ThisExpression.prototype.transpile = function transpile (code) {
			if (this.alias) {
				code.overwrite(this.start, this.end, this.alias, {
					storeName: true,
					contentOnly: true
				});
			}
		};
	
		return ThisExpression;
	}(Node));
	
	var UpdateExpression = (function (Node$$1) {
		function UpdateExpression () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) UpdateExpression.__proto__ = Node$$1;
		UpdateExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
		UpdateExpression.prototype.constructor = UpdateExpression;
	
		UpdateExpression.prototype.initialise = function initialise (transforms) {
			if (this.argument.type === 'Identifier') {
				var declaration = this.findScope(false).findDeclaration(
					this.argument.name
				);
				// special case  https://gitlab.com/Rich-Harris/buble/issues/150
				var statement = declaration && declaration.node.ancestor(3);
				if (
					statement &&
					statement.type === 'ForStatement' &&
					statement.body.contains(this)
				) {
					statement.reassigned[this.argument.name] = true;
				}
			}
	
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		UpdateExpression.prototype.transpile = function transpile (code, transforms) {
			if (this.argument.type === 'Identifier') {
				// Do this check after everything has been initialized to find
				// shadowing declarations after this expression
				checkConst(this.argument, this.findScope(false));
			}
			Node$$1.prototype.transpile.call(this, code, transforms);
		};
	
		return UpdateExpression;
	}(Node));
	
	var VariableDeclaration = (function (Node$$1) {
		function VariableDeclaration () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) VariableDeclaration.__proto__ = Node$$1;
		VariableDeclaration.prototype = Object.create( Node$$1 && Node$$1.prototype );
		VariableDeclaration.prototype.constructor = VariableDeclaration;
	
		VariableDeclaration.prototype.initialise = function initialise (transforms) {
			this.scope = this.findScope(this.kind === 'var');
			this.declarations.forEach(function (declarator) { return declarator.initialise(transforms); });
		};
	
		VariableDeclaration.prototype.transpile = function transpile (code, transforms) {
			var this$1 = this;
	
			var i0 = this.getIndentation();
			var kind = this.kind;
	
			if (transforms.letConst && kind !== 'var') {
				kind = 'var';
				code.overwrite(this.start, this.start + this.kind.length, kind, {
					storeName: true
				});
			}
	
			if (transforms.destructuring && this.parent.type !== 'ForOfStatement' && this.parent.type !== 'ForInStatement') {
				var c = this.start;
				var lastDeclaratorIsPattern;
	
				this.declarations.forEach(function (declarator, i) {
					declarator.transpile(code, transforms);
	
					if (declarator.id.type === 'Identifier') {
						if (i > 0 && this$1.declarations[i - 1].id.type !== 'Identifier') {
							code.overwrite(c, declarator.id.start, "var ");
						}
					} else {
						var inline = loopStatement.test(this$1.parent.type);
	
						if (i === 0) {
							code.remove(c, declarator.id.start);
						} else {
							code.overwrite(c, declarator.id.start, (";\n" + i0));
						}
	
						var simple =
							declarator.init.type === 'Identifier' && !declarator.init.rewritten;
	
						var name = simple
							? (declarator.init.alias || declarator.init.name)
							: declarator.findScope(true).createIdentifier('ref');
	
						c = declarator.start;
	
						var statementGenerators = [];
	
						if (simple) {
							code.remove(declarator.id.end, declarator.end);
						} else {
							statementGenerators.push(function (start, prefix, suffix) {
								code.prependRight(declarator.id.end, ("var " + name));
								code.appendLeft(declarator.init.end, ("" + suffix));
								code.move(declarator.id.end, declarator.end, start);
							});
						}
	
						var scope = declarator.findScope(false);
						destructure(
							code,
							function (id) { return scope.createIdentifier(id); },
							function (ref) {
								var name = ref.name;
	
								return scope.resolveName(name);
						},
							declarator.id,
							name,
							inline,
							statementGenerators
						);
	
						var prefix = inline ? 'var ' : '';
						var suffix = inline ? ", " : (";\n" + i0);
						statementGenerators.forEach(function (fn, j) {
							if (
								i === this$1.declarations.length - 1 &&
								j === statementGenerators.length - 1
							) {
								suffix = inline ? '' : ';';
							}
	
							fn(declarator.start, j === 0 ? prefix : '', suffix);
						});
					}
	
					c = declarator.end;
					lastDeclaratorIsPattern = declarator.id.type !== 'Identifier';
				});
	
				if (lastDeclaratorIsPattern && this.end > c) {
					code.overwrite(c, this.end, '', { contentOnly: true });
				}
			} else {
				this.declarations.forEach(function (declarator) {
					declarator.transpile(code, transforms);
				});
			}
		};
	
		return VariableDeclaration;
	}(Node));
	
	var VariableDeclarator = (function (Node$$1) {
		function VariableDeclarator () {
			Node$$1.apply(this, arguments);
		}
	
		if ( Node$$1 ) VariableDeclarator.__proto__ = Node$$1;
		VariableDeclarator.prototype = Object.create( Node$$1 && Node$$1.prototype );
		VariableDeclarator.prototype.constructor = VariableDeclarator;
	
		VariableDeclarator.prototype.initialise = function initialise (transforms) {
			var kind = this.parent.kind;
			if (kind === 'let' && this.parent.parent.type === 'ForStatement') {
				kind = 'for.let'; // special case...
			}
	
			this.parent.scope.addDeclaration(this.id, kind);
			Node$$1.prototype.initialise.call(this, transforms);
		};
	
		VariableDeclarator.prototype.transpile = function transpile (code, transforms) {
			if (!this.init && transforms.letConst && this.parent.kind !== 'var') {
				var inLoop = this.findNearest(
					/Function|^For(In|Of)?Statement|^(?:Do)?WhileStatement/
				);
				if (
					inLoop &&
					!/Function/.test(inLoop.type) &&
					!this.isLeftDeclaratorOfLoop()
				) {
					code.appendLeft(this.id.end, ' = (void 0)');
				}
			}
	
			if (this.id) { this.id.transpile(code, transforms); }
			if (this.init) { this.init.transpile(code, transforms); }
		};
	
		VariableDeclarator.prototype.isLeftDeclaratorOfLoop = function isLeftDeclaratorOfLoop () {
			return (
				this.parent &&
				this.parent.type === 'VariableDeclaration' &&
				this.parent.parent &&
				(this.parent.parent.type === 'ForInStatement' ||
					this.parent.parent.type === 'ForOfStatement') &&
				this.parent.parent.left &&
				this.parent.parent.left.declarations[0] === this
			);
		};
	
		return VariableDeclarator;
	}(Node));
	
	var types = {
		ArrayExpression: ArrayExpression,
		ArrowFunctionExpression: ArrowFunctionExpression,
		AssignmentExpression: AssignmentExpression,
		BinaryExpression: BinaryExpression,
		BreakStatement: BreakStatement,
		CallExpression: CallExpression,
		ClassBody: ClassBody,
		ClassDeclaration: ClassDeclaration,
		ClassExpression: ClassExpression,
		ContinueStatement: ContinueStatement,
		DoWhileStatement: LoopStatement,
		ExportNamedDeclaration: ExportNamedDeclaration,
		ExportDefaultDeclaration: ExportDefaultDeclaration,
		ForStatement: ForStatement,
		ForInStatement: ForInStatement,
		ForOfStatement: ForOfStatement,
		FunctionDeclaration: FunctionDeclaration,
		FunctionExpression: FunctionExpression,
		Identifier: Identifier,
		IfStatement: IfStatement,
		ImportDeclaration: ImportDeclaration,
		ImportDefaultSpecifier: ImportDefaultSpecifier,
		ImportSpecifier: ImportSpecifier,
		JSXAttribute: JSXAttribute,
		JSXClosingElement: JSXClosingElement,
		JSXClosingFragment: JSXClosingFragment,
		JSXElement: JSXElement,
		JSXExpressionContainer: JSXExpressionContainer,
		JSXFragment: JSXFragment,
		JSXOpeningElement: JSXOpeningElement,
		JSXOpeningFragment: JSXOpeningFragment,
		JSXSpreadAttribute: JSXSpreadAttribute,
		Literal: Literal,
		MemberExpression: MemberExpression,
		NewExpression: NewExpression,
		ObjectExpression: ObjectExpression,
		Property: Property,
		ReturnStatement: ReturnStatement,
		SpreadElement: SpreadElement,
		Super: Super,
		TaggedTemplateExpression: TaggedTemplateExpression,
		TemplateElement: TemplateElement,
		TemplateLiteral: TemplateLiteral,
		ThisExpression: ThisExpression,
		UpdateExpression: UpdateExpression,
		VariableDeclaration: VariableDeclaration,
		VariableDeclarator: VariableDeclarator,
		WhileStatement: LoopStatement
	};
	
	var keys = {
		Program: ['body'],
		Literal: []
	};
	
	var statementsWithBlocks = {
		IfStatement: 'consequent',
		ForStatement: 'body',
		ForInStatement: 'body',
		ForOfStatement: 'body',
		WhileStatement: 'body',
		DoWhileStatement: 'body',
		ArrowFunctionExpression: 'body'
	};
	
	function wrap(raw, parent) {
		if (!raw) { return; }
	
		if ('length' in raw) {
			var i = raw.length;
			while (i--) { wrap(raw[i], parent); }
			return;
		}
	
		// with e.g. shorthand properties, key and value are
		// the same node. We don't want to wrap an object twice
		if (raw.__wrapped) { return; }
		raw.__wrapped = true;
	
		if (!keys[raw.type]) {
			keys[raw.type] = Object.keys(raw).filter(
				function (key) { return typeof raw[key] === 'object'; }
			);
		}
	
		// special case  body-less if/for/while statements. TODO others?
		var bodyType = statementsWithBlocks[raw.type];
		if (bodyType && raw[bodyType].type !== 'BlockStatement') {
			var expression = raw[bodyType];
	
			// create a synthetic block statement, otherwise all hell
			// breaks loose when it comes to block scoping
			raw[bodyType] = {
				start: expression.start,
				end: expression.end,
				type: 'BlockStatement',
				body: [expression],
				synthetic: true
			};
		}
	
		raw.parent = parent;
		raw.program = parent.program || parent;
		raw.depth = parent.depth + 1;
		raw.keys = keys[raw.type];
		raw.indentation = undefined;
	
		for (var i$1 = 0, list = keys[raw.type]; i$1 < list.length; i$1 += 1) {
			var key = list[i$1];
	
			wrap(raw[key], raw);
		}
	
		raw.program.magicString.addSourcemapLocation(raw.start);
		raw.program.magicString.addSourcemapLocation(raw.end);
	
		var type =
			(raw.type === 'BlockStatement' ? BlockStatement : types[raw.type]) || Node;
		raw.__proto__ = type.prototype;
	}
	
	function Program(source, ast, transforms, options) {
		var this$1 = this;
	
		this.type = 'Root';
	
		// options
		this.jsx = options.jsx || 'React.createElement';
		this.options = options;
	
		this.source = source;
		this.magicString = new MagicString(source);
	
		this.ast = ast;
		this.depth = 0;
	
		wrap((this.body = ast), this);
		this.body.__proto__ = BlockStatement.prototype;
	
		this.templateLiteralQuasis = Object.create(null);
		for (var i = 0; i < this.body.body.length; ++i) {
			if (!this$1.body.body[i].directive) {
				this$1.prependAt = this$1.body.body[i].start;
				break;
			}
		}
		this.objectWithoutPropertiesHelper = null;
	
		this.indentExclusionElements = [];
		this.body.initialise(transforms);
	
		this.indentExclusions = Object.create(null);
		for (var i$2 = 0, list = this$1.indentExclusionElements; i$2 < list.length; i$2 += 1) {
			var node = list[i$2];
	
			for (var i$1 = node.start; i$1 < node.end; i$1 += 1) {
				this$1.indentExclusions[i$1] = true;
			}
		}
	
		this.body.transpile(this.magicString, transforms);
	}
	
	Program.prototype = {
		export: function export$1(options) {
			if ( options === void 0 ) options = {};
	
			return {
				code: this.magicString.toString(),
				map: this.magicString.generateMap({
					file: options.file,
					source: options.source,
					includeContent: options.includeContent !== false
				})
			};
		},
	
		findNearest: function findNearest() {
			return null;
		},
	
		findScope: function findScope() {
			return null;
		},
	
		getObjectWithoutPropertiesHelper: function getObjectWithoutPropertiesHelper(code) {
			if (!this.objectWithoutPropertiesHelper) {
				this.objectWithoutPropertiesHelper = this.body.scope.createIdentifier('objectWithoutProperties');
				code.prependLeft(this.prependAt, "function " + (this.objectWithoutPropertiesHelper) + " (obj, exclude) { " +
					"var target = {}; for (var k in obj) " +
					"if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) " +
					"target[k] = obj[k]; return target; }\n"
				);
			}
			return this.objectWithoutPropertiesHelper;
		}
	};
	
	var matrix = {
		chrome: {
			    48: 305357,
			    49: 326143,
			    50: 391679,
			    51: 391679,
			    52: 522751,
			    53: 522751,
			    54: 522751,
			    55: 522751,
			    56: 522751,
			    57: 522751,
			    58: 1047039,
			    59: 1047039,
			    60: 1047039,
			    61: 1047039,
			    62: 1047039,
			    63: 1047039
		},
		firefox: {
			    43: 325853,
			    44: 326109,
			    45: 326111,
			    46: 391647,
			    47: 391679,
			    48: 391679,
			    49: 387583,
			    50: 387583,
			    51: 387583,
			    52: 1047039,
			    53: 1047039,
			    54: 1047039,
			    55: 1047039,
			    56: 1047039,
			    57: 1047039,
			    58: 1047039
		},
		safari: {
			     8: 262148,
			     9: 301166,
			    10: 915967,
			'10.1': 1047039,
			    11: 1047039
		},
		ie: {
			     8: 0,
			     9: 262144,
			    10: 262144,
			    11: 262400
		},
		edge: {
			    12: 305485,
			    13: 387535,
			    14: 1042943,
			    15: 1042943,
			    16: 1042943
		},
		node: {
			'0.10': 262144,
			'0.12': 262208,
			     4: 297167,
			     5: 297167,
			     6: 391679,
			     8: 1047039,
			 '8.3': 1047039,
			 '8.7': 1047039
		}
	};
	
	var features = [
		'arrow',
		'classes',
		'computedProperty',
		'conciseMethodProperty',
		'defaultParameter',
		'destructuring',
		'forOf',
		'generator',
		'letConst',
		'moduleExport',
		'moduleImport',
		'numericLiteral',
		'parameterDestructuring',
		'spreadRest',
		'stickyRegExp',
		'templateString',
		'unicodeRegExp',
	
		// ES2016
		'exponentiation',
	
		// additional transforms, not from
		// https://featuretests.io
		'reservedProperties',
	
		'trailingFunctionCommas'
	];
	
	var version = "0.19.3";
	
	var ref = [inject, acornDynamicImport].reduce(
		function (final, plugin) { return plugin(final); },
		acorn
	);
	var parse = ref.parse;
	
	var dangerousTransforms = ['dangerousTaggedTemplateString', 'dangerousForOf'];
	
	function target(target) {
		var targets = Object.keys(target);
		var bitmask = targets.length
			? 1048575
			: 262144;
	
		Object.keys(target).forEach(function (environment) {
			var versions = matrix[environment];
			if (!versions)
				{ throw new Error(
					("Unknown environment '" + environment + "'. Please raise an issue at https://github.com/Rich-Harris/buble/issues")
				); }
	
			var targetVersion = target[environment];
			if (!(targetVersion in versions))
				{ throw new Error(
					("Support data exists for the following versions of " + environment + ": " + (Object.keys(
						versions
					).join(
						', '
					)) + ". Please raise an issue at https://github.com/Rich-Harris/buble/issues")
				); }
			var support = versions[targetVersion];
	
			bitmask &= support;
		});
	
		var transforms = Object.create(null);
		features.forEach(function (name, i) {
			transforms[name] = !(bitmask & (1 << i));
		});
	
		dangerousTransforms.forEach(function (name) {
			transforms[name] = false;
		});
	
		return transforms;
	}
	
	function transform(source, options) {
		if ( options === void 0 ) options = {};
	
		var ast;
		var jsx = null;
	
		try {
			ast = parse(source, {
				ecmaVersion: 9,
				preserveParens: true,
				sourceType: 'module',
				onComment: function (block, text) {
					if (!jsx) {
						var match = /@jsx\s+([^\s]+)/.exec(text);
						if (match) { jsx = match[1]; }
					}
				},
				plugins: {
					jsx: true,
					dynamicImport: true
				}
			});
			options.jsx = jsx || options.jsx;
		} catch (err) {
			err.snippet = getSnippet(source, err.loc);
			err.toString = function () { return ((err.name) + ": " + (err.message) + "\n" + (err.snippet)); };
			throw err;
		}
	
		var transforms = target(options.target || {});
		Object.keys(options.transforms || {}).forEach(function (name) {
			if (name === 'modules') {
				if (!('moduleImport' in options.transforms))
					{ transforms.moduleImport = options.transforms.modules; }
				if (!('moduleExport' in options.transforms))
					{ transforms.moduleExport = options.transforms.modules; }
				return;
			}
	
			if (!(name in transforms)) { throw new Error(("Unknown transform '" + name + "'")); }
			transforms[name] = options.transforms[name];
		});
	
		return new Program(source, ast, transforms, options).export(options);
	}
	
	exports.target = target;
	exports.transform = transform;
	exports.VERSION = version;
	//# sourceMappingURL=buble-browser.cjs.js.map
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 15 */
/*!********************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/magic-string/0.22.5/~/magic-string/dist/magic-string.cjs.js ***!
  \********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {'use strict';
	
	var vlq = __webpack_require__(/*! vlq */ 21);
	
	function Chunk ( start, end, content ) {
		this.start = start;
		this.end = end;
		this.original = content;
	
		this.intro = '';
		this.outro = '';
	
		this.content = content;
		this.storeName = false;
		this.edited = false;
	
		// we make these non-enumerable, for sanity while debugging
		Object.defineProperties( this, {
			previous: { writable: true, value: null },
			next: { writable: true, value: null }
		});
	}
	
	Chunk.prototype = {
		appendLeft: function appendLeft ( content ) {
			this.outro += content;
		},
	
		appendRight: function appendRight ( content ) {
			this.intro = this.intro + content;
		},
	
		clone: function clone () {
			var chunk = new Chunk( this.start, this.end, this.original );
	
			chunk.intro = this.intro;
			chunk.outro = this.outro;
			chunk.content = this.content;
			chunk.storeName = this.storeName;
			chunk.edited = this.edited;
	
			return chunk;
		},
	
		contains: function contains ( index ) {
			return this.start < index && index < this.end;
		},
	
		eachNext: function eachNext ( fn ) {
			var chunk = this;
			while ( chunk ) {
				fn( chunk );
				chunk = chunk.next;
			}
		},
	
		eachPrevious: function eachPrevious ( fn ) {
			var chunk = this;
			while ( chunk ) {
				fn( chunk );
				chunk = chunk.previous;
			}
		},
	
		edit: function edit ( content, storeName, contentOnly ) {
			this.content = content;
			if ( !contentOnly ) {
				this.intro = '';
				this.outro = '';
			}
			this.storeName = storeName;
	
			this.edited = true;
	
			return this;
		},
	
		prependLeft: function prependLeft ( content ) {
			this.outro = content + this.outro;
		},
	
		prependRight: function prependRight ( content ) {
			this.intro = content + this.intro;
		},
	
		split: function split ( index ) {
			var sliceIndex = index - this.start;
	
			var originalBefore = this.original.slice( 0, sliceIndex );
			var originalAfter = this.original.slice( sliceIndex );
	
			this.original = originalBefore;
	
			var newChunk = new Chunk( index, this.end, originalAfter );
			newChunk.outro = this.outro;
			this.outro = '';
	
			this.end = index;
	
			if ( this.edited ) {
				// TODO is this block necessary?...
				newChunk.edit( '', false );
				this.content = '';
			} else {
				this.content = originalBefore;
			}
	
			newChunk.next = this.next;
			if ( newChunk.next ) { newChunk.next.previous = newChunk; }
			newChunk.previous = this;
			this.next = newChunk;
	
			return newChunk;
		},
	
		toString: function toString () {
			return this.intro + this.content + this.outro;
		},
	
		trimEnd: function trimEnd ( rx ) {
			this.outro = this.outro.replace( rx, '' );
			if ( this.outro.length ) { return true; }
	
			var trimmed = this.content.replace( rx, '' );
	
			if ( trimmed.length ) {
				if ( trimmed !== this.content ) {
					this.split( this.start + trimmed.length ).edit( '', false );
				}
	
				return true;
			} else {
				this.edit( '', false );
	
				this.intro = this.intro.replace( rx, '' );
				if ( this.intro.length ) { return true; }
			}
		},
	
		trimStart: function trimStart ( rx ) {
			this.intro = this.intro.replace( rx, '' );
			if ( this.intro.length ) { return true; }
	
			var trimmed = this.content.replace( rx, '' );
	
			if ( trimmed.length ) {
				if ( trimmed !== this.content ) {
					this.split( this.end - trimmed.length );
					this.edit( '', false );
				}
	
				return true;
			} else {
				this.edit( '', false );
	
				this.outro = this.outro.replace( rx, '' );
				if ( this.outro.length ) { return true; }
			}
		}
	};
	
	var _btoa;
	
	if ( typeof window !== 'undefined' && typeof window.btoa === 'function' ) {
		_btoa = window.btoa;
	} else if ( typeof Buffer === 'function' ) {
		_btoa = function (str) { return new Buffer( str ).toString( 'base64' ); };
	} else {
		_btoa = function () {
			throw new Error( 'Unsupported environment: `window.btoa` or `Buffer` should be supported.' );
		};
	}
	
	var btoa = _btoa;
	
	function SourceMap ( properties ) {
		this.version = 3;
	
		this.file           = properties.file;
		this.sources        = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names          = properties.names;
		this.mappings       = properties.mappings;
	}
	
	SourceMap.prototype = {
		toString: function toString () {
			return JSON.stringify( this );
		},
	
		toUrl: function toUrl () {
			return 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );
		}
	};
	
	function guessIndent ( code ) {
		var lines = code.split( '\n' );
	
		var tabbed = lines.filter( function (line) { return /^\t+/.test( line ); } );
		var spaced = lines.filter( function (line) { return /^ {2,}/.test( line ); } );
	
		if ( tabbed.length === 0 && spaced.length === 0 ) {
			return null;
		}
	
		// More lines tabbed than spaced? Assume tabs, and
		// default to tabs in the case of a tie (or nothing
		// to go on)
		if ( tabbed.length >= spaced.length ) {
			return '\t';
		}
	
		// Otherwise, we need to guess the multiple
		var min = spaced.reduce( function ( previous, current ) {
			var numSpaces = /^ +/.exec( current )[0].length;
			return Math.min( numSpaces, previous );
		}, Infinity );
	
		return new Array( min + 1 ).join( ' ' );
	}
	
	function getRelativePath ( from, to ) {
		var fromParts = from.split( /[\/\\]/ );
		var toParts = to.split( /[\/\\]/ );
	
		fromParts.pop(); // get dirname
	
		while ( fromParts[0] === toParts[0] ) {
			fromParts.shift();
			toParts.shift();
		}
	
		if ( fromParts.length ) {
			var i = fromParts.length;
			while ( i-- ) { fromParts[i] = '..'; }
		}
	
		return fromParts.concat( toParts ).join( '/' );
	}
	
	var toString = Object.prototype.toString;
	
	function isObject ( thing ) {
		return toString.call( thing ) === '[object Object]';
	}
	
	function getLocator ( source ) {
		var originalLines = source.split( '\n' );
	
		var start = 0;
		var lineRanges = originalLines.map( function ( line, i ) {
			var end = start + line.length + 1;
			var range = { start: start, end: end, line: i };
	
			start = end;
			return range;
		});
	
		var i = 0;
	
		function rangeContains ( range, index ) {
			return range.start <= index && index < range.end;
		}
	
		function getLocation ( range, index ) {
			return { line: range.line, column: index - range.start };
		}
	
		return function locate ( index ) {
			var range = lineRanges[i];
	
			var d = index >= range.end ? 1 : -1;
	
			while ( range ) {
				if ( rangeContains( range, index ) ) { return getLocation( range, index ); }
	
				i += d;
				range = lineRanges[i];
			}
		};
	}
	
	function Mappings ( hires ) {
		var this$1 = this;
	
		var offsets = {
			generatedCodeColumn: 0,
			sourceIndex: 0,
			sourceCodeLine: 0,
			sourceCodeColumn: 0,
			sourceCodeName: 0
		};
	
		var generatedCodeLine = 0;
		var generatedCodeColumn = 0;
	
		this.raw = [];
		var rawSegments = this.raw[ generatedCodeLine ] = [];
	
		var pending = null;
	
		this.addEdit = function ( sourceIndex, content, original, loc, nameIndex ) {
			if ( content.length ) {
				rawSegments.push([
					generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column,
					nameIndex ]);
			} else if ( pending ) {
				rawSegments.push( pending );
			}
	
			this$1.advance( content );
			pending = null;
		};
	
		this.addUneditedChunk = function ( sourceIndex, chunk, original, loc, sourcemapLocations ) {
			var originalCharIndex = chunk.start;
			var first = true;
	
			while ( originalCharIndex < chunk.end ) {
				if ( hires || first || sourcemapLocations[ originalCharIndex ] ) {
					rawSegments.push([
						generatedCodeColumn,
						sourceIndex,
						loc.line,
						loc.column,
						-1
					]);
				}
	
				if ( original[ originalCharIndex ] === '\n' ) {
					loc.line += 1;
					loc.column = 0;
					generatedCodeLine += 1;
					this$1.raw[ generatedCodeLine ] = rawSegments = [];
					generatedCodeColumn = 0;
				} else {
					loc.column += 1;
					generatedCodeColumn += 1;
				}
	
				originalCharIndex += 1;
				first = false;
			}
	
			pending = [
				generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column,
				-1 ];
		};
	
		this.advance = function (str) {
			if ( !str ) { return; }
	
			var lines = str.split( '\n' );
			var lastLine = lines.pop();
	
			if ( lines.length ) {
				generatedCodeLine += lines.length;
				this$1.raw[ generatedCodeLine ] = rawSegments = [];
				generatedCodeColumn = lastLine.length;
			} else {
				generatedCodeColumn += lastLine.length;
			}
		};
	
		this.encode = function () {
			return this$1.raw.map( function (segments) {
				var generatedCodeColumn = 0;
	
				return segments.map( function (segment) {
					var arr = [
						segment[0] - generatedCodeColumn,
						segment[1] - offsets.sourceIndex,
						segment[2] - offsets.sourceCodeLine,
						segment[3] - offsets.sourceCodeColumn
					];
	
					generatedCodeColumn = segment[0];
					offsets.sourceIndex = segment[1];
					offsets.sourceCodeLine = segment[2];
					offsets.sourceCodeColumn = segment[3];
	
					if ( ~segment[4] ) {
						arr.push( segment[4] - offsets.sourceCodeName );
						offsets.sourceCodeName = segment[4];
					}
	
					return vlq.encode( arr );
				}).join( ',' );
			}).join( ';' );
		};
	}
	
	var Stats = function Stats () {
		Object.defineProperties( this, {
			startTimes: { value: {} }
		});
	};
	
	Stats.prototype.time = function time ( label ) {
		this.startTimes[ label ] = process.hrtime();
	};
	
	Stats.prototype.timeEnd = function timeEnd ( label ) {
		var elapsed = process.hrtime( this.startTimes[ label ] );
	
		if ( !this[ label ] ) { this[ label ] = 0; }
		this[ label ] += elapsed[0] * 1e3 + elapsed[1] * 1e-6;
	};
	
	var warned = {
		insertLeft: false,
		insertRight: false,
		storeName: false
	};
	
	function MagicString$1 ( string, options ) {
		if ( options === void 0 ) options = {};
	
		var chunk = new Chunk( 0, string.length, string );
	
		Object.defineProperties( this, {
			original:              { writable: true, value: string },
			outro:                 { writable: true, value: '' },
			intro:                 { writable: true, value: '' },
			firstChunk:            { writable: true, value: chunk },
			lastChunk:             { writable: true, value: chunk },
			lastSearchedChunk:     { writable: true, value: chunk },
			byStart:               { writable: true, value: {} },
			byEnd:                 { writable: true, value: {} },
			filename:              { writable: true, value: options.filename },
			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
			sourcemapLocations:    { writable: true, value: {} },
			storedNames:           { writable: true, value: {} },
			indentStr:             { writable: true, value: guessIndent( string ) }
		});
	
		this.byStart[ 0 ] = chunk;
		this.byEnd[ string.length ] = chunk;
	}
	
	MagicString$1.prototype = {
		addSourcemapLocation: function addSourcemapLocation ( char ) {
			this.sourcemapLocations[ char ] = true;
		},
	
		append: function append ( content ) {
			if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }
	
			this.outro += content;
			return this;
		},
	
		appendLeft: function appendLeft ( index, content ) {
			if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }
	
			this._split( index );
	
			var chunk = this.byEnd[ index ];
	
			if ( chunk ) {
				chunk.appendLeft( content );
			} else {
				this.intro += content;
			}
	
			return this;
		},
	
		appendRight: function appendRight ( index, content ) {
			if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }
	
			this._split( index );
	
			var chunk = this.byStart[ index ];
	
			if ( chunk ) {
				chunk.appendRight( content );
			} else {
				this.outro += content;
			}
	
			return this;
		},
	
		clone: function clone () {
			var cloned = new MagicString$1( this.original, { filename: this.filename });
	
			var originalChunk = this.firstChunk;
			var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
	
			while ( originalChunk ) {
				cloned.byStart[ clonedChunk.start ] = clonedChunk;
				cloned.byEnd[ clonedChunk.end ] = clonedChunk;
	
				var nextOriginalChunk = originalChunk.next;
				var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
	
				if ( nextClonedChunk ) {
					clonedChunk.next = nextClonedChunk;
					nextClonedChunk.previous = clonedChunk;
	
					clonedChunk = nextClonedChunk;
				}
	
				originalChunk = nextOriginalChunk;
			}
	
			cloned.lastChunk = clonedChunk;
	
			if ( this.indentExclusionRanges ) {
				cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
			}
	
			Object.keys( this.sourcemapLocations ).forEach( function (loc) {
				cloned.sourcemapLocations[ loc ] = true;
			});
	
			return cloned;
		},
	
		generateMap: function generateMap ( options ) {
			var this$1 = this;
	
			options = options || {};
	
			var sourceIndex = 0;
			var names = Object.keys( this.storedNames );
			var mappings = new Mappings( options.hires );
	
			var locate = getLocator( this.original );
	
			if ( this.intro ) {
				mappings.advance( this.intro );
			}
	
			this.firstChunk.eachNext( function (chunk) {
				var loc = locate( chunk.start );
	
				if ( chunk.intro.length ) { mappings.advance( chunk.intro ); }
	
				if ( chunk.edited ) {
					mappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );
				} else {
					mappings.addUneditedChunk( sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations );
				}
	
				if ( chunk.outro.length ) { mappings.advance( chunk.outro ); }
			});
	
			var map = new SourceMap({
				file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
				sources: [ options.source ? getRelativePath( options.file || '', options.source ) : null ],
				sourcesContent: options.includeContent ? [ this.original ] : [ null ],
				names: names,
				mappings: mappings.encode()
			});
			return map;
		},
	
		getIndentString: function getIndentString () {
			return this.indentStr === null ? '\t' : this.indentStr;
		},
	
		indent: function indent ( indentStr, options ) {
			var this$1 = this;
	
			var pattern = /^[^\r\n]/gm;
	
			if ( isObject( indentStr ) ) {
				options = indentStr;
				indentStr = undefined;
			}
	
			indentStr = indentStr !== undefined ? indentStr : ( this.indentStr || '\t' );
	
			if ( indentStr === '' ) { return this; } // noop
	
			options = options || {};
	
			// Process exclusion ranges
			var isExcluded = {};
	
			if ( options.exclude ) {
				var exclusions = typeof options.exclude[0] === 'number' ? [ options.exclude ] : options.exclude;
				exclusions.forEach( function (exclusion) {
					for ( var i = exclusion[0]; i < exclusion[1]; i += 1 ) {
						isExcluded[i] = true;
					}
				});
			}
	
			var shouldIndentNextCharacter = options.indentStart !== false;
			var replacer = function (match) {
				if ( shouldIndentNextCharacter ) { return ("" + indentStr + match); }
				shouldIndentNextCharacter = true;
				return match;
			};
	
			this.intro = this.intro.replace( pattern, replacer );
	
			var charIndex = 0;
	
			var chunk = this.firstChunk;
	
			while ( chunk ) {
				var end = chunk.end;
	
				if ( chunk.edited ) {
					if ( !isExcluded[ charIndex ] ) {
						chunk.content = chunk.content.replace( pattern, replacer );
	
						if ( chunk.content.length ) {
							shouldIndentNextCharacter = chunk.content[ chunk.content.length - 1 ] === '\n';
						}
					}
				} else {
					charIndex = chunk.start;
	
					while ( charIndex < end ) {
						if ( !isExcluded[ charIndex ] ) {
							var char = this$1.original[ charIndex ];
	
							if ( char === '\n' ) {
								shouldIndentNextCharacter = true;
							} else if ( char !== '\r' && shouldIndentNextCharacter ) {
								shouldIndentNextCharacter = false;
	
								if ( charIndex === chunk.start ) {
									chunk.prependRight( indentStr );
								} else {
									this$1._splitChunk( chunk, charIndex );
									chunk = chunk.next;
									chunk.prependRight( indentStr );
								}
							}
						}
	
						charIndex += 1;
					}
				}
	
				charIndex = chunk.end;
				chunk = chunk.next;
			}
	
			this.outro = this.outro.replace( pattern, replacer );
	
			return this;
		},
	
		insert: function insert () {
			throw new Error( 'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)' );
		},
	
		insertLeft: function insertLeft ( index, content ) {
			if ( !warned.insertLeft ) {
				console.warn( 'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead' ); // eslint-disable-line no-console
				warned.insertLeft = true;
			}
	
			return this.appendLeft( index, content );
		},
	
		insertRight: function insertRight ( index, content ) {
			if ( !warned.insertRight ) {
				console.warn( 'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead' ); // eslint-disable-line no-console
				warned.insertRight = true;
			}
	
			return this.prependRight( index, content );
		},
	
		move: function move ( start, end, index ) {
			if ( index >= start && index <= end ) { throw new Error( 'Cannot move a selection inside itself' ); }
	
			this._split( start );
			this._split( end );
			this._split( index );
	
			var first = this.byStart[ start ];
			var last = this.byEnd[ end ];
	
			var oldLeft = first.previous;
			var oldRight = last.next;
	
			var newRight = this.byStart[ index ];
			if ( !newRight && last === this.lastChunk ) { return this; }
			var newLeft = newRight ? newRight.previous : this.lastChunk;
	
			if ( oldLeft ) { oldLeft.next = oldRight; }
			if ( oldRight ) { oldRight.previous = oldLeft; }
	
			if ( newLeft ) { newLeft.next = first; }
			if ( newRight ) { newRight.previous = last; }
	
			if ( !first.previous ) { this.firstChunk = last.next; }
			if ( !last.next ) {
				this.lastChunk = first.previous;
				this.lastChunk.next = null;
			}
	
			first.previous = newLeft;
			last.next = newRight || null;
	
			if ( !newLeft ) { this.firstChunk = first; }
			if ( !newRight ) { this.lastChunk = last; }
	
			return this;
		},
	
		overwrite: function overwrite ( start, end, content, options ) {
			var this$1 = this;
	
			if ( typeof content !== 'string' ) { throw new TypeError( 'replacement content must be a string' ); }
	
			while ( start < 0 ) { start += this$1.original.length; }
			while ( end < 0 ) { end += this$1.original.length; }
	
			if ( end > this.original.length ) { throw new Error( 'end is out of bounds' ); }
			if ( start === end ) { throw new Error( 'Cannot overwrite a zero-length range  use appendLeft or prependRight instead' ); }
	
			this._split( start );
			this._split( end );
	
			if ( options === true ) {
				if ( !warned.storeName ) {
					console.warn( 'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string' ); // eslint-disable-line no-console
					warned.storeName = true;
				}
	
				options = { storeName: true };
			}
			var storeName = options !== undefined ? options.storeName : false;
			var contentOnly = options !== undefined ? options.contentOnly : false;
	
			if ( storeName ) {
				var original = this.original.slice( start, end );
				this.storedNames[ original ] = true;
			}
	
			var first = this.byStart[ start ];
			var last = this.byEnd[ end ];
	
			if ( first ) {
				if ( end > first.end && first.next !== this.byStart[ first.end ] ) {
					throw new Error( 'Cannot overwrite across a split point' );
				}
	
				first.edit( content, storeName, contentOnly );
	
				if ( first !== last ) {
					var chunk = first.next;
					while ( chunk !== last ) {
						chunk.edit( '', false );
						chunk = chunk.next;
					}
	
					chunk.edit( '', false );
				}
			}
	
			else {
				// must be inserting at the end
				var newChunk = new Chunk( start, end, '' ).edit( content, storeName );
	
				// TODO last chunk in the array may not be the last chunk, if it's moved...
				last.next = newChunk;
				newChunk.previous = last;
			}
	
			return this;
		},
	
		prepend: function prepend ( content ) {
			if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }
	
			this.intro = content + this.intro;
			return this;
		},
	
		prependLeft: function prependLeft ( index, content ) {
			if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }
	
			this._split( index );
	
			var chunk = this.byEnd[ index ];
	
			if ( chunk ) {
				chunk.prependLeft( content );
			} else {
				this.intro = content + this.intro;
			}
	
			return this;
		},
	
		prependRight: function prependRight ( index, content ) {
			if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }
	
			this._split( index );
	
			var chunk = this.byStart[ index ];
	
			if ( chunk ) {
				chunk.prependRight( content );
			} else {
				this.outro = content + this.outro;
			}
	
			return this;
		},
	
		remove: function remove ( start, end ) {
			var this$1 = this;
	
			while ( start < 0 ) { start += this$1.original.length; }
			while ( end < 0 ) { end += this$1.original.length; }
	
			if ( start === end ) { return this; }
	
			if ( start < 0 || end > this.original.length ) { throw new Error( 'Character is out of bounds' ); }
			if ( start > end ) { throw new Error( 'end must be greater than start' ); }
	
			this._split( start );
			this._split( end );
	
			var chunk = this.byStart[ start ];
	
			while ( chunk ) {
				chunk.intro = '';
				chunk.outro = '';
				chunk.edit( '' );
	
				chunk = end > chunk.end ? this$1.byStart[ chunk.end ] : null;
			}
	
			return this;
		},
	
		slice: function slice ( start, end ) {
			var this$1 = this;
			if ( start === void 0 ) start = 0;
			if ( end === void 0 ) end = this.original.length;
	
			while ( start < 0 ) { start += this$1.original.length; }
			while ( end < 0 ) { end += this$1.original.length; }
	
			var result = '';
	
			// find start chunk
			var chunk = this.firstChunk;
			while ( chunk && ( chunk.start > start || chunk.end <= start ) ) {
	
				// found end chunk before start
				if ( chunk.start < end && chunk.end >= end ) {
					return result;
				}
	
				chunk = chunk.next;
			}
	
			if ( chunk && chunk.edited && chunk.start !== start ) { throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }
	
			var startChunk = chunk;
			while ( chunk ) {
				if ( chunk.intro && ( startChunk !== chunk || chunk.start === start ) ) {
					result += chunk.intro;
				}
	
				var containsEnd = chunk.start < end && chunk.end >= end;
				if ( containsEnd && chunk.edited && chunk.end !== end ) { throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }
	
				var sliceStart = startChunk === chunk ? start - chunk.start : 0;
				var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
	
				result += chunk.content.slice( sliceStart, sliceEnd );
	
				if ( chunk.outro && ( !containsEnd || chunk.end === end ) ) {
					result += chunk.outro;
				}
	
				if ( containsEnd ) {
					break;
				}
	
				chunk = chunk.next;
			}
	
			return result;
		},
	
		// TODO deprecate this? not really very useful
		snip: function snip ( start, end ) {
			var clone = this.clone();
			clone.remove( 0, start );
			clone.remove( end, clone.original.length );
	
			return clone;
		},
	
		_split: function _split ( index ) {
			var this$1 = this;
	
			if ( this.byStart[ index ] || this.byEnd[ index ] ) { return; }
	
			var chunk = this.lastSearchedChunk;
			var searchForward = index > chunk.end;
	
			while ( true ) {
				if ( chunk.contains( index ) ) { return this$1._splitChunk( chunk, index ); }
	
				chunk = searchForward ?
					this$1.byStart[ chunk.end ] :
					this$1.byEnd[ chunk.start ];
			}
		},
	
		_splitChunk: function _splitChunk ( chunk, index ) {
			if ( chunk.edited && chunk.content.length ) { // zero-length edited chunks are a special case (overlapping replacements)
				var loc = getLocator( this.original )( index );
				throw new Error( ("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + "  \"" + (chunk.original) + "\")") );
			}
	
			var newChunk = chunk.split( index );
	
			this.byEnd[ index ] = chunk;
			this.byStart[ index ] = newChunk;
			this.byEnd[ newChunk.end ] = newChunk;
	
			if ( chunk === this.lastChunk ) { this.lastChunk = newChunk; }
	
			this.lastSearchedChunk = chunk;
			return true;
		},
	
		toString: function toString () {
			var str = this.intro;
	
			var chunk = this.firstChunk;
			while ( chunk ) {
				str += chunk.toString();
				chunk = chunk.next;
			}
	
			return str + this.outro;
		},
	
		trimLines: function trimLines () {
			return this.trim('[\\r\\n]');
		},
	
		trim: function trim ( charType ) {
			return this.trimStart( charType ).trimEnd( charType );
		},
	
		trimEnd: function trimEnd ( charType ) {
			var this$1 = this;
	
			var rx = new RegExp( ( charType || '\\s' ) + '+$' );
	
			this.outro = this.outro.replace( rx, '' );
			if ( this.outro.length ) { return this; }
	
			var chunk = this.lastChunk;
	
			do {
				var end = chunk.end;
				var aborted = chunk.trimEnd( rx );
	
				// if chunk was trimmed, we have a new lastChunk
				if ( chunk.end !== end ) {
					if ( this$1.lastChunk === chunk ) {
						this$1.lastChunk = chunk.next;
					}
	
					this$1.byEnd[ chunk.end ] = chunk;
					this$1.byStart[ chunk.next.start ] = chunk.next;
					this$1.byEnd[ chunk.next.end ] = chunk.next;
				}
	
				if ( aborted ) { return this$1; }
				chunk = chunk.previous;
			} while ( chunk );
	
			return this;
		},
	
		trimStart: function trimStart ( charType ) {
			var this$1 = this;
	
			var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );
	
			this.intro = this.intro.replace( rx, '' );
			if ( this.intro.length ) { return this; }
	
			var chunk = this.firstChunk;
	
			do {
				var end = chunk.end;
				var aborted = chunk.trimStart( rx );
	
				if ( chunk.end !== end ) {
					// special case...
					if ( chunk === this$1.lastChunk ) { this$1.lastChunk = chunk.next; }
	
					this$1.byEnd[ chunk.end ] = chunk;
					this$1.byStart[ chunk.next.start ] = chunk.next;
					this$1.byEnd[ chunk.next.end ] = chunk.next;
				}
	
				if ( aborted ) { return this$1; }
				chunk = chunk.next;
			} while ( chunk );
	
			return this;
		}
	};
	
	var hasOwnProp = Object.prototype.hasOwnProperty;
	
	function Bundle ( options ) {
		if ( options === void 0 ) options = {};
	
		this.intro = options.intro || '';
		this.separator = options.separator !== undefined ? options.separator : '\n';
	
		this.sources = [];
	
		this.uniqueSources = [];
		this.uniqueSourceIndexByFilename = {};
	}
	
	Bundle.prototype = {
		addSource: function addSource ( source ) {
			if ( source instanceof MagicString$1 ) {
				return this.addSource({
					content: source,
					filename: source.filename,
					separator: this.separator
				});
			}
	
			if ( !isObject( source ) || !source.content ) {
				throw new Error( 'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`' );
			}
	
			[ 'filename', 'indentExclusionRanges', 'separator' ].forEach( function (option) {
				if ( !hasOwnProp.call( source, option ) ) { source[ option ] = source.content[ option ]; }
			});
	
			if ( source.separator === undefined ) { // TODO there's a bunch of this sort of thing, needs cleaning up
				source.separator = this.separator;
			}
	
			if ( source.filename ) {
				if ( !hasOwnProp.call( this.uniqueSourceIndexByFilename, source.filename ) ) {
					this.uniqueSourceIndexByFilename[ source.filename ] = this.uniqueSources.length;
					this.uniqueSources.push({ filename: source.filename, content: source.content.original });
				} else {
					var uniqueSource = this.uniqueSources[ this.uniqueSourceIndexByFilename[ source.filename ] ];
					if ( source.content.original !== uniqueSource.content ) {
						throw new Error( ("Illegal source: same filename (" + (source.filename) + "), different contents") );
					}
				}
			}
	
			this.sources.push( source );
			return this;
		},
	
		append: function append ( str, options ) {
			this.addSource({
				content: new MagicString$1( str ),
				separator: ( options && options.separator ) || ''
			});
	
			return this;
		},
	
		clone: function clone () {
			var bundle = new Bundle({
				intro: this.intro,
				separator: this.separator
			});
	
			this.sources.forEach( function (source) {
				bundle.addSource({
					filename: source.filename,
					content: source.content.clone(),
					separator: source.separator
				});
			});
	
			return bundle;
		},
	
		generateMap: function generateMap ( options ) {
			var this$1 = this;
			if ( options === void 0 ) options = {};
	
			var names = [];
			this.sources.forEach( function (source) {
				Object.keys( source.content.storedNames ).forEach( function (name) {
					if ( !~names.indexOf( name ) ) { names.push( name ); }
				});
			});
	
			var mappings = new Mappings( options.hires );
	
			if ( this.intro ) {
				mappings.advance( this.intro );
			}
	
			this.sources.forEach( function ( source, i ) {
				if ( i > 0 ) {
					mappings.advance( this$1.separator );
				}
	
				var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[ source.filename ] : -1;
				var magicString = source.content;
				var locate = getLocator( magicString.original );
	
				if ( magicString.intro ) {
					mappings.advance( magicString.intro );
				}
	
				magicString.firstChunk.eachNext( function (chunk) {
					var loc = locate( chunk.start );
	
					if ( chunk.intro.length ) { mappings.advance( chunk.intro ); }
	
					if ( source.filename ) {
						if ( chunk.edited ) {
							mappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );
						} else {
							mappings.addUneditedChunk( sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations );
						}
					}
	
					else {
						mappings.advance( chunk.content );
					}
	
					if ( chunk.outro.length ) { mappings.advance( chunk.outro ); }
				});
	
				if ( magicString.outro ) {
					mappings.advance( magicString.outro );
				}
			});
	
			return new SourceMap({
				file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
				sources: this.uniqueSources.map( function (source) {
					return options.file ? getRelativePath( options.file, source.filename ) : source.filename;
				}),
				sourcesContent: this.uniqueSources.map( function (source) {
					return options.includeContent ? source.content : null;
				}),
				names: names,
				mappings: mappings.encode()
			});
		},
	
		getIndentString: function getIndentString () {
			var indentStringCounts = {};
	
			this.sources.forEach( function (source) {
				var indentStr = source.content.indentStr;
	
				if ( indentStr === null ) { return; }
	
				if ( !indentStringCounts[ indentStr ] ) { indentStringCounts[ indentStr ] = 0; }
				indentStringCounts[ indentStr ] += 1;
			});
	
			return ( Object.keys( indentStringCounts ).sort( function ( a, b ) {
				return indentStringCounts[a] - indentStringCounts[b];
			})[0] ) || '\t';
		},
	
		indent: function indent ( indentStr ) {
			var this$1 = this;
	
			if ( !arguments.length ) {
				indentStr = this.getIndentString();
			}
	
			if ( indentStr === '' ) { return this; } // noop
	
			var trailingNewline = !this.intro || this.intro.slice( -1 ) === '\n';
	
			this.sources.forEach( function ( source, i ) {
				var separator = source.separator !== undefined ? source.separator : this$1.separator;
				var indentStart = trailingNewline || ( i > 0 && /\r?\n$/.test( separator ) );
	
				source.content.indent( indentStr, {
					exclude: source.indentExclusionRanges,
					indentStart: indentStart//: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
				});
	
				// TODO this is a very slow way to determine this
				trailingNewline = source.content.toString().slice( 0, -1 ) === '\n';
			});
	
			if ( this.intro ) {
				this.intro = indentStr + this.intro.replace( /^[^\n]/gm, function ( match, index ) {
					return index > 0 ? indentStr + match : match;
				});
			}
	
			return this;
		},
	
		prepend: function prepend ( str ) {
			this.intro = str + this.intro;
			return this;
		},
	
		toString: function toString () {
			var this$1 = this;
	
			var body = this.sources.map( function ( source, i ) {
				var separator = source.separator !== undefined ? source.separator : this$1.separator;
				var str = ( i > 0 ? separator : '' ) + source.content.toString();
	
				return str;
			}).join( '' );
	
			return this.intro + body;
		},
	
		trimLines: function trimLines () {
			return this.trim('[\\r\\n]');
		},
	
		trim: function trim ( charType ) {
			return this.trimStart( charType ).trimEnd( charType );
		},
	
		trimStart: function trimStart ( charType ) {
			var this$1 = this;
	
			var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );
			this.intro = this.intro.replace( rx, '' );
	
			if ( !this.intro ) {
				var source;
				var i = 0;
	
				do {
					source = this$1.sources[i];
	
					if ( !source ) {
						break;
					}
	
					source.content.trimStart( charType );
					i += 1;
				} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?
			}
	
			return this;
		},
	
		trimEnd: function trimEnd ( charType ) {
			var this$1 = this;
	
			var rx = new RegExp( ( charType || '\\s' ) + '+$' );
	
			var source;
			var i = this.sources.length - 1;
	
			do {
				source = this$1.sources[i];
	
				if ( !source ) {
					this$1.intro = this$1.intro.replace( rx, '' );
					break;
				}
	
				source.content.trimEnd( charType );
				i -= 1;
			} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?
	
			return this;
		}
	};
	
	MagicString$1.Bundle = Bundle;
	MagicString$1.default = MagicString$1; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121
	
	module.exports = MagicString$1;
	//# sourceMappingURL=magic-string.cjs.js.map
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ../~/.registry.npmjs.org/buffer/4.9.1/~/buffer/index.js */ 16).Buffer, __webpack_require__(/*! ../~/.registry.npmjs.org/process/0.11.10/~/process/browser.js */ 20)))

/***/ },
/* 16 */
/*!***************************************************************!*\
  !*** ../~/.registry.npmjs.org/buffer/4.9.1/~/buffer/index.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(/*! base64-js */ 17)
	var ieee754 = __webpack_require__(/*! ieee754 */ 18)
	var isArray = __webpack_require__(/*! isarray */ 19)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ../~/.registry.npmjs.org/buffer/4.9.1/~/buffer/index.js */ 16).Buffer, (function() { return this; }())))

/***/ },
/* 17 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/base64-js/1.3.0/~/base64-js/index.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function getLens (b64) {
	  var len = b64.length
	
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=')
	  if (validLen === -1) validLen = len
	
	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4)
	
	  return [validLen, placeHoldersLen]
	}
	
	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function toByteArray (b64) {
	  var tmp
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	
	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
	
	  var curByte = 0
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen
	
	  for (var i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)]
	    arr[curByte++] = (tmp >> 16) & 0xFF
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF)
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(
	      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
	    ))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    )
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    )
	  }
	
	  return parts.join('')
	}


/***/ },
/* 18 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ieee754/1.1.11/~/ieee754/index.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 19 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/isarray/1.0.0/~/isarray/index.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 20 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/process/0.11.10/~/process/browser.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 21 */
/*!************************************************************!*\
  !*** ../~/.registry.npmjs.org/vlq/0.2.3/~/vlq/dist/vlq.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.vlq = global.vlq || {})));
	}(this, (function (exports) { 'use strict';
	
	var charToInteger = {};
	var integerToChar = {};
	
	'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split( '' ).forEach( function ( char, i ) {
		charToInteger[ char ] = i;
		integerToChar[ i ] = char;
	});
	
	function decode ( string ) {
		var result = [];
		var shift = 0;
		var value = 0;
	
		for ( var i = 0; i < string.length; i += 1 ) {
			var integer = charToInteger[ string[i] ];
	
			if ( integer === undefined ) {
				throw new Error( 'Invalid character (' + string[i] + ')' );
			}
	
			var hasContinuationBit = integer & 32;
	
			integer &= 31;
			value += integer << shift;
	
			if ( hasContinuationBit ) {
				shift += 5;
			} else {
				var shouldNegate = value & 1;
				value >>= 1;
	
				result.push( shouldNegate ? -value : value );
	
				// reset
				value = shift = 0;
			}
		}
	
		return result;
	}
	
	function encode ( value ) {
		var result;
	
		if ( typeof value === 'number' ) {
			result = encodeInteger( value );
		} else {
			result = '';
			for ( var i = 0; i < value.length; i += 1 ) {
				result += encodeInteger( value[i] );
			}
		}
	
		return result;
	}
	
	function encodeInteger ( num ) {
		var result = '';
	
		if ( num < 0 ) {
			num = ( -num << 1 ) | 1;
		} else {
			num <<= 1;
		}
	
		do {
			var clamped = num & 31;
			num >>= 5;
	
			if ( num > 0 ) {
				clamped |= 32;
			}
	
			result += integerToChar[ clamped ];
		} while ( num > 0 );
	
		return result;
	}
	
	exports.decode = decode;
	exports.encode = encode;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },
/* 22 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/acorn/5.5.3/~/acorn/dist/acorn.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.acorn = {})));
	}(this, (function (exports) { 'use strict';
	
	// Reserved word lists for various dialects of the language
	
	var reservedWords = {
	  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	  5: "class enum extends super const export import",
	  6: "enum",
	  strict: "implements interface let package private protected public static yield",
	  strictBind: "eval arguments"
	};
	
	// And the keywords
	
	var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
	
	var keywords = {
	  5: ecma5AndLessKeywords,
	  6: ecma5AndLessKeywords + " const class extends export import super"
	};
	
	var keywordRelationalOperator = /^in(stanceof)?$/;
	
	// ## Character categories
	
	// Big ugly regular expressions that match characters in the
	// whitespace, identifier, and identifier-start categories. These
	// are only applied when a character is found to actually have a
	// code point above 128.
	// Generated by `bin/generate-identifier-regex.js`.
	
	var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312e\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fea\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
	var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
	
	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	
	// These are a run-length and offset encoded representation of the
	// >0xffff code points that are a valid part of identifiers. The
	// offset starts at 0x10000, and each pair of numbers represents an
	// offset to the next range, and then a size of the range. They were
	// generated by bin/generate-identifier-regex.js
	
	// eslint-disable-next-line comma-spacing
	var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,55,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,698,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,1,31,6124,20,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];
	
	// eslint-disable-next-line comma-spacing
	var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,19719,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];
	
	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function isInAstralSet(code, set) {
	  var pos = 0x10000;
	  for (var i = 0; i < set.length; i += 2) {
	    pos += set[i];
	    if (pos > code) { return false }
	    pos += set[i + 1];
	    if (pos >= code) { return true }
	  }
	}
	
	// Test whether a given character code starts an identifier.
	
	function isIdentifierStart(code, astral) {
	  if (code < 65) { return code === 36 }
	  if (code < 91) { return true }
	  if (code < 97) { return code === 95 }
	  if (code < 123) { return true }
	  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
	  if (astral === false) { return false }
	  return isInAstralSet(code, astralIdentifierStartCodes)
	}
	
	// Test whether a given character is part of an identifier.
	
	function isIdentifierChar(code, astral) {
	  if (code < 48) { return code === 36 }
	  if (code < 58) { return true }
	  if (code < 65) { return false }
	  if (code < 91) { return true }
	  if (code < 97) { return code === 95 }
	  if (code < 123) { return true }
	  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
	  if (astral === false) { return false }
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
	}
	
	// ## Token types
	
	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.
	
	// All token type variables start with an underscore, to make them
	// easy to recognize.
	
	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// The `startsExpr` property is used to check if the token ends a
	// `yield` expression. It is set on all token types that either can
	// directly start an expression (like a quotation mark) or can
	// continue an expression (like the body of a string).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.
	
	var TokenType = function TokenType(label, conf) {
	  if ( conf === void 0 ) conf = {};
	
	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop || null;
	  this.updateContext = null;
	};
	
	function binop(name, prec) {
	  return new TokenType(name, {beforeExpr: true, binop: prec})
	}
	var beforeExpr = {beforeExpr: true};
	var startsExpr = {startsExpr: true};
	
	// Map keyword names to token types.
	
	var keywords$1 = {};
	
	// Succinct definitions of keyword token types
	function kw(name, options) {
	  if ( options === void 0 ) options = {};
	
	  options.keyword = name;
	  return keywords$1[name] = new TokenType(name, options)
	}
	
	var types = {
	  num: new TokenType("num", startsExpr),
	  regexp: new TokenType("regexp", startsExpr),
	  string: new TokenType("string", startsExpr),
	  name: new TokenType("name", startsExpr),
	  eof: new TokenType("eof"),
	
	  // Punctuation token types.
	  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
	  bracketR: new TokenType("]"),
	  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
	  braceR: new TokenType("}"),
	  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
	  parenR: new TokenType(")"),
	  comma: new TokenType(",", beforeExpr),
	  semi: new TokenType(";", beforeExpr),
	  colon: new TokenType(":", beforeExpr),
	  dot: new TokenType("."),
	  question: new TokenType("?", beforeExpr),
	  arrow: new TokenType("=>", beforeExpr),
	  template: new TokenType("template"),
	  invalidTemplate: new TokenType("invalidTemplate"),
	  ellipsis: new TokenType("...", beforeExpr),
	  backQuote: new TokenType("`", startsExpr),
	  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),
	
	  // Operators. These carry several kinds of properties to help the
	  // parser use them properly (the presence of these properties is
	  // what categorizes them as operators).
	  //
	  // `binop`, when present, specifies that this operator is a binary
	  // operator, and will refer to its precedence.
	  //
	  // `prefix` and `postfix` mark the operator as a prefix or postfix
	  // unary operator.
	  //
	  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	  // binary operators with a very low precedence, that should result
	  // in AssignmentExpression nodes.
	
	  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
	  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
	  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
	  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
	  logicalOR: binop("||", 1),
	  logicalAND: binop("&&", 2),
	  bitwiseOR: binop("|", 3),
	  bitwiseXOR: binop("^", 4),
	  bitwiseAND: binop("&", 5),
	  equality: binop("==/!=/===/!==", 6),
	  relational: binop("</>/<=/>=", 7),
	  bitShift: binop("<</>>/>>>", 8),
	  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
	  modulo: binop("%", 10),
	  star: binop("*", 10),
	  slash: binop("/", 10),
	  starstar: new TokenType("**", {beforeExpr: true}),
	
	  // Keyword token types.
	  _break: kw("break"),
	  _case: kw("case", beforeExpr),
	  _catch: kw("catch"),
	  _continue: kw("continue"),
	  _debugger: kw("debugger"),
	  _default: kw("default", beforeExpr),
	  _do: kw("do", {isLoop: true, beforeExpr: true}),
	  _else: kw("else", beforeExpr),
	  _finally: kw("finally"),
	  _for: kw("for", {isLoop: true}),
	  _function: kw("function", startsExpr),
	  _if: kw("if"),
	  _return: kw("return", beforeExpr),
	  _switch: kw("switch"),
	  _throw: kw("throw", beforeExpr),
	  _try: kw("try"),
	  _var: kw("var"),
	  _const: kw("const"),
	  _while: kw("while", {isLoop: true}),
	  _with: kw("with"),
	  _new: kw("new", {beforeExpr: true, startsExpr: true}),
	  _this: kw("this", startsExpr),
	  _super: kw("super", startsExpr),
	  _class: kw("class", startsExpr),
	  _extends: kw("extends", beforeExpr),
	  _export: kw("export"),
	  _import: kw("import"),
	  _null: kw("null", startsExpr),
	  _true: kw("true", startsExpr),
	  _false: kw("false", startsExpr),
	  _in: kw("in", {beforeExpr: true, binop: 7}),
	  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
	  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
	  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
	  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
	};
	
	// Matches a whole line break (where CRLF is considered a single
	// line break). Used to count lines.
	
	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	var lineBreakG = new RegExp(lineBreak.source, "g");
	
	function isNewLine(code) {
	  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
	}
	
	var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	
	var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
	
	var ref = Object.prototype;
	var hasOwnProperty = ref.hasOwnProperty;
	var toString = ref.toString;
	
	// Checks if an object has a property.
	
	function has(obj, propName) {
	  return hasOwnProperty.call(obj, propName)
	}
	
	var isArray = Array.isArray || (function (obj) { return (
	  toString.call(obj) === "[object Array]"
	); });
	
	// These are used when `options.locations` is on, for the
	// `startLoc` and `endLoc` properties.
	
	var Position = function Position(line, col) {
	  this.line = line;
	  this.column = col;
	};
	
	Position.prototype.offset = function offset (n) {
	  return new Position(this.line, this.column + n)
	};
	
	var SourceLocation = function SourceLocation(p, start, end) {
	  this.start = start;
	  this.end = end;
	  if (p.sourceFile !== null) { this.source = p.sourceFile; }
	};
	
	// The `getLineInfo` function is mostly useful when the
	// `locations` option is off (for performance reasons) and you
	// want to find the line/column position for a given character
	// offset. `input` should be the code string that the offset refers
	// into.
	
	function getLineInfo(input, offset) {
	  for (var line = 1, cur = 0;;) {
	    lineBreakG.lastIndex = cur;
	    var match = lineBreakG.exec(input);
	    if (match && match.index < offset) {
	      ++line;
	      cur = match.index + match[0].length;
	    } else {
	      return new Position(line, offset - cur)
	    }
	  }
	}
	
	// A second optional argument can be given to further configure
	// the parser process. These options are recognized:
	
	var defaultOptions = {
	  // `ecmaVersion` indicates the ECMAScript version to parse. Must
	  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
	  // for strict mode, the set of reserved words, and support for
	  // new syntax features. The default is 7.
	  ecmaVersion: 7,
	  // `sourceType` indicates the mode the code should be parsed in.
	  // Can be either `"script"` or `"module"`. This influences global
	  // strict mode and parsing of `import` and `export` declarations.
	  sourceType: "script",
	  // `onInsertedSemicolon` can be a callback that will be called
	  // when a semicolon is automatically inserted. It will be passed
	  // th position of the comma as an offset, and if `locations` is
	  // enabled, it is given the location as a `{line, column}` object
	  // as second argument.
	  onInsertedSemicolon: null,
	  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	  // trailing commas.
	  onTrailingComma: null,
	  // By default, reserved words are only enforced if ecmaVersion >= 5.
	  // Set `allowReserved` to a boolean value to explicitly turn this on
	  // an off. When this option has the value "never", reserved words
	  // and keywords can also not be used as property names.
	  allowReserved: null,
	  // When enabled, a return at the top level is not considered an
	  // error.
	  allowReturnOutsideFunction: false,
	  // When enabled, import/export statements are not constrained to
	  // appearing at the top of the program.
	  allowImportExportEverywhere: false,
	  // When enabled, hashbang directive in the beginning of file
	  // is allowed and treated as a line comment.
	  allowHashBang: false,
	  // When `locations` is on, `loc` properties holding objects with
	  // `start` and `end` properties in `{line, column}` form (with
	  // line being 1-based and column 0-based) will be attached to the
	  // nodes.
	  locations: false,
	  // A function can be passed as `onToken` option, which will
	  // cause Acorn to call that function with object in the same
	  // format as tokens returned from `tokenizer().getToken()`. Note
	  // that you are not allowed to call the parser from the
	  // callbackthat will corrupt its internal state.
	  onToken: null,
	  // A function can be passed as `onComment` option, which will
	  // cause Acorn to call that function with `(block, text, start,
	  // end)` parameters whenever a comment is skipped. `block` is a
	  // boolean indicating whether this is a block (`/* */`) comment,
	  // `text` is the content of the comment, and `start` and `end` are
	  // character offsets that denote the start and end of the comment.
	  // When the `locations` option is on, two more parameters are
	  // passed, the full `{line, column}` locations of the start and
	  // end of the comments. Note that you are not allowed to call the
	  // parser from the callbackthat will corrupt its internal state.
	  onComment: null,
	  // Nodes have their start and end characters offsets recorded in
	  // `start` and `end` properties (directly on the node, rather than
	  // the `loc` object, which holds line/column data. To also add a
	  // [semi-standardized][range] `range` property holding a `[start,
	  // end]` array with the same numbers, set the `ranges` option to
	  // `true`.
	  //
	  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	  ranges: false,
	  // It is possible to parse multiple files into a single AST by
	  // passing the tree produced by parsing the first file as
	  // `program` option in subsequent parses. This will add the
	  // toplevel forms of the parsed file to the `Program` (top) node
	  // of an existing parse tree.
	  program: null,
	  // When `locations` is on, you can pass this to record the source
	  // file in every node's `loc` object.
	  sourceFile: null,
	  // This value, if given, is stored in every node, whether
	  // `locations` is on or off.
	  directSourceFile: null,
	  // When enabled, parenthesized expressions are represented by
	  // (non-standard) ParenthesizedExpression nodes
	  preserveParens: false,
	  plugins: {}
	};
	
	// Interpret and default an options object
	
	function getOptions(opts) {
	  var options = {};
	
	  for (var opt in defaultOptions)
	    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }
	
	  if (options.ecmaVersion >= 2015)
	    { options.ecmaVersion -= 2009; }
	
	  if (options.allowReserved == null)
	    { options.allowReserved = options.ecmaVersion < 5; }
	
	  if (isArray(options.onToken)) {
	    var tokens = options.onToken;
	    options.onToken = function (token) { return tokens.push(token); };
	  }
	  if (isArray(options.onComment))
	    { options.onComment = pushComment(options, options.onComment); }
	
	  return options
	}
	
	function pushComment(options, array) {
	  return function(block, text, start, end, startLoc, endLoc) {
	    var comment = {
	      type: block ? "Block" : "Line",
	      value: text,
	      start: start,
	      end: end
	    };
	    if (options.locations)
	      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
	    if (options.ranges)
	      { comment.range = [start, end]; }
	    array.push(comment);
	  }
	}
	
	// Registered plugins
	var plugins = {};
	
	function keywordRegexp(words) {
	  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
	}
	
	var Parser = function Parser(options, input, startPos) {
	  this.options = options = getOptions(options);
	  this.sourceFile = options.sourceFile;
	  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
	  var reserved = "";
	  if (!options.allowReserved) {
	    for (var v = options.ecmaVersion;; v--)
	      { if (reserved = reservedWords[v]) { break } }
	    if (options.sourceType == "module") { reserved += " await"; }
	  }
	  this.reservedWords = keywordRegexp(reserved);
	  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
	  this.reservedWordsStrict = keywordRegexp(reservedStrict);
	  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
	  this.input = String(input);
	
	  // Used to signal to callers of `readWord1` whether the word
	  // contained any escape sequences. This is needed because words with
	  // escape sequences must not be interpreted as keywords.
	  this.containsEsc = false;
	
	  // Load plugins
	  this.loadPlugins(options.plugins);
	
	  // Set up token state
	
	  // The current position of the tokenizer in the input.
	  if (startPos) {
	    this.pos = startPos;
	    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
	    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
	  } else {
	    this.pos = this.lineStart = 0;
	    this.curLine = 1;
	  }
	
	  // Properties of the current token:
	  // Its type
	  this.type = types.eof;
	  // For tokens that include more information than their type, the value
	  this.value = null;
	  // Its start and end offset
	  this.start = this.end = this.pos;
	  // And, if locations are used, the {line, column} object
	  // corresponding to those offsets
	  this.startLoc = this.endLoc = this.curPosition();
	
	  // Position information for the previous token
	  this.lastTokEndLoc = this.lastTokStartLoc = null;
	  this.lastTokStart = this.lastTokEnd = this.pos;
	
	  // The context stack is used to superficially track syntactic
	  // context to predict whether a regular expression is allowed in a
	  // given position.
	  this.context = this.initialContext();
	  this.exprAllowed = true;
	
	  // Figure out if it's a module code.
	  this.inModule = options.sourceType === "module";
	  this.strict = this.inModule || this.strictDirective(this.pos);
	
	  // Used to signify the start of a potential arrow function
	  this.potentialArrowAt = -1;
	
	  // Flags to track whether we are in a function, a generator, an async function.
	  this.inFunction = this.inGenerator = this.inAsync = false;
	  // Positions to delayed-check that yield/await does not exist in default parameters.
	  this.yieldPos = this.awaitPos = 0;
	  // Labels in scope.
	  this.labels = [];
	
	  // If enabled, skip leading hashbang line.
	  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
	    { this.skipLineComment(2); }
	
	  // Scope tracking for duplicate variable names (see scope.js)
	  this.scopeStack = [];
	  this.enterFunctionScope();
	
	  // For RegExp validation
	  this.regexpState = null;
	};
	
	// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
	Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
	Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };
	
	Parser.prototype.extend = function extend (name, f) {
	  this[name] = f(this[name]);
	};
	
	Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
	    var this$1 = this;
	
	  for (var name in pluginConfigs) {
	    var plugin = plugins[name];
	    if (!plugin) { throw new Error("Plugin '" + name + "' not found") }
	    plugin(this$1, pluginConfigs[name]);
	  }
	};
	
	Parser.prototype.parse = function parse () {
	  var node = this.options.program || this.startNode();
	  this.nextToken();
	  return this.parseTopLevel(node)
	};
	
	var pp = Parser.prototype;
	
	// ## Parser utilities
	
	var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;
	pp.strictDirective = function(start) {
	  var this$1 = this;
	
	  for (;;) {
	    skipWhiteSpace.lastIndex = start;
	    start += skipWhiteSpace.exec(this$1.input)[0].length;
	    var match = literal.exec(this$1.input.slice(start));
	    if (!match) { return false }
	    if ((match[1] || match[2]) == "use strict") { return true }
	    start += match[0].length;
	  }
	};
	
	// Predicate that tests whether the next token is of the given
	// type, and if yes, consumes it as a side effect.
	
	pp.eat = function(type) {
	  if (this.type === type) {
	    this.next();
	    return true
	  } else {
	    return false
	  }
	};
	
	// Tests whether parsed token is a contextual keyword.
	
	pp.isContextual = function(name) {
	  return this.type === types.name && this.value === name && !this.containsEsc
	};
	
	// Consumes contextual keyword if possible.
	
	pp.eatContextual = function(name) {
	  if (!this.isContextual(name)) { return false }
	  this.next();
	  return true
	};
	
	// Asserts that following token is given contextual keyword.
	
	pp.expectContextual = function(name) {
	  if (!this.eatContextual(name)) { this.unexpected(); }
	};
	
	// Test whether a semicolon can be inserted at the current position.
	
	pp.canInsertSemicolon = function() {
	  return this.type === types.eof ||
	    this.type === types.braceR ||
	    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	};
	
	pp.insertSemicolon = function() {
	  if (this.canInsertSemicolon()) {
	    if (this.options.onInsertedSemicolon)
	      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
	    return true
	  }
	};
	
	// Consume a semicolon, or, failing that, see if we are allowed to
	// pretend that there is a semicolon at this position.
	
	pp.semicolon = function() {
	  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
	};
	
	pp.afterTrailingComma = function(tokType, notNext) {
	  if (this.type == tokType) {
	    if (this.options.onTrailingComma)
	      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
	    if (!notNext)
	      { this.next(); }
	    return true
	  }
	};
	
	// Expect a token of a given type. If found, consume it, otherwise,
	// raise an unexpected token error.
	
	pp.expect = function(type) {
	  this.eat(type) || this.unexpected();
	};
	
	// Raise an unexpected token error.
	
	pp.unexpected = function(pos) {
	  this.raise(pos != null ? pos : this.start, "Unexpected token");
	};
	
	function DestructuringErrors() {
	  this.shorthandAssign =
	  this.trailingComma =
	  this.parenthesizedAssign =
	  this.parenthesizedBind =
	  this.doubleProto =
	    -1;
	}
	
	pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
	  if (!refDestructuringErrors) { return }
	  if (refDestructuringErrors.trailingComma > -1)
	    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
	  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
	  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
	};
	
	pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	  if (!refDestructuringErrors) { return false }
	  var shorthandAssign = refDestructuringErrors.shorthandAssign;
	  var doubleProto = refDestructuringErrors.doubleProto;
	  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
	  if (shorthandAssign >= 0)
	    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
	  if (doubleProto >= 0)
	    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
	};
	
	pp.checkYieldAwaitInDefaultParams = function() {
	  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
	    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
	  if (this.awaitPos)
	    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
	};
	
	pp.isSimpleAssignTarget = function(expr) {
	  if (expr.type === "ParenthesizedExpression")
	    { return this.isSimpleAssignTarget(expr.expression) }
	  return expr.type === "Identifier" || expr.type === "MemberExpression"
	};
	
	var pp$1 = Parser.prototype;
	
	// ### Statement parsing
	
	// Parse a program. Initializes the parser, reads any number of
	// statements, and wraps them in a Program node.  Optionally takes a
	// `program` argument.  If present, the statements will be appended
	// to its body instead of creating a new node.
	
	pp$1.parseTopLevel = function(node) {
	  var this$1 = this;
	
	  var exports = {};
	  if (!node.body) { node.body = []; }
	  while (this.type !== types.eof) {
	    var stmt = this$1.parseStatement(true, true, exports);
	    node.body.push(stmt);
	  }
	  this.adaptDirectivePrologue(node.body);
	  this.next();
	  if (this.options.ecmaVersion >= 6) {
	    node.sourceType = this.options.sourceType;
	  }
	  return this.finishNode(node, "Program")
	};
	
	var loopLabel = {kind: "loop"};
	var switchLabel = {kind: "switch"};
	
	pp$1.isLet = function() {
	  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
	  skipWhiteSpace.lastIndex = this.pos;
	  var skip = skipWhiteSpace.exec(this.input);
	  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
	  if (nextCh === 91 || nextCh == 123) { return true } // '{' and '['
	  if (isIdentifierStart(nextCh, true)) {
	    var pos = next + 1;
	    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
	    var ident = this.input.slice(next, pos);
	    if (!keywordRelationalOperator.test(ident)) { return true }
	  }
	  return false
	};
	
	// check 'async [no LineTerminator here] function'
	// - 'async /*foo*/ function' is OK.
	// - 'async /*\n*/ function' is invalid.
	pp$1.isAsyncFunction = function() {
	  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
	    { return false }
	
	  skipWhiteSpace.lastIndex = this.pos;
	  var skip = skipWhiteSpace.exec(this.input);
	  var next = this.pos + skip[0].length;
	  return !lineBreak.test(this.input.slice(this.pos, next)) &&
	    this.input.slice(next, next + 8) === "function" &&
	    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
	};
	
	// Parse a single statement.
	//
	// If expecting a statement and finding a slash operator, parse a
	// regular expression literal. This is to handle cases like
	// `if (foo) /blah/.exec(foo)`, where looking at the previous token
	// does not help.
	
	pp$1.parseStatement = function(declaration, topLevel, exports) {
	  var starttype = this.type, node = this.startNode(), kind;
	
	  if (this.isLet()) {
	    starttype = types._var;
	    kind = "let";
	  }
	
	  // Most types of statements are recognized by the keyword they
	  // start with. Many are trivial to parse, some require a bit of
	  // complexity.
	
	  switch (starttype) {
	  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
	  case types._debugger: return this.parseDebuggerStatement(node)
	  case types._do: return this.parseDoStatement(node)
	  case types._for: return this.parseForStatement(node)
	  case types._function:
	    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }
	    return this.parseFunctionStatement(node, false)
	  case types._class:
	    if (!declaration) { this.unexpected(); }
	    return this.parseClass(node, true)
	  case types._if: return this.parseIfStatement(node)
	  case types._return: return this.parseReturnStatement(node)
	  case types._switch: return this.parseSwitchStatement(node)
	  case types._throw: return this.parseThrowStatement(node)
	  case types._try: return this.parseTryStatement(node)
	  case types._const: case types._var:
	    kind = kind || this.value;
	    if (!declaration && kind != "var") { this.unexpected(); }
	    return this.parseVarStatement(node, kind)
	  case types._while: return this.parseWhileStatement(node)
	  case types._with: return this.parseWithStatement(node)
	  case types.braceL: return this.parseBlock()
	  case types.semi: return this.parseEmptyStatement(node)
	  case types._export:
	  case types._import:
	    if (!this.options.allowImportExportEverywhere) {
	      if (!topLevel)
	        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
	      if (!this.inModule)
	        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
	    }
	    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)
	
	    // If the statement does not start with a statement keyword or a
	    // brace, it's an ExpressionStatement or LabeledStatement. We
	    // simply start parsing an expression, and afterwards, if the
	    // next token is a colon and the expression was a simple
	    // Identifier node, we switch to interpreting it as a label.
	  default:
	    if (this.isAsyncFunction()) {
	      if (!declaration) { this.unexpected(); }
	      this.next();
	      return this.parseFunctionStatement(node, true)
	    }
	
	    var maybeName = this.value, expr = this.parseExpression();
	    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
	      { return this.parseLabeledStatement(node, maybeName, expr) }
	    else { return this.parseExpressionStatement(node, expr) }
	  }
	};
	
	pp$1.parseBreakContinueStatement = function(node, keyword) {
	  var this$1 = this;
	
	  var isBreak = keyword == "break";
	  this.next();
	  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
	  else if (this.type !== types.name) { this.unexpected(); }
	  else {
	    node.label = this.parseIdent();
	    this.semicolon();
	  }
	
	  // Verify that there is an actual destination to break or
	  // continue to.
	  var i = 0;
	  for (; i < this.labels.length; ++i) {
	    var lab = this$1.labels[i];
	    if (node.label == null || lab.name === node.label.name) {
	      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
	      if (node.label && isBreak) { break }
	    }
	  }
	  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
	  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
	};
	
	pp$1.parseDebuggerStatement = function(node) {
	  this.next();
	  this.semicolon();
	  return this.finishNode(node, "DebuggerStatement")
	};
	
	pp$1.parseDoStatement = function(node) {
	  this.next();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  this.expect(types._while);
	  node.test = this.parseParenExpression();
	  if (this.options.ecmaVersion >= 6)
	    { this.eat(types.semi); }
	  else
	    { this.semicolon(); }
	  return this.finishNode(node, "DoWhileStatement")
	};
	
	// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	// loop is non-trivial. Basically, we have to parse the init `var`
	// statement or expression, disallowing the `in` operator (see
	// the second parameter to `parseExpression`), and then check
	// whether the next token is `in` or `of`. When there is no init
	// part (semicolon immediately after the opening parenthesis), it
	// is a regular `for` loop.
	
	pp$1.parseForStatement = function(node) {
	  this.next();
	  var awaitAt = (this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual("await")) ? this.lastTokStart : -1;
	  this.labels.push(loopLabel);
	  this.enterLexicalScope();
	  this.expect(types.parenL);
	  if (this.type === types.semi) {
	    if (awaitAt > -1) { this.unexpected(awaitAt); }
	    return this.parseFor(node, null)
	  }
	  var isLet = this.isLet();
	  if (this.type === types._var || this.type === types._const || isLet) {
	    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
	    this.next();
	    this.parseVar(init$1, true, kind);
	    this.finishNode(init$1, "VariableDeclaration");
	    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
	        !(kind !== "var" && init$1.declarations[0].init)) {
	      if (this.options.ecmaVersion >= 9) {
	        if (this.type === types._in) {
	          if (awaitAt > -1) { this.unexpected(awaitAt); }
	        } else { node.await = awaitAt > -1; }
	      }
	      return this.parseForIn(node, init$1)
	    }
	    if (awaitAt > -1) { this.unexpected(awaitAt); }
	    return this.parseFor(node, init$1)
	  }
	  var refDestructuringErrors = new DestructuringErrors;
	  var init = this.parseExpression(true, refDestructuringErrors);
	  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	    if (this.options.ecmaVersion >= 9) {
	      if (this.type === types._in) {
	        if (awaitAt > -1) { this.unexpected(awaitAt); }
	      } else { node.await = awaitAt > -1; }
	    }
	    this.toAssignable(init, false, refDestructuringErrors);
	    this.checkLVal(init);
	    return this.parseForIn(node, init)
	  } else {
	    this.checkExpressionErrors(refDestructuringErrors, true);
	  }
	  if (awaitAt > -1) { this.unexpected(awaitAt); }
	  return this.parseFor(node, init)
	};
	
	pp$1.parseFunctionStatement = function(node, isAsync) {
	  this.next();
	  return this.parseFunction(node, true, false, isAsync)
	};
	
	pp$1.parseIfStatement = function(node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  // allow function declarations in branches, but only in non-strict mode
	  node.consequent = this.parseStatement(!this.strict && this.type == types._function);
	  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type == types._function) : null;
	  return this.finishNode(node, "IfStatement")
	};
	
	pp$1.parseReturnStatement = function(node) {
	  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
	    { this.raise(this.start, "'return' outside of function"); }
	  this.next();
	
	  // In `return` (and `break`/`continue`), the keywords with
	  // optional arguments, we eagerly look for a semicolon or the
	  // possibility to insert one.
	
	  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
	  else { node.argument = this.parseExpression(); this.semicolon(); }
	  return this.finishNode(node, "ReturnStatement")
	};
	
	pp$1.parseSwitchStatement = function(node) {
	  var this$1 = this;
	
	  this.next();
	  node.discriminant = this.parseParenExpression();
	  node.cases = [];
	  this.expect(types.braceL);
	  this.labels.push(switchLabel);
	  this.enterLexicalScope();
	
	  // Statements under must be grouped (by label) in SwitchCase
	  // nodes. `cur` is used to keep the node that we are currently
	  // adding statements to.
	
	  var cur;
	  for (var sawDefault = false; this.type != types.braceR;) {
	    if (this$1.type === types._case || this$1.type === types._default) {
	      var isCase = this$1.type === types._case;
	      if (cur) { this$1.finishNode(cur, "SwitchCase"); }
	      node.cases.push(cur = this$1.startNode());
	      cur.consequent = [];
	      this$1.next();
	      if (isCase) {
	        cur.test = this$1.parseExpression();
	      } else {
	        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses"); }
	        sawDefault = true;
	        cur.test = null;
	      }
	      this$1.expect(types.colon);
	    } else {
	      if (!cur) { this$1.unexpected(); }
	      cur.consequent.push(this$1.parseStatement(true));
	    }
	  }
	  this.exitLexicalScope();
	  if (cur) { this.finishNode(cur, "SwitchCase"); }
	  this.next(); // Closing brace
	  this.labels.pop();
	  return this.finishNode(node, "SwitchStatement")
	};
	
	pp$1.parseThrowStatement = function(node) {
	  this.next();
	  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
	    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
	  node.argument = this.parseExpression();
	  this.semicolon();
	  return this.finishNode(node, "ThrowStatement")
	};
	
	// Reused empty array added for node fields that are always empty.
	
	var empty = [];
	
	pp$1.parseTryStatement = function(node) {
	  this.next();
	  node.block = this.parseBlock();
	  node.handler = null;
	  if (this.type === types._catch) {
	    var clause = this.startNode();
	    this.next();
	    this.expect(types.parenL);
	    clause.param = this.parseBindingAtom();
	    this.enterLexicalScope();
	    this.checkLVal(clause.param, "let");
	    this.expect(types.parenR);
	    clause.body = this.parseBlock(false);
	    this.exitLexicalScope();
	    node.handler = this.finishNode(clause, "CatchClause");
	  }
	  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
	  if (!node.handler && !node.finalizer)
	    { this.raise(node.start, "Missing catch or finally clause"); }
	  return this.finishNode(node, "TryStatement")
	};
	
	pp$1.parseVarStatement = function(node, kind) {
	  this.next();
	  this.parseVar(node, false, kind);
	  this.semicolon();
	  return this.finishNode(node, "VariableDeclaration")
	};
	
	pp$1.parseWhileStatement = function(node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "WhileStatement")
	};
	
	pp$1.parseWithStatement = function(node) {
	  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
	  this.next();
	  node.object = this.parseParenExpression();
	  node.body = this.parseStatement(false);
	  return this.finishNode(node, "WithStatement")
	};
	
	pp$1.parseEmptyStatement = function(node) {
	  this.next();
	  return this.finishNode(node, "EmptyStatement")
	};
	
	pp$1.parseLabeledStatement = function(node, maybeName, expr) {
	  var this$1 = this;
	
	  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)
	    {
	    var label = list[i$1];
	
	    if (label.name === maybeName)
	      { this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
	  } }
	  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
	  for (var i = this.labels.length - 1; i >= 0; i--) {
	    var label$1 = this$1.labels[i];
	    if (label$1.statementStart == node.start) {
	      // Update information about previous labels on this node
	      label$1.statementStart = this$1.start;
	      label$1.kind = kind;
	    } else { break }
	  }
	  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
	  node.body = this.parseStatement(true);
	  if (node.body.type == "ClassDeclaration" ||
	      node.body.type == "VariableDeclaration" && node.body.kind != "var" ||
	      node.body.type == "FunctionDeclaration" && (this.strict || node.body.generator))
	    { this.raiseRecoverable(node.body.start, "Invalid labeled declaration"); }
	  this.labels.pop();
	  node.label = expr;
	  return this.finishNode(node, "LabeledStatement")
	};
	
	pp$1.parseExpressionStatement = function(node, expr) {
	  node.expression = expr;
	  this.semicolon();
	  return this.finishNode(node, "ExpressionStatement")
	};
	
	// Parse a semicolon-enclosed block of statements, handling `"use
	// strict"` declarations when `allowStrict` is true (used for
	// function bodies).
	
	pp$1.parseBlock = function(createNewLexicalScope) {
	  var this$1 = this;
	  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
	
	  var node = this.startNode();
	  node.body = [];
	  this.expect(types.braceL);
	  if (createNewLexicalScope) {
	    this.enterLexicalScope();
	  }
	  while (!this.eat(types.braceR)) {
	    var stmt = this$1.parseStatement(true);
	    node.body.push(stmt);
	  }
	  if (createNewLexicalScope) {
	    this.exitLexicalScope();
	  }
	  return this.finishNode(node, "BlockStatement")
	};
	
	// Parse a regular `for` loop. The disambiguation code in
	// `parseStatement` will already have parsed the init statement or
	// expression.
	
	pp$1.parseFor = function(node, init) {
	  node.init = init;
	  this.expect(types.semi);
	  node.test = this.type === types.semi ? null : this.parseExpression();
	  this.expect(types.semi);
	  node.update = this.type === types.parenR ? null : this.parseExpression();
	  this.expect(types.parenR);
	  this.exitLexicalScope();
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "ForStatement")
	};
	
	// Parse a `for`/`in` and `for`/`of` loop, which are almost
	// same from parser's perspective.
	
	pp$1.parseForIn = function(node, init) {
	  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
	  this.next();
	  if (type == "ForInStatement") {
	    if (init.type === "AssignmentPattern" ||
	      (init.type === "VariableDeclaration" && init.declarations[0].init != null &&
	       (this.strict || init.declarations[0].id.type !== "Identifier")))
	      { this.raise(init.start, "Invalid assignment in for-in loop head"); }
	  }
	  node.left = init;
	  node.right = type == "ForInStatement" ? this.parseExpression() : this.parseMaybeAssign();
	  this.expect(types.parenR);
	  this.exitLexicalScope();
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, type)
	};
	
	// Parse a list of variable declarations.
	
	pp$1.parseVar = function(node, isFor, kind) {
	  var this$1 = this;
	
	  node.declarations = [];
	  node.kind = kind;
	  for (;;) {
	    var decl = this$1.startNode();
	    this$1.parseVarId(decl, kind);
	    if (this$1.eat(types.eq)) {
	      decl.init = this$1.parseMaybeAssign(isFor);
	    } else if (kind === "const" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
	      this$1.unexpected();
	    } else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
	      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
	    } else {
	      decl.init = null;
	    }
	    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
	    if (!this$1.eat(types.comma)) { break }
	  }
	  return node
	};
	
	pp$1.parseVarId = function(decl, kind) {
	  decl.id = this.parseBindingAtom(kind);
	  this.checkLVal(decl.id, kind, false);
	};
	
	// Parse a function declaration or literal (depending on the
	// `isStatement` parameter).
	
	pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)
	    { node.generator = this.eat(types.star); }
	  if (this.options.ecmaVersion >= 8)
	    { node.async = !!isAsync; }
	
	  if (isStatement) {
	    node.id = isStatement === "nullableID" && this.type != types.name ? null : this.parseIdent();
	    if (node.id) {
	      this.checkLVal(node.id, "var");
	    }
	  }
	
	  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
	      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
	  this.inGenerator = node.generator;
	  this.inAsync = node.async;
	  this.yieldPos = 0;
	  this.awaitPos = 0;
	  this.inFunction = true;
	  this.enterFunctionScope();
	
	  if (!isStatement)
	    { node.id = this.type == types.name ? this.parseIdent() : null; }
	
	  this.parseFunctionParams(node);
	  this.parseFunctionBody(node, allowExpressionBody);
	
	  this.inGenerator = oldInGen;
	  this.inAsync = oldInAsync;
	  this.yieldPos = oldYieldPos;
	  this.awaitPos = oldAwaitPos;
	  this.inFunction = oldInFunc;
	  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
	};
	
	pp$1.parseFunctionParams = function(node) {
	  this.expect(types.parenL);
	  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
	  this.checkYieldAwaitInDefaultParams();
	};
	
	// Parse a class declaration or literal (depending on the
	// `isStatement` parameter).
	
	pp$1.parseClass = function(node, isStatement) {
	  var this$1 = this;
	
	  this.next();
	
	  this.parseClassId(node, isStatement);
	  this.parseClassSuper(node);
	  var classBody = this.startNode();
	  var hadConstructor = false;
	  classBody.body = [];
	  this.expect(types.braceL);
	  while (!this.eat(types.braceR)) {
	    var member = this$1.parseClassMember(classBody);
	    if (member && member.type === "MethodDefinition" && member.kind === "constructor") {
	      if (hadConstructor) { this$1.raise(member.start, "Duplicate constructor in the same class"); }
	      hadConstructor = true;
	    }
	  }
	  node.body = this.finishNode(classBody, "ClassBody");
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
	};
	
	pp$1.parseClassMember = function(classBody) {
	  var this$1 = this;
	
	  if (this.eat(types.semi)) { return null }
	
	  var method = this.startNode();
	  var tryContextual = function (k, noLineBreak) {
	    if ( noLineBreak === void 0 ) noLineBreak = false;
	
	    var start = this$1.start, startLoc = this$1.startLoc;
	    if (!this$1.eatContextual(k)) { return false }
	    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
	    if (method.key) { this$1.unexpected(); }
	    method.computed = false;
	    method.key = this$1.startNodeAt(start, startLoc);
	    method.key.name = k;
	    this$1.finishNode(method.key, "Identifier");
	    return false
	  };
	
	  method.kind = "method";
	  method.static = tryContextual("static");
	  var isGenerator = this.eat(types.star);
	  var isAsync = false;
	  if (!isGenerator) {
	    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
	      isAsync = true;
	      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
	    } else if (tryContextual("get")) {
	      method.kind = "get";
	    } else if (tryContextual("set")) {
	      method.kind = "set";
	    }
	  }
	  if (!method.key) { this.parsePropertyName(method); }
	  var key = method.key;
	  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
	      key.type === "Literal" && key.value === "constructor")) {
	    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
	    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
	    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
	    method.kind = "constructor";
	  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
	    this.raise(key.start, "Classes may not have a static property named prototype");
	  }
	  this.parseClassMethod(classBody, method, isGenerator, isAsync);
	  if (method.kind === "get" && method.value.params.length !== 0)
	    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
	  if (method.kind === "set" && method.value.params.length !== 1)
	    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
	  if (method.kind === "set" && method.value.params[0].type === "RestElement")
	    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
	  return method
	};
	
	pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
	  method.value = this.parseMethod(isGenerator, isAsync);
	  classBody.body.push(this.finishNode(method, "MethodDefinition"));
	};
	
	pp$1.parseClassId = function(node, isStatement) {
	  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
	};
	
	pp$1.parseClassSuper = function(node) {
	  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
	};
	
	// Parses module export declaration.
	
	pp$1.parseExport = function(node, exports) {
	  var this$1 = this;
	
	  this.next();
	  // export * from '...'
	  if (this.eat(types.star)) {
	    this.expectContextual("from");
	    if (this.type !== types.string) { this.unexpected(); }
	    node.source = this.parseExprAtom();
	    this.semicolon();
	    return this.finishNode(node, "ExportAllDeclaration")
	  }
	  if (this.eat(types._default)) { // export default ...
	    this.checkExport(exports, "default", this.lastTokStart);
	    var isAsync;
	    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
	      var fNode = this.startNode();
	      this.next();
	      if (isAsync) { this.next(); }
	      node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
	    } else if (this.type === types._class) {
	      var cNode = this.startNode();
	      node.declaration = this.parseClass(cNode, "nullableID");
	    } else {
	      node.declaration = this.parseMaybeAssign();
	      this.semicolon();
	    }
	    return this.finishNode(node, "ExportDefaultDeclaration")
	  }
	  // export var|const|let|function|class ...
	  if (this.shouldParseExportStatement()) {
	    node.declaration = this.parseStatement(true);
	    if (node.declaration.type === "VariableDeclaration")
	      { this.checkVariableExport(exports, node.declaration.declarations); }
	    else
	      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
	    node.specifiers = [];
	    node.source = null;
	  } else { // export { x, y as z } [from '...']
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifiers(exports);
	    if (this.eatContextual("from")) {
	      if (this.type !== types.string) { this.unexpected(); }
	      node.source = this.parseExprAtom();
	    } else {
	      // check for keywords used as local names
	      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
	        var spec = list[i];
	
	        this$1.checkUnreserved(spec.local);
	      }
	
	      node.source = null;
	    }
	    this.semicolon();
	  }
	  return this.finishNode(node, "ExportNamedDeclaration")
	};
	
	pp$1.checkExport = function(exports, name, pos) {
	  if (!exports) { return }
	  if (has(exports, name))
	    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
	  exports[name] = true;
	};
	
	pp$1.checkPatternExport = function(exports, pat) {
	  var this$1 = this;
	
	  var type = pat.type;
	  if (type == "Identifier")
	    { this.checkExport(exports, pat.name, pat.start); }
	  else if (type == "ObjectPattern")
	    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
	      {
	        var prop = list[i];
	
	        this$1.checkPatternExport(exports, prop);
	      } }
	  else if (type == "ArrayPattern")
	    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
	      var elt = list$1[i$1];
	
	        if (elt) { this$1.checkPatternExport(exports, elt); }
	    } }
	  else if (type == "Property")
	    { this.checkPatternExport(exports, pat.value); }
	  else if (type == "AssignmentPattern")
	    { this.checkPatternExport(exports, pat.left); }
	  else if (type == "RestElement")
	    { this.checkPatternExport(exports, pat.argument); }
	  else if (type == "ParenthesizedExpression")
	    { this.checkPatternExport(exports, pat.expression); }
	};
	
	pp$1.checkVariableExport = function(exports, decls) {
	  var this$1 = this;
	
	  if (!exports) { return }
	  for (var i = 0, list = decls; i < list.length; i += 1)
	    {
	    var decl = list[i];
	
	    this$1.checkPatternExport(exports, decl.id);
	  }
	};
	
	pp$1.shouldParseExportStatement = function() {
	  return this.type.keyword === "var" ||
	    this.type.keyword === "const" ||
	    this.type.keyword === "class" ||
	    this.type.keyword === "function" ||
	    this.isLet() ||
	    this.isAsyncFunction()
	};
	
	// Parses a comma-separated list of module exports.
	
	pp$1.parseExportSpecifiers = function(exports) {
	  var this$1 = this;
	
	  var nodes = [], first = true;
	  // export { x, y as z } [from '...']
	  this.expect(types.braceL);
	  while (!this.eat(types.braceR)) {
	    if (!first) {
	      this$1.expect(types.comma);
	      if (this$1.afterTrailingComma(types.braceR)) { break }
	    } else { first = false; }
	
	    var node = this$1.startNode();
	    node.local = this$1.parseIdent(true);
	    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
	    this$1.checkExport(exports, node.exported.name, node.exported.start);
	    nodes.push(this$1.finishNode(node, "ExportSpecifier"));
	  }
	  return nodes
	};
	
	// Parses import declaration.
	
	pp$1.parseImport = function(node) {
	  this.next();
	  // import '...'
	  if (this.type === types.string) {
	    node.specifiers = empty;
	    node.source = this.parseExprAtom();
	  } else {
	    node.specifiers = this.parseImportSpecifiers();
	    this.expectContextual("from");
	    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration")
	};
	
	// Parses a comma-separated list of module imports.
	
	pp$1.parseImportSpecifiers = function() {
	  var this$1 = this;
	
	  var nodes = [], first = true;
	  if (this.type === types.name) {
	    // import defaultObj, { x, y as z } from '...'
	    var node = this.startNode();
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, "let");
	    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
	    if (!this.eat(types.comma)) { return nodes }
	  }
	  if (this.type === types.star) {
	    var node$1 = this.startNode();
	    this.next();
	    this.expectContextual("as");
	    node$1.local = this.parseIdent();
	    this.checkLVal(node$1.local, "let");
	    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
	    return nodes
	  }
	  this.expect(types.braceL);
	  while (!this.eat(types.braceR)) {
	    if (!first) {
	      this$1.expect(types.comma);
	      if (this$1.afterTrailingComma(types.braceR)) { break }
	    } else { first = false; }
	
	    var node$2 = this$1.startNode();
	    node$2.imported = this$1.parseIdent(true);
	    if (this$1.eatContextual("as")) {
	      node$2.local = this$1.parseIdent();
	    } else {
	      this$1.checkUnreserved(node$2.imported);
	      node$2.local = node$2.imported;
	    }
	    this$1.checkLVal(node$2.local, "let");
	    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
	  }
	  return nodes
	};
	
	// Set `ExpressionStatement#directive` property for directive prologues.
	pp$1.adaptDirectivePrologue = function(statements) {
	  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
	    statements[i].directive = statements[i].expression.raw.slice(1, -1);
	  }
	};
	pp$1.isDirectiveCandidate = function(statement) {
	  return (
	    statement.type === "ExpressionStatement" &&
	    statement.expression.type === "Literal" &&
	    typeof statement.expression.value === "string" &&
	    // Reject parenthesized strings.
	    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
	  )
	};
	
	var pp$2 = Parser.prototype;
	
	// Convert existing expression atom to assignable pattern
	// if possible.
	
	pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
	  var this$1 = this;
	
	  if (this.options.ecmaVersion >= 6 && node) {
	    switch (node.type) {
	    case "Identifier":
	      if (this.inAsync && node.name === "await")
	        { this.raise(node.start, "Can not use 'await' as identifier inside an async function"); }
	      break
	
	    case "ObjectPattern":
	    case "ArrayPattern":
	    case "RestElement":
	      break
	
	    case "ObjectExpression":
	      node.type = "ObjectPattern";
	      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
	      for (var i = 0, list = node.properties; i < list.length; i += 1) {
	        var prop = list[i];
	
	      this$1.toAssignable(prop, isBinding);
	        // Early error:
	        //   AssignmentRestProperty[Yield, Await] :
	        //     `...` DestructuringAssignmentTarget[Yield, Await]
	        //
	        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
	        if (
	          prop.type === "RestElement" &&
	          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
	        ) {
	          this$1.raise(prop.argument.start, "Unexpected token");
	        }
	      }
	      break
	
	    case "Property":
	      // AssignmentProperty has type == "Property"
	      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
	      this.toAssignable(node.value, isBinding);
	      break
	
	    case "ArrayExpression":
	      node.type = "ArrayPattern";
	      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
	      this.toAssignableList(node.elements, isBinding);
	      break
	
	    case "SpreadElement":
	      node.type = "RestElement";
	      this.toAssignable(node.argument, isBinding);
	      if (node.argument.type === "AssignmentPattern")
	        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
	      break
	
	    case "AssignmentExpression":
	      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
	      node.type = "AssignmentPattern";
	      delete node.operator;
	      this.toAssignable(node.left, isBinding);
	      // falls through to AssignmentPattern
	
	    case "AssignmentPattern":
	      break
	
	    case "ParenthesizedExpression":
	      this.toAssignable(node.expression, isBinding);
	      break
	
	    case "MemberExpression":
	      if (!isBinding) { break }
	
	    default:
	      this.raise(node.start, "Assigning to rvalue");
	    }
	  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
	  return node
	};
	
	// Convert list of expression atoms to binding list.
	
	pp$2.toAssignableList = function(exprList, isBinding) {
	  var this$1 = this;
	
	  var end = exprList.length;
	  for (var i = 0; i < end; i++) {
	    var elt = exprList[i];
	    if (elt) { this$1.toAssignable(elt, isBinding); }
	  }
	  if (end) {
	    var last = exprList[end - 1];
	    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
	      { this.unexpected(last.argument.start); }
	  }
	  return exprList
	};
	
	// Parses spread element.
	
	pp$2.parseSpread = function(refDestructuringErrors) {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	  return this.finishNode(node, "SpreadElement")
	};
	
	pp$2.parseRestBinding = function() {
	  var node = this.startNode();
	  this.next();
	
	  // RestElement inside of a function parameter must be an identifier
	  if (this.options.ecmaVersion === 6 && this.type !== types.name)
	    { this.unexpected(); }
	
	  node.argument = this.parseBindingAtom();
	
	  return this.finishNode(node, "RestElement")
	};
	
	// Parses lvalue (assignable) atom.
	
	pp$2.parseBindingAtom = function() {
	  if (this.options.ecmaVersion >= 6) {
	    switch (this.type) {
	    case types.bracketL:
	      var node = this.startNode();
	      this.next();
	      node.elements = this.parseBindingList(types.bracketR, true, true);
	      return this.finishNode(node, "ArrayPattern")
	
	    case types.braceL:
	      return this.parseObj(true)
	    }
	  }
	  return this.parseIdent()
	};
	
	pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
	  var this$1 = this;
	
	  var elts = [], first = true;
	  while (!this.eat(close)) {
	    if (first) { first = false; }
	    else { this$1.expect(types.comma); }
	    if (allowEmpty && this$1.type === types.comma) {
	      elts.push(null);
	    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
	      break
	    } else if (this$1.type === types.ellipsis) {
	      var rest = this$1.parseRestBinding();
	      this$1.parseBindingListItem(rest);
	      elts.push(rest);
	      if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
	      this$1.expect(close);
	      break
	    } else {
	      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
	      this$1.parseBindingListItem(elem);
	      elts.push(elem);
	    }
	  }
	  return elts
	};
	
	pp$2.parseBindingListItem = function(param) {
	  return param
	};
	
	// Parses assignment pattern around given atom if possible.
	
	pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
	  left = left || this.parseBindingAtom();
	  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
	  var node = this.startNodeAt(startPos, startLoc);
	  node.left = left;
	  node.right = this.parseMaybeAssign();
	  return this.finishNode(node, "AssignmentPattern")
	};
	
	// Verify that a node is an lval  something that can be assigned
	// to.
	// bindingType can be either:
	// 'var' indicating that the lval creates a 'var' binding
	// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
	// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references
	
	pp$2.checkLVal = function(expr, bindingType, checkClashes) {
	  var this$1 = this;
	
	  switch (expr.type) {
	  case "Identifier":
	    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
	      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
	    if (checkClashes) {
	      if (has(checkClashes, expr.name))
	        { this.raiseRecoverable(expr.start, "Argument name clash"); }
	      checkClashes[expr.name] = true;
	    }
	    if (bindingType && bindingType !== "none") {
	      if (
	        bindingType === "var" && !this.canDeclareVarName(expr.name) ||
	        bindingType !== "var" && !this.canDeclareLexicalName(expr.name)
	      ) {
	        this.raiseRecoverable(expr.start, ("Identifier '" + (expr.name) + "' has already been declared"));
	      }
	      if (bindingType === "var") {
	        this.declareVarName(expr.name);
	      } else {
	        this.declareLexicalName(expr.name);
	      }
	    }
	    break
	
	  case "MemberExpression":
	    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
	    break
	
	  case "ObjectPattern":
	    for (var i = 0, list = expr.properties; i < list.length; i += 1)
	      {
	    var prop = list[i];
	
	    this$1.checkLVal(prop, bindingType, checkClashes);
	  }
	    break
	
	  case "Property":
	    // AssignmentProperty has type == "Property"
	    this.checkLVal(expr.value, bindingType, checkClashes);
	    break
	
	  case "ArrayPattern":
	    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
	      var elem = list$1[i$1];
	
	    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }
	    }
	    break
	
	  case "AssignmentPattern":
	    this.checkLVal(expr.left, bindingType, checkClashes);
	    break
	
	  case "RestElement":
	    this.checkLVal(expr.argument, bindingType, checkClashes);
	    break
	
	  case "ParenthesizedExpression":
	    this.checkLVal(expr.expression, bindingType, checkClashes);
	    break
	
	  default:
	    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
	  }
	};
	
	// A recursive descent parser operates by defining functions for all
	// syntactic elements, and recursively calling those, each function
	// advancing the input stream and returning an AST node. Precedence
	// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
	// instead of `(!x)[1]` is handled by the fact that the parser
	// function that parses unary prefix operators is called first, and
	// in turn calls the function that parses `[]` subscripts  that
	// way, it'll receive the node for `x[1]` already parsed, and wraps
	// *that* in the unary operator node.
	//
	// Acorn uses an [operator precedence parser][opp] to handle binary
	// operator precedence, because it is much more compact than using
	// the technique outlined above, which uses different, nesting
	// functions to specify precedence, for all of the ten binary
	// precedence levels that JavaScript defines.
	//
	// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
	
	var pp$3 = Parser.prototype;
	
	// Check if property name clashes with already added.
	// Object/class getters and setters are not allowed to clash 
	// either with each other or with an init property  and in
	// strict mode, init properties are also not allowed to be repeated.
	
	pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
	  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
	    { return }
	  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
	    { return }
	  var key = prop.key;
	  var name;
	  switch (key.type) {
	  case "Identifier": name = key.name; break
	  case "Literal": name = String(key.value); break
	  default: return
	  }
	  var kind = prop.kind;
	  if (this.options.ecmaVersion >= 6) {
	    if (name === "__proto__" && kind === "init") {
	      if (propHash.proto) {
	        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
	        // Backwards-compat kludge. Can be removed in version 6.0
	        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
	      }
	      propHash.proto = true;
	    }
	    return
	  }
	  name = "$" + name;
	  var other = propHash[name];
	  if (other) {
	    var redefinition;
	    if (kind === "init") {
	      redefinition = this.strict && other.init || other.get || other.set;
	    } else {
	      redefinition = other.init || other[kind];
	    }
	    if (redefinition)
	      { this.raiseRecoverable(key.start, "Redefinition of property"); }
	  } else {
	    other = propHash[name] = {
	      init: false,
	      get: false,
	      set: false
	    };
	  }
	  other[kind] = true;
	};
	
	// ### Expression parsing
	
	// These nest, from the most general expression type at the top to
	// 'atomic', nondivisible expression types at the bottom. Most of
	// the functions will simply let the function(s) below them parse,
	// and, *if* the syntactic construct they handle is present, wrap
	// the AST node that the inner parser gave them in another node.
	
	// Parse a full expression. The optional arguments are used to
	// forbid the `in` operator (in for loops initalization expressions)
	// and provide reference for storing '=' operator inside shorthand
	// property assignment in contexts where both object expression
	// and object pattern might appear (so it's possible to raise
	// delayed syntax error at correct position).
	
	pp$3.parseExpression = function(noIn, refDestructuringErrors) {
	  var this$1 = this;
	
	  var startPos = this.start, startLoc = this.startLoc;
	  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
	  if (this.type === types.comma) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.expressions = [expr];
	    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }
	    return this.finishNode(node, "SequenceExpression")
	  }
	  return expr
	};
	
	// Parse an assignment expression. This includes applications of
	// operators like `+=`.
	
	pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
	  if (this.inGenerator && this.isContextual("yield")) { return this.parseYield() }
	
	  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
	  if (refDestructuringErrors) {
	    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
	    oldTrailingComma = refDestructuringErrors.trailingComma;
	    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
	  } else {
	    refDestructuringErrors = new DestructuringErrors;
	    ownDestructuringErrors = true;
	  }
	
	  var startPos = this.start, startLoc = this.startLoc;
	  if (this.type == types.parenL || this.type == types.name)
	    { this.potentialArrowAt = this.start; }
	  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
	  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
	  if (this.type.isAssign) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
	    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
	    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
	    this.checkLVal(left);
	    this.next();
	    node.right = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "AssignmentExpression")
	  } else {
	    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
	  }
	  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
	  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
	  return left
	};
	
	// Parse a ternary conditional (`?:`) operator.
	
	pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
	  var startPos = this.start, startLoc = this.startLoc;
	  var expr = this.parseExprOps(noIn, refDestructuringErrors);
	  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
	  if (this.eat(types.question)) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    this.expect(types.colon);
	    node.alternate = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "ConditionalExpression")
	  }
	  return expr
	};
	
	// Start the precedence parser.
	
	pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
	  var startPos = this.start, startLoc = this.startLoc;
	  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
	  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
	  return expr.start == startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
	};
	
	// Parse binary operators with the operator precedence parsing
	// algorithm. `left` is the left-hand side of the operator.
	// `minPrec` provides context that allows the function to stop and
	// defer further parser to one of its callers when it encounters an
	// operator that has a lower precedence than the set it is parsing.
	
	pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
	  var prec = this.type.binop;
	  if (prec != null && (!noIn || this.type !== types._in)) {
	    if (prec > minPrec) {
	      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
	      var op = this.value;
	      this.next();
	      var startPos = this.start, startLoc = this.startLoc;
	      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
	      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
	      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
	    }
	  }
	  return left
	};
	
	pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	  var node = this.startNodeAt(startPos, startLoc);
	  node.left = left;
	  node.operator = op;
	  node.right = right;
	  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
	};
	
	// Parse unary operators, both prefix and postfix.
	
	pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
	  var this$1 = this;
	
	  var startPos = this.start, startLoc = this.startLoc, expr;
	  if (this.inAsync && this.isContextual("await")) {
	    expr = this.parseAwait();
	    sawUnary = true;
	  } else if (this.type.prefix) {
	    var node = this.startNode(), update = this.type === types.incDec;
	    node.operator = this.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary(null, true);
	    this.checkExpressionErrors(refDestructuringErrors, true);
	    if (update) { this.checkLVal(node.argument); }
	    else if (this.strict && node.operator === "delete" &&
	             node.argument.type === "Identifier")
	      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
	    else { sawUnary = true; }
	    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  } else {
	    expr = this.parseExprSubscripts(refDestructuringErrors);
	    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
	    while (this.type.postfix && !this.canInsertSemicolon()) {
	      var node$1 = this$1.startNodeAt(startPos, startLoc);
	      node$1.operator = this$1.value;
	      node$1.prefix = false;
	      node$1.argument = expr;
	      this$1.checkLVal(expr);
	      this$1.next();
	      expr = this$1.finishNode(node$1, "UpdateExpression");
	    }
	  }
	
	  if (!sawUnary && this.eat(types.starstar))
	    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
	  else
	    { return expr }
	};
	
	// Parse call, dot, and `[]`-subscript expressions.
	
	pp$3.parseExprSubscripts = function(refDestructuringErrors) {
	  var startPos = this.start, startLoc = this.startLoc;
	  var expr = this.parseExprAtom(refDestructuringErrors);
	  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
	  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
	  var result = this.parseSubscripts(expr, startPos, startLoc);
	  if (refDestructuringErrors && result.type === "MemberExpression") {
	    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
	    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
	  }
	  return result
	};
	
	pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
	  var this$1 = this;
	
	  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
	      this.lastTokEnd == base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
	  for (var computed = (void 0);;) {
	    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
	      var node = this$1.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
	      node.computed = !!computed;
	      if (computed) { this$1.expect(types.bracketR); }
	      base = this$1.finishNode(node, "MemberExpression");
	    } else if (!noCalls && this$1.eat(types.parenL)) {
	      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;
	      this$1.yieldPos = 0;
	      this$1.awaitPos = 0;
	      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
	      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
	        this$1.checkPatternErrors(refDestructuringErrors, false);
	        this$1.checkYieldAwaitInDefaultParams();
	        this$1.yieldPos = oldYieldPos;
	        this$1.awaitPos = oldAwaitPos;
	        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
	      }
	      this$1.checkExpressionErrors(refDestructuringErrors, true);
	      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
	      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
	      var node$1 = this$1.startNodeAt(startPos, startLoc);
	      node$1.callee = base;
	      node$1.arguments = exprList;
	      base = this$1.finishNode(node$1, "CallExpression");
	    } else if (this$1.type === types.backQuote) {
	      var node$2 = this$1.startNodeAt(startPos, startLoc);
	      node$2.tag = base;
	      node$2.quasi = this$1.parseTemplate({isTagged: true});
	      base = this$1.finishNode(node$2, "TaggedTemplateExpression");
	    } else {
	      return base
	    }
	  }
	};
	
	// Parse an atomic expression  either a single token that is an
	// expression, an expression started by a keyword like `function` or
	// `new`, or an expression wrapped in punctuation like `()`, `[]`,
	// or `{}`.
	
	pp$3.parseExprAtom = function(refDestructuringErrors) {
	  var node, canBeArrow = this.potentialArrowAt == this.start;
	  switch (this.type) {
	  case types._super:
	    if (!this.inFunction)
	      { this.raise(this.start, "'super' outside of function or class"); }
	    node = this.startNode();
	    this.next();
	    // The `super` keyword can appear at below:
	    // SuperProperty:
	    //     super [ Expression ]
	    //     super . IdentifierName
	    // SuperCall:
	    //     super Arguments
	    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
	      { this.unexpected(); }
	    return this.finishNode(node, "Super")
	
	  case types._this:
	    node = this.startNode();
	    this.next();
	    return this.finishNode(node, "ThisExpression")
	
	  case types.name:
	    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
	    var id = this.parseIdent(this.type !== types.name);
	    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
	      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }
	    if (canBeArrow && !this.canInsertSemicolon()) {
	      if (this.eat(types.arrow))
	        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
	      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
	        id = this.parseIdent();
	        if (this.canInsertSemicolon() || !this.eat(types.arrow))
	          { this.unexpected(); }
	        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
	      }
	    }
	    return id
	
	  case types.regexp:
	    var value = this.value;
	    node = this.parseLiteral(value.value);
	    node.regex = {pattern: value.pattern, flags: value.flags};
	    return node
	
	  case types.num: case types.string:
	    return this.parseLiteral(this.value)
	
	  case types._null: case types._true: case types._false:
	    node = this.startNode();
	    node.value = this.type === types._null ? null : this.type === types._true;
	    node.raw = this.type.keyword;
	    this.next();
	    return this.finishNode(node, "Literal")
	
	  case types.parenL:
	    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
	    if (refDestructuringErrors) {
	      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
	        { refDestructuringErrors.parenthesizedAssign = start; }
	      if (refDestructuringErrors.parenthesizedBind < 0)
	        { refDestructuringErrors.parenthesizedBind = start; }
	    }
	    return expr
	
	  case types.bracketL:
	    node = this.startNode();
	    this.next();
	    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
	    return this.finishNode(node, "ArrayExpression")
	
	  case types.braceL:
	    return this.parseObj(false, refDestructuringErrors)
	
	  case types._function:
	    node = this.startNode();
	    this.next();
	    return this.parseFunction(node, false)
	
	  case types._class:
	    return this.parseClass(this.startNode(), false)
	
	  case types._new:
	    return this.parseNew()
	
	  case types.backQuote:
	    return this.parseTemplate()
	
	  default:
	    this.unexpected();
	  }
	};
	
	pp$3.parseLiteral = function(value) {
	  var node = this.startNode();
	  node.value = value;
	  node.raw = this.input.slice(this.start, this.end);
	  this.next();
	  return this.finishNode(node, "Literal")
	};
	
	pp$3.parseParenExpression = function() {
	  this.expect(types.parenL);
	  var val = this.parseExpression();
	  this.expect(types.parenR);
	  return val
	};
	
	pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
	  var this$1 = this;
	
	  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
	  if (this.options.ecmaVersion >= 6) {
	    this.next();
	
	    var innerStartPos = this.start, innerStartLoc = this.startLoc;
	    var exprList = [], first = true, lastIsComma = false;
	    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
	    this.yieldPos = 0;
	    this.awaitPos = 0;
	    while (this.type !== types.parenR) {
	      first ? first = false : this$1.expect(types.comma);
	      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
	        lastIsComma = true;
	        break
	      } else if (this$1.type === types.ellipsis) {
	        spreadStart = this$1.start;
	        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
	        if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
	        break
	      } else {
	        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
	      }
	    }
	    var innerEndPos = this.start, innerEndLoc = this.startLoc;
	    this.expect(types.parenR);
	
	    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
	      this.checkPatternErrors(refDestructuringErrors, false);
	      this.checkYieldAwaitInDefaultParams();
	      this.yieldPos = oldYieldPos;
	      this.awaitPos = oldAwaitPos;
	      return this.parseParenArrowList(startPos, startLoc, exprList)
	    }
	
	    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
	    if (spreadStart) { this.unexpected(spreadStart); }
	    this.checkExpressionErrors(refDestructuringErrors, true);
	    this.yieldPos = oldYieldPos || this.yieldPos;
	    this.awaitPos = oldAwaitPos || this.awaitPos;
	
	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartPos, innerStartLoc);
	      val.expressions = exprList;
	      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }
	  } else {
	    val = this.parseParenExpression();
	  }
	
	  if (this.options.preserveParens) {
	    var par = this.startNodeAt(startPos, startLoc);
	    par.expression = val;
	    return this.finishNode(par, "ParenthesizedExpression")
	  } else {
	    return val
	  }
	};
	
	pp$3.parseParenItem = function(item) {
	  return item
	};
	
	pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
	  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
	};
	
	// New's precedence is slightly tricky. It must allow its argument to
	// be a `[]` or dot subscript expression, but not a call  at least,
	// not without wrapping it in parentheses. Thus, it uses the noCalls
	// argument to parseSubscripts to prevent it from consuming the
	// argument list.
	
	var empty$1 = [];
	
	pp$3.parseNew = function() {
	  var node = this.startNode();
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
	    node.meta = meta;
	    var containsEsc = this.containsEsc;
	    node.property = this.parseIdent(true);
	    if (node.property.name !== "target" || containsEsc)
	      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
	    if (!this.inFunction)
	      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
	    return this.finishNode(node, "MetaProperty")
	  }
	  var startPos = this.start, startLoc = this.startLoc;
	  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
	  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
	  else { node.arguments = empty$1; }
	  return this.finishNode(node, "NewExpression")
	};
	
	// Parse template expression.
	
	pp$3.parseTemplateElement = function(ref) {
	  var isTagged = ref.isTagged;
	
	  var elem = this.startNode();
	  if (this.type === types.invalidTemplate) {
	    if (!isTagged) {
	      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
	    }
	    elem.value = {
	      raw: this.value,
	      cooked: null
	    };
	  } else {
	    elem.value = {
	      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
	      cooked: this.value
	    };
	  }
	  this.next();
	  elem.tail = this.type === types.backQuote;
	  return this.finishNode(elem, "TemplateElement")
	};
	
	pp$3.parseTemplate = function(ref) {
	  var this$1 = this;
	  if ( ref === void 0 ) ref = {};
	  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;
	
	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement({isTagged: isTagged});
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    this$1.expect(types.dollarBraceL);
	    node.expressions.push(this$1.parseExpression());
	    this$1.expect(types.braceR);
	    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));
	  }
	  this.next();
	  return this.finishNode(node, "TemplateLiteral")
	};
	
	pp$3.isAsyncProp = function(prop) {
	  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
	    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
	    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	};
	
	// Parse an object literal or binding pattern.
	
	pp$3.parseObj = function(isPattern, refDestructuringErrors) {
	  var this$1 = this;
	
	  var node = this.startNode(), first = true, propHash = {};
	  node.properties = [];
	  this.next();
	  while (!this.eat(types.braceR)) {
	    if (!first) {
	      this$1.expect(types.comma);
	      if (this$1.afterTrailingComma(types.braceR)) { break }
	    } else { first = false; }
	
	    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);
	    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }
	    node.properties.push(prop);
	  }
	  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
	};
	
	pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
	  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
	  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
	    if (isPattern) {
	      prop.argument = this.parseIdent(false);
	      if (this.type === types.comma) {
	        this.raise(this.start, "Comma is not permitted after the rest element");
	      }
	      return this.finishNode(prop, "RestElement")
	    }
	    // To disallow parenthesized identifier via `this.toAssignable()`.
	    if (this.type === types.parenL && refDestructuringErrors) {
	      if (refDestructuringErrors.parenthesizedAssign < 0) {
	        refDestructuringErrors.parenthesizedAssign = this.start;
	      }
	      if (refDestructuringErrors.parenthesizedBind < 0) {
	        refDestructuringErrors.parenthesizedBind = this.start;
	      }
	    }
	    // Parse argument.
	    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	    // To disallow trailing comma via `this.toAssignable()`.
	    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
	      refDestructuringErrors.trailingComma = this.start;
	    }
	    // Finish
	    return this.finishNode(prop, "SpreadElement")
	  }
	  if (this.options.ecmaVersion >= 6) {
	    prop.method = false;
	    prop.shorthand = false;
	    if (isPattern || refDestructuringErrors) {
	      startPos = this.start;
	      startLoc = this.startLoc;
	    }
	    if (!isPattern)
	      { isGenerator = this.eat(types.star); }
	  }
	  var containsEsc = this.containsEsc;
	  this.parsePropertyName(prop);
	  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
	    isAsync = true;
	    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
	    this.parsePropertyName(prop, refDestructuringErrors);
	  } else {
	    isAsync = false;
	  }
	  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
	  return this.finishNode(prop, "Property")
	};
	
	pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
	  if ((isGenerator || isAsync) && this.type === types.colon)
	    { this.unexpected(); }
	
	  if (this.eat(types.colon)) {
	    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
	    prop.kind = "init";
	  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
	    if (isPattern) { this.unexpected(); }
	    prop.kind = "init";
	    prop.method = true;
	    prop.value = this.parseMethod(isGenerator, isAsync);
	  } else if (!isPattern && !containsEsc &&
	             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
	             (prop.key.name === "get" || prop.key.name === "set") &&
	             (this.type != types.comma && this.type != types.braceR)) {
	    if (isGenerator || isAsync) { this.unexpected(); }
	    prop.kind = prop.key.name;
	    this.parsePropertyName(prop);
	    prop.value = this.parseMethod(false);
	    var paramCount = prop.kind === "get" ? 0 : 1;
	    if (prop.value.params.length !== paramCount) {
	      var start = prop.value.start;
	      if (prop.kind === "get")
	        { this.raiseRecoverable(start, "getter should have no params"); }
	      else
	        { this.raiseRecoverable(start, "setter should have exactly one param"); }
	    } else {
	      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
	        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
	    }
	  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	    this.checkUnreserved(prop.key);
	    prop.kind = "init";
	    if (isPattern) {
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else if (this.type === types.eq && refDestructuringErrors) {
	      if (refDestructuringErrors.shorthandAssign < 0)
	        { refDestructuringErrors.shorthandAssign = this.start; }
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else {
	      prop.value = prop.key;
	    }
	    prop.shorthand = true;
	  } else { this.unexpected(); }
	};
	
	pp$3.parsePropertyName = function(prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(types.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssign();
	      this.expect(types.bracketR);
	      return prop.key
	    } else {
	      prop.computed = false;
	    }
	  }
	  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)
	};
	
	// Initialize empty function node.
	
	pp$3.initFunction = function(node) {
	  node.id = null;
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = false;
	    node.expression = false;
	  }
	  if (this.options.ecmaVersion >= 8)
	    { node.async = false; }
	};
	
	// Parse object or class method.
	
	pp$3.parseMethod = function(isGenerator, isAsync) {
	  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
	      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
	
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 6)
	    { node.generator = isGenerator; }
	  if (this.options.ecmaVersion >= 8)
	    { node.async = !!isAsync; }
	
	  this.inGenerator = node.generator;
	  this.inAsync = node.async;
	  this.yieldPos = 0;
	  this.awaitPos = 0;
	  this.inFunction = true;
	  this.enterFunctionScope();
	
	  this.expect(types.parenL);
	  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
	  this.checkYieldAwaitInDefaultParams();
	  this.parseFunctionBody(node, false);
	
	  this.inGenerator = oldInGen;
	  this.inAsync = oldInAsync;
	  this.yieldPos = oldYieldPos;
	  this.awaitPos = oldAwaitPos;
	  this.inFunction = oldInFunc;
	  return this.finishNode(node, "FunctionExpression")
	};
	
	// Parse arrow function expression with given parameters.
	
	pp$3.parseArrowExpression = function(node, params, isAsync) {
	  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
	      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
	
	  this.enterFunctionScope();
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 8)
	    { node.async = !!isAsync; }
	
	  this.inGenerator = false;
	  this.inAsync = node.async;
	  this.yieldPos = 0;
	  this.awaitPos = 0;
	  this.inFunction = true;
	
	  node.params = this.toAssignableList(params, true);
	  this.parseFunctionBody(node, true);
	
	  this.inGenerator = oldInGen;
	  this.inAsync = oldInAsync;
	  this.yieldPos = oldYieldPos;
	  this.awaitPos = oldAwaitPos;
	  this.inFunction = oldInFunc;
	  return this.finishNode(node, "ArrowFunctionExpression")
	};
	
	// Parse function body and check parameters.
	
	pp$3.parseFunctionBody = function(node, isArrowFunction) {
	  var isExpression = isArrowFunction && this.type !== types.braceL;
	  var oldStrict = this.strict, useStrict = false;
	
	  if (isExpression) {
	    node.body = this.parseMaybeAssign();
	    node.expression = true;
	    this.checkParams(node, false);
	  } else {
	    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
	    if (!oldStrict || nonSimple) {
	      useStrict = this.strictDirective(this.end);
	      // If this is a strict mode function, verify that argument names
	      // are not repeated, and it does not try to bind the words `eval`
	      // or `arguments`.
	      if (useStrict && nonSimple)
	        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
	    }
	    // Start a new scope with regard to labels and the `inFunction`
	    // flag (restore them to their old value afterwards).
	    var oldLabels = this.labels;
	    this.labels = [];
	    if (useStrict) { this.strict = true; }
	
	    // Add the params to varDeclaredNames to ensure that an error is thrown
	    // if a let/const declaration in the function clashes with one of the params.
	    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
	    node.body = this.parseBlock(false);
	    node.expression = false;
	    this.adaptDirectivePrologue(node.body.body);
	    this.labels = oldLabels;
	  }
	  this.exitFunctionScope();
	
	  if (this.strict && node.id) {
	    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
	    this.checkLVal(node.id, "none");
	  }
	  this.strict = oldStrict;
	};
	
	pp$3.isSimpleParamList = function(params) {
	  for (var i = 0, list = params; i < list.length; i += 1)
	    {
	    var param = list[i];
	
	    if (param.type !== "Identifier") { return false
	  } }
	  return true
	};
	
	// Checks function params for various disallowed patterns such as using "eval"
	// or "arguments" and duplicate parameters.
	
	pp$3.checkParams = function(node, allowDuplicates) {
	  var this$1 = this;
	
	  var nameHash = {};
	  for (var i = 0, list = node.params; i < list.length; i += 1)
	    {
	    var param = list[i];
	
	    this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
	  }
	};
	
	// Parses a comma-separated list of expressions, and returns them as
	// an array. `close` is the token type that ends the list, and
	// `allowEmpty` can be turned on to allow subsequent commas with
	// nothing in between them to be parsed as `null` (which is needed
	// for array literals).
	
	pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	  var this$1 = this;
	
	  var elts = [], first = true;
	  while (!this.eat(close)) {
	    if (!first) {
	      this$1.expect(types.comma);
	      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }
	    } else { first = false; }
	
	    var elt = (void 0);
	    if (allowEmpty && this$1.type === types.comma)
	      { elt = null; }
	    else if (this$1.type === types.ellipsis) {
	      elt = this$1.parseSpread(refDestructuringErrors);
	      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)
	        { refDestructuringErrors.trailingComma = this$1.start; }
	    } else {
	      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
	    }
	    elts.push(elt);
	  }
	  return elts
	};
	
	pp$3.checkUnreserved = function(ref) {
	  var start = ref.start;
	  var end = ref.end;
	  var name = ref.name;
	
	  if (this.inGenerator && name === "yield")
	    { this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator"); }
	  if (this.inAsync && name === "await")
	    { this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function"); }
	  if (this.isKeyword(name))
	    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
	  if (this.options.ecmaVersion < 6 &&
	    this.input.slice(start, end).indexOf("\\") != -1) { return }
	  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
	  if (re.test(name)) {
	    if (!this.inAsync && name === "await")
	      { this.raiseRecoverable(start, "Can not use keyword 'await' outside an async function"); }
	    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
	  }
	};
	
	// Parse the next token as an identifier. If `liberal` is true (used
	// when parsing properties), it will also convert keywords into
	// identifiers.
	
	pp$3.parseIdent = function(liberal, isBinding) {
	  var node = this.startNode();
	  if (liberal && this.options.allowReserved == "never") { liberal = false; }
	  if (this.type === types.name) {
	    node.name = this.value;
	  } else if (this.type.keyword) {
	    node.name = this.type.keyword;
	
	    // To fix https://github.com/acornjs/acorn/issues/575
	    // `class` and `function` keywords push new context into this.context.
	    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
	    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
	    if ((node.name === "class" || node.name === "function") &&
	        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
	      this.context.pop();
	    }
	  } else {
	    this.unexpected();
	  }
	  this.next();
	  this.finishNode(node, "Identifier");
	  if (!liberal) { this.checkUnreserved(node); }
	  return node
	};
	
	// Parses yield expression inside generator.
	
	pp$3.parseYield = function() {
	  if (!this.yieldPos) { this.yieldPos = this.start; }
	
	  var node = this.startNode();
	  this.next();
	  if (this.type == types.semi || this.canInsertSemicolon() || (this.type != types.star && !this.type.startsExpr)) {
	    node.delegate = false;
	    node.argument = null;
	  } else {
	    node.delegate = this.eat(types.star);
	    node.argument = this.parseMaybeAssign();
	  }
	  return this.finishNode(node, "YieldExpression")
	};
	
	pp$3.parseAwait = function() {
	  if (!this.awaitPos) { this.awaitPos = this.start; }
	
	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeUnary(null, true);
	  return this.finishNode(node, "AwaitExpression")
	};
	
	var pp$4 = Parser.prototype;
	
	// This function is used to raise exceptions on parse errors. It
	// takes an offset integer (into the current `input`) to indicate
	// the location of the error, attaches the position to the end
	// of the error message, and then raises a `SyntaxError` with that
	// message.
	
	pp$4.raise = function(pos, message) {
	  var loc = getLineInfo(this.input, pos);
	  message += " (" + loc.line + ":" + loc.column + ")";
	  var err = new SyntaxError(message);
	  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
	  throw err
	};
	
	pp$4.raiseRecoverable = pp$4.raise;
	
	pp$4.curPosition = function() {
	  if (this.options.locations) {
	    return new Position(this.curLine, this.pos - this.lineStart)
	  }
	};
	
	var pp$5 = Parser.prototype;
	
	// Object.assign polyfill
	var assign = Object.assign || function(target) {
	  var sources = [], len = arguments.length - 1;
	  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];
	
	  for (var i = 0, list = sources; i < list.length; i += 1) {
	    var source = list[i];
	
	    for (var key in source) {
	      if (has(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	  return target
	};
	
	// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
	
	pp$5.enterFunctionScope = function() {
	  // var: a hash of var-declared names in the current lexical scope
	  // lexical: a hash of lexically-declared names in the current lexical scope
	  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
	  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
	  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});
	};
	
	pp$5.exitFunctionScope = function() {
	  this.scopeStack.pop();
	};
	
	pp$5.enterLexicalScope = function() {
	  var parentScope = this.scopeStack[this.scopeStack.length - 1];
	  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};
	
	  this.scopeStack.push(childScope);
	  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
	};
	
	pp$5.exitLexicalScope = function() {
	  var childScope = this.scopeStack.pop();
	  var parentScope = this.scopeStack[this.scopeStack.length - 1];
	
	  assign(parentScope.childVar, childScope.var, childScope.childVar);
	};
	
	/**
	 * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
	 * in the current lexical scope or any of the parent lexical scopes in this function.
	 */
	pp$5.canDeclareVarName = function(name) {
	  var currentScope = this.scopeStack[this.scopeStack.length - 1];
	
	  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)
	};
	
	/**
	 * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
	 * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
	 * any child lexical scopes in this function.
	 */
	pp$5.canDeclareLexicalName = function(name) {
	  var currentScope = this.scopeStack[this.scopeStack.length - 1];
	
	  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)
	};
	
	pp$5.declareVarName = function(name) {
	  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
	};
	
	pp$5.declareLexicalName = function(name) {
	  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
	};
	
	var Node = function Node(parser, pos, loc) {
	  this.type = "";
	  this.start = pos;
	  this.end = 0;
	  if (parser.options.locations)
	    { this.loc = new SourceLocation(parser, loc); }
	  if (parser.options.directSourceFile)
	    { this.sourceFile = parser.options.directSourceFile; }
	  if (parser.options.ranges)
	    { this.range = [pos, 0]; }
	};
	
	// Start an AST node, attaching a start offset.
	
	var pp$6 = Parser.prototype;
	
	pp$6.startNode = function() {
	  return new Node(this, this.start, this.startLoc)
	};
	
	pp$6.startNodeAt = function(pos, loc) {
	  return new Node(this, pos, loc)
	};
	
	// Finish an AST node, adding `type` and `end` properties.
	
	function finishNodeAt(node, type, pos, loc) {
	  node.type = type;
	  node.end = pos;
	  if (this.options.locations)
	    { node.loc.end = loc; }
	  if (this.options.ranges)
	    { node.range[1] = pos; }
	  return node
	}
	
	pp$6.finishNode = function(node, type) {
	  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
	};
	
	// Finish node at given position
	
	pp$6.finishNodeAt = function(node, type, pos, loc) {
	  return finishNodeAt.call(this, node, type, pos, loc)
	};
	
	// The algorithm used to determine whether a regexp can appear at a
	// given point in the program is loosely based on sweet.js' approach.
	// See https://github.com/mozilla/sweet.js/wiki/design
	
	var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
	  this.token = token;
	  this.isExpr = !!isExpr;
	  this.preserveSpace = !!preserveSpace;
	  this.override = override;
	  this.generator = !!generator;
	};
	
	var types$1 = {
	  b_stat: new TokContext("{", false),
	  b_expr: new TokContext("{", true),
	  b_tmpl: new TokContext("${", false),
	  p_stat: new TokContext("(", false),
	  p_expr: new TokContext("(", true),
	  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
	  f_stat: new TokContext("function", false),
	  f_expr: new TokContext("function", true),
	  f_expr_gen: new TokContext("function", true, false, null, true),
	  f_gen: new TokContext("function", false, false, null, true)
	};
	
	var pp$7 = Parser.prototype;
	
	pp$7.initialContext = function() {
	  return [types$1.b_stat]
	};
	
	pp$7.braceIsBlock = function(prevType) {
	  var parent = this.curContext();
	  if (parent === types$1.f_expr || parent === types$1.f_stat)
	    { return true }
	  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
	    { return !parent.isExpr }
	
	  // The check for `tt.name && exprAllowed` detects whether we are
	  // after a `yield` or `of` construct. See the `updateContext` for
	  // `tt.name`.
	  if (prevType === types._return || prevType == types.name && this.exprAllowed)
	    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
	  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow)
	    { return true }
	  if (prevType == types.braceL)
	    { return parent === types$1.b_stat }
	  if (prevType == types._var || prevType == types.name)
	    { return false }
	  return !this.exprAllowed
	};
	
	pp$7.inGeneratorContext = function() {
	  var this$1 = this;
	
	  for (var i = this.context.length - 1; i >= 1; i--) {
	    var context = this$1.context[i];
	    if (context.token === "function")
	      { return context.generator }
	  }
	  return false
	};
	
	pp$7.updateContext = function(prevType) {
	  var update, type = this.type;
	  if (type.keyword && prevType == types.dot)
	    { this.exprAllowed = false; }
	  else if (update = type.updateContext)
	    { update.call(this, prevType); }
	  else
	    { this.exprAllowed = type.beforeExpr; }
	};
	
	// Token-specific context update code
	
	types.parenR.updateContext = types.braceR.updateContext = function() {
	  if (this.context.length == 1) {
	    this.exprAllowed = true;
	    return
	  }
	  var out = this.context.pop();
	  if (out === types$1.b_stat && this.curContext().token === "function") {
	    out = this.context.pop();
	  }
	  this.exprAllowed = !out.isExpr;
	};
	
	types.braceL.updateContext = function(prevType) {
	  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
	  this.exprAllowed = true;
	};
	
	types.dollarBraceL.updateContext = function() {
	  this.context.push(types$1.b_tmpl);
	  this.exprAllowed = true;
	};
	
	types.parenL.updateContext = function(prevType) {
	  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
	  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
	  this.exprAllowed = true;
	};
	
	types.incDec.updateContext = function() {
	  // tokExprAllowed stays unchanged
	};
	
	types._function.updateContext = types._class.updateContext = function(prevType) {
	  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
	      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
	    { this.context.push(types$1.f_expr); }
	  else
	    { this.context.push(types$1.f_stat); }
	  this.exprAllowed = false;
	};
	
	types.backQuote.updateContext = function() {
	  if (this.curContext() === types$1.q_tmpl)
	    { this.context.pop(); }
	  else
	    { this.context.push(types$1.q_tmpl); }
	  this.exprAllowed = false;
	};
	
	types.star.updateContext = function(prevType) {
	  if (prevType == types._function) {
	    var index = this.context.length - 1;
	    if (this.context[index] === types$1.f_expr)
	      { this.context[index] = types$1.f_expr_gen; }
	    else
	      { this.context[index] = types$1.f_gen; }
	  }
	  this.exprAllowed = true;
	};
	
	types.name.updateContext = function(prevType) {
	  var allowed = false;
	  if (this.options.ecmaVersion >= 6) {
	    if (this.value == "of" && !this.exprAllowed ||
	        this.value == "yield" && this.inGeneratorContext())
	      { allowed = true; }
	  }
	  this.exprAllowed = allowed;
	};
	
	var data = {
	  "$LONE": [
	    "ASCII",
	    "ASCII_Hex_Digit",
	    "AHex",
	    "Alphabetic",
	    "Alpha",
	    "Any",
	    "Assigned",
	    "Bidi_Control",
	    "Bidi_C",
	    "Bidi_Mirrored",
	    "Bidi_M",
	    "Case_Ignorable",
	    "CI",
	    "Cased",
	    "Changes_When_Casefolded",
	    "CWCF",
	    "Changes_When_Casemapped",
	    "CWCM",
	    "Changes_When_Lowercased",
	    "CWL",
	    "Changes_When_NFKC_Casefolded",
	    "CWKCF",
	    "Changes_When_Titlecased",
	    "CWT",
	    "Changes_When_Uppercased",
	    "CWU",
	    "Dash",
	    "Default_Ignorable_Code_Point",
	    "DI",
	    "Deprecated",
	    "Dep",
	    "Diacritic",
	    "Dia",
	    "Emoji",
	    "Emoji_Component",
	    "Emoji_Modifier",
	    "Emoji_Modifier_Base",
	    "Emoji_Presentation",
	    "Extender",
	    "Ext",
	    "Grapheme_Base",
	    "Gr_Base",
	    "Grapheme_Extend",
	    "Gr_Ext",
	    "Hex_Digit",
	    "Hex",
	    "IDS_Binary_Operator",
	    "IDSB",
	    "IDS_Trinary_Operator",
	    "IDST",
	    "ID_Continue",
	    "IDC",
	    "ID_Start",
	    "IDS",
	    "Ideographic",
	    "Ideo",
	    "Join_Control",
	    "Join_C",
	    "Logical_Order_Exception",
	    "LOE",
	    "Lowercase",
	    "Lower",
	    "Math",
	    "Noncharacter_Code_Point",
	    "NChar",
	    "Pattern_Syntax",
	    "Pat_Syn",
	    "Pattern_White_Space",
	    "Pat_WS",
	    "Quotation_Mark",
	    "QMark",
	    "Radical",
	    "Regional_Indicator",
	    "RI",
	    "Sentence_Terminal",
	    "STerm",
	    "Soft_Dotted",
	    "SD",
	    "Terminal_Punctuation",
	    "Term",
	    "Unified_Ideograph",
	    "UIdeo",
	    "Uppercase",
	    "Upper",
	    "Variation_Selector",
	    "VS",
	    "White_Space",
	    "space",
	    "XID_Continue",
	    "XIDC",
	    "XID_Start",
	    "XIDS"
	  ],
	  "General_Category": [
	    "Cased_Letter",
	    "LC",
	    "Close_Punctuation",
	    "Pe",
	    "Connector_Punctuation",
	    "Pc",
	    "Control",
	    "Cc",
	    "cntrl",
	    "Currency_Symbol",
	    "Sc",
	    "Dash_Punctuation",
	    "Pd",
	    "Decimal_Number",
	    "Nd",
	    "digit",
	    "Enclosing_Mark",
	    "Me",
	    "Final_Punctuation",
	    "Pf",
	    "Format",
	    "Cf",
	    "Initial_Punctuation",
	    "Pi",
	    "Letter",
	    "L",
	    "Letter_Number",
	    "Nl",
	    "Line_Separator",
	    "Zl",
	    "Lowercase_Letter",
	    "Ll",
	    "Mark",
	    "M",
	    "Combining_Mark",
	    "Math_Symbol",
	    "Sm",
	    "Modifier_Letter",
	    "Lm",
	    "Modifier_Symbol",
	    "Sk",
	    "Nonspacing_Mark",
	    "Mn",
	    "Number",
	    "N",
	    "Open_Punctuation",
	    "Ps",
	    "Other",
	    "C",
	    "Other_Letter",
	    "Lo",
	    "Other_Number",
	    "No",
	    "Other_Punctuation",
	    "Po",
	    "Other_Symbol",
	    "So",
	    "Paragraph_Separator",
	    "Zp",
	    "Private_Use",
	    "Co",
	    "Punctuation",
	    "P",
	    "punct",
	    "Separator",
	    "Z",
	    "Space_Separator",
	    "Zs",
	    "Spacing_Mark",
	    "Mc",
	    "Surrogate",
	    "Cs",
	    "Symbol",
	    "S",
	    "Titlecase_Letter",
	    "Lt",
	    "Unassigned",
	    "Cn",
	    "Uppercase_Letter",
	    "Lu"
	  ],
	  "Script": [
	    "Adlam",
	    "Adlm",
	    "Ahom",
	    "Anatolian_Hieroglyphs",
	    "Hluw",
	    "Arabic",
	    "Arab",
	    "Armenian",
	    "Armn",
	    "Avestan",
	    "Avst",
	    "Balinese",
	    "Bali",
	    "Bamum",
	    "Bamu",
	    "Bassa_Vah",
	    "Bass",
	    "Batak",
	    "Batk",
	    "Bengali",
	    "Beng",
	    "Bhaiksuki",
	    "Bhks",
	    "Bopomofo",
	    "Bopo",
	    "Brahmi",
	    "Brah",
	    "Braille",
	    "Brai",
	    "Buginese",
	    "Bugi",
	    "Buhid",
	    "Buhd",
	    "Canadian_Aboriginal",
	    "Cans",
	    "Carian",
	    "Cari",
	    "Caucasian_Albanian",
	    "Aghb",
	    "Chakma",
	    "Cakm",
	    "Cham",
	    "Cherokee",
	    "Cher",
	    "Common",
	    "Zyyy",
	    "Coptic",
	    "Copt",
	    "Qaac",
	    "Cuneiform",
	    "Xsux",
	    "Cypriot",
	    "Cprt",
	    "Cyrillic",
	    "Cyrl",
	    "Deseret",
	    "Dsrt",
	    "Devanagari",
	    "Deva",
	    "Duployan",
	    "Dupl",
	    "Egyptian_Hieroglyphs",
	    "Egyp",
	    "Elbasan",
	    "Elba",
	    "Ethiopic",
	    "Ethi",
	    "Georgian",
	    "Geor",
	    "Glagolitic",
	    "Glag",
	    "Gothic",
	    "Goth",
	    "Grantha",
	    "Gran",
	    "Greek",
	    "Grek",
	    "Gujarati",
	    "Gujr",
	    "Gurmukhi",
	    "Guru",
	    "Han",
	    "Hani",
	    "Hangul",
	    "Hang",
	    "Hanunoo",
	    "Hano",
	    "Hatran",
	    "Hatr",
	    "Hebrew",
	    "Hebr",
	    "Hiragana",
	    "Hira",
	    "Imperial_Aramaic",
	    "Armi",
	    "Inherited",
	    "Zinh",
	    "Qaai",
	    "Inscriptional_Pahlavi",
	    "Phli",
	    "Inscriptional_Parthian",
	    "Prti",
	    "Javanese",
	    "Java",
	    "Kaithi",
	    "Kthi",
	    "Kannada",
	    "Knda",
	    "Katakana",
	    "Kana",
	    "Kayah_Li",
	    "Kali",
	    "Kharoshthi",
	    "Khar",
	    "Khmer",
	    "Khmr",
	    "Khojki",
	    "Khoj",
	    "Khudawadi",
	    "Sind",
	    "Lao",
	    "Laoo",
	    "Latin",
	    "Latn",
	    "Lepcha",
	    "Lepc",
	    "Limbu",
	    "Limb",
	    "Linear_A",
	    "Lina",
	    "Linear_B",
	    "Linb",
	    "Lisu",
	    "Lycian",
	    "Lyci",
	    "Lydian",
	    "Lydi",
	    "Mahajani",
	    "Mahj",
	    "Malayalam",
	    "Mlym",
	    "Mandaic",
	    "Mand",
	    "Manichaean",
	    "Mani",
	    "Marchen",
	    "Marc",
	    "Masaram_Gondi",
	    "Gonm",
	    "Meetei_Mayek",
	    "Mtei",
	    "Mende_Kikakui",
	    "Mend",
	    "Meroitic_Cursive",
	    "Merc",
	    "Meroitic_Hieroglyphs",
	    "Mero",
	    "Miao",
	    "Plrd",
	    "Modi",
	    "Mongolian",
	    "Mong",
	    "Mro",
	    "Mroo",
	    "Multani",
	    "Mult",
	    "Myanmar",
	    "Mymr",
	    "Nabataean",
	    "Nbat",
	    "New_Tai_Lue",
	    "Talu",
	    "Newa",
	    "Nko",
	    "Nkoo",
	    "Nushu",
	    "Nshu",
	    "Ogham",
	    "Ogam",
	    "Ol_Chiki",
	    "Olck",
	    "Old_Hungarian",
	    "Hung",
	    "Old_Italic",
	    "Ital",
	    "Old_North_Arabian",
	    "Narb",
	    "Old_Permic",
	    "Perm",
	    "Old_Persian",
	    "Xpeo",
	    "Old_South_Arabian",
	    "Sarb",
	    "Old_Turkic",
	    "Orkh",
	    "Oriya",
	    "Orya",
	    "Osage",
	    "Osge",
	    "Osmanya",
	    "Osma",
	    "Pahawh_Hmong",
	    "Hmng",
	    "Palmyrene",
	    "Palm",
	    "Pau_Cin_Hau",
	    "Pauc",
	    "Phags_Pa",
	    "Phag",
	    "Phoenician",
	    "Phnx",
	    "Psalter_Pahlavi",
	    "Phlp",
	    "Rejang",
	    "Rjng",
	    "Runic",
	    "Runr",
	    "Samaritan",
	    "Samr",
	    "Saurashtra",
	    "Saur",
	    "Sharada",
	    "Shrd",
	    "Shavian",
	    "Shaw",
	    "Siddham",
	    "Sidd",
	    "SignWriting",
	    "Sgnw",
	    "Sinhala",
	    "Sinh",
	    "Sora_Sompeng",
	    "Sora",
	    "Soyombo",
	    "Soyo",
	    "Sundanese",
	    "Sund",
	    "Syloti_Nagri",
	    "Sylo",
	    "Syriac",
	    "Syrc",
	    "Tagalog",
	    "Tglg",
	    "Tagbanwa",
	    "Tagb",
	    "Tai_Le",
	    "Tale",
	    "Tai_Tham",
	    "Lana",
	    "Tai_Viet",
	    "Tavt",
	    "Takri",
	    "Takr",
	    "Tamil",
	    "Taml",
	    "Tangut",
	    "Tang",
	    "Telugu",
	    "Telu",
	    "Thaana",
	    "Thaa",
	    "Thai",
	    "Tibetan",
	    "Tibt",
	    "Tifinagh",
	    "Tfng",
	    "Tirhuta",
	    "Tirh",
	    "Ugaritic",
	    "Ugar",
	    "Vai",
	    "Vaii",
	    "Warang_Citi",
	    "Wara",
	    "Yi",
	    "Yiii",
	    "Zanabazar_Square",
	    "Zanb"
	  ]
	};
	Array.prototype.push.apply(data.$LONE, data.General_Category);
	data.gc = data.General_Category;
	data.sc = data.Script_Extensions = data.scx = data.Script;
	
	var pp$9 = Parser.prototype;
	
	var RegExpValidationState = function RegExpValidationState(parser) {
	  this.parser = parser;
	  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
	  this.source = "";
	  this.flags = "";
	  this.start = 0;
	  this.switchU = false;
	  this.switchN = false;
	  this.pos = 0;
	  this.lastIntValue = 0;
	  this.lastStringValue = "";
	  this.lastAssertionIsQuantifiable = false;
	  this.numCapturingParens = 0;
	  this.maxBackReference = 0;
	  this.groupNames = [];
	  this.backReferenceNames = [];
	};
	
	RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
	  var unicode = flags.indexOf("u") !== -1;
	  this.start = start | 0;
	  this.source = pattern + "";
	  this.flags = flags;
	  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
	  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
	};
	
	RegExpValidationState.prototype.raise = function raise (message) {
	  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
	};
	
	// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
	// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
	RegExpValidationState.prototype.at = function at (i) {
	  var s = this.source;
	  var l = s.length;
	  if (i >= l) {
	    return -1
	  }
	  var c = s.charCodeAt(i);
	  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
	    return c
	  }
	  return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00
	};
	
	RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
	  var s = this.source;
	  var l = s.length;
	  if (i >= l) {
	    return l
	  }
	  var c = s.charCodeAt(i);
	  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
	    return i + 1
	  }
	  return i + 2
	};
	
	RegExpValidationState.prototype.current = function current () {
	  return this.at(this.pos)
	};
	
	RegExpValidationState.prototype.lookahead = function lookahead () {
	  return this.at(this.nextIndex(this.pos))
	};
	
	RegExpValidationState.prototype.advance = function advance () {
	  this.pos = this.nextIndex(this.pos);
	};
	
	RegExpValidationState.prototype.eat = function eat (ch) {
	  if (this.current() === ch) {
	    this.advance();
	    return true
	  }
	  return false
	};
	
	function codePointToString$1(ch) {
	  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
	  ch -= 0x10000;
	  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
	}
	
	/**
	 * Validate the flags part of a given RegExpLiteral.
	 *
	 * @param {RegExpValidationState} state The state to validate RegExp.
	 * @returns {void}
	 */
	pp$9.validateRegExpFlags = function(state) {
	  var this$1 = this;
	
	  var validFlags = state.validFlags;
	  var flags = state.flags;
	
	  for (var i = 0; i < flags.length; i++) {
	    var flag = flags.charAt(i);
	    if (validFlags.indexOf(flag) == -1) {
	      this$1.raise(state.start, "Invalid regular expression flag");
	    }
	    if (flags.indexOf(flag, i + 1) > -1) {
	      this$1.raise(state.start, "Duplicate regular expression flag");
	    }
	  }
	};
	
	/**
	 * Validate the pattern part of a given RegExpLiteral.
	 *
	 * @param {RegExpValidationState} state The state to validate RegExp.
	 * @returns {void}
	 */
	pp$9.validateRegExpPattern = function(state) {
	  this.regexp_pattern(state);
	
	  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
	  // parsing contains a |GroupName|, reparse with the goal symbol
	  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
	  // exception if _P_ did not conform to the grammar, if any elements of _P_
	  // were not matched by the parse, or if any Early Error conditions exist.
	  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
	    state.switchN = true;
	    this.regexp_pattern(state);
	  }
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
	pp$9.regexp_pattern = function(state) {
	  state.pos = 0;
	  state.lastIntValue = 0;
	  state.lastStringValue = "";
	  state.lastAssertionIsQuantifiable = false;
	  state.numCapturingParens = 0;
	  state.maxBackReference = 0;
	  state.groupNames.length = 0;
	  state.backReferenceNames.length = 0;
	
	  this.regexp_disjunction(state);
	
	  if (state.pos !== state.source.length) {
	    // Make the same messages as V8.
	    if (state.eat(0x29 /* ) */)) {
	      state.raise("Unmatched ')'");
	    }
	    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
	      state.raise("Lone quantifier brackets");
	    }
	  }
	  if (state.maxBackReference > state.numCapturingParens) {
	    state.raise("Invalid escape");
	  }
	  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
	    var name = list[i];
	
	    if (state.groupNames.indexOf(name) === -1) {
	      state.raise("Invalid named capture referenced");
	    }
	  }
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
	pp$9.regexp_disjunction = function(state) {
	  var this$1 = this;
	
	  this.regexp_alternative(state);
	  while (state.eat(0x7C /* | */)) {
	    this$1.regexp_alternative(state);
	  }
	
	  // Make the same message as V8.
	  if (this.regexp_eatQuantifier(state, true)) {
	    state.raise("Nothing to repeat");
	  }
	  if (state.eat(0x7B /* { */)) {
	    state.raise("Lone quantifier brackets");
	  }
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
	pp$9.regexp_alternative = function(state) {
	  while (state.pos < state.source.length && this.regexp_eatTerm(state))
	    {  }
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
	pp$9.regexp_eatTerm = function(state) {
	  if (this.regexp_eatAssertion(state)) {
	    // Handle `QuantifiableAssertion Quantifier` alternative.
	    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
	    // is a QuantifiableAssertion.
	    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
	      // Make the same message as V8.
	      if (state.switchU) {
	        state.raise("Invalid quantifier");
	      }
	    }
	    return true
	  }
	
	  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
	    this.regexp_eatQuantifier(state);
	    return true
	  }
	
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
	pp$9.regexp_eatAssertion = function(state) {
	  var start = state.pos;
	  state.lastAssertionIsQuantifiable = false;
	
	  // ^, $
	  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
	    return true
	  }
	
	  // \b \B
	  if (state.eat(0x5C /* \ */)) {
	    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
	      return true
	    }
	    state.pos = start;
	  }
	
	  // Lookahead / Lookbehind
	  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
	    var lookbehind = false;
	    if (this.options.ecmaVersion >= 9) {
	      lookbehind = state.eat(0x3C /* < */);
	    }
	    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
	      this.regexp_disjunction(state);
	      if (!state.eat(0x29 /* ) */)) {
	        state.raise("Unterminated group");
	      }
	      state.lastAssertionIsQuantifiable = !lookbehind;
	      return true
	    }
	  }
	
	  state.pos = start;
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
	pp$9.regexp_eatQuantifier = function(state, noError) {
	  if ( noError === void 0 ) noError = false;
	
	  if (this.regexp_eatQuantifierPrefix(state, noError)) {
	    state.eat(0x3F /* ? */);
	    return true
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
	pp$9.regexp_eatQuantifierPrefix = function(state, noError) {
	  return (
	    state.eat(0x2A /* * */) ||
	    state.eat(0x2B /* + */) ||
	    state.eat(0x3F /* ? */) ||
	    this.regexp_eatBracedQuantifier(state, noError)
	  )
	};
	pp$9.regexp_eatBracedQuantifier = function(state, noError) {
	  var start = state.pos;
	  if (state.eat(0x7B /* { */)) {
	    var min = 0, max = -1;
	    if (this.regexp_eatDecimalDigits(state)) {
	      min = state.lastIntValue;
	      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
	        max = state.lastIntValue;
	      }
	      if (state.eat(0x7D /* } */)) {
	        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
	        if (max !== -1 && max < min && !noError) {
	          state.raise("numbers out of order in {} quantifier");
	        }
	        return true
	      }
	    }
	    if (state.switchU && !noError) {
	      state.raise("Incomplete quantifier");
	    }
	    state.pos = start;
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
	pp$9.regexp_eatAtom = function(state) {
	  return (
	    this.regexp_eatPatternCharacters(state) ||
	    state.eat(0x2E /* . */) ||
	    this.regexp_eatReverseSolidusAtomEscape(state) ||
	    this.regexp_eatCharacterClass(state) ||
	    this.regexp_eatUncapturingGroup(state) ||
	    this.regexp_eatCapturingGroup(state)
	  )
	};
	pp$9.regexp_eatReverseSolidusAtomEscape = function(state) {
	  var start = state.pos;
	  if (state.eat(0x5C /* \ */)) {
	    if (this.regexp_eatAtomEscape(state)) {
	      return true
	    }
	    state.pos = start;
	  }
	  return false
	};
	pp$9.regexp_eatUncapturingGroup = function(state) {
	  var start = state.pos;
	  if (state.eat(0x28 /* ( */)) {
	    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
	      this.regexp_disjunction(state);
	      if (state.eat(0x29 /* ) */)) {
	        return true
	      }
	      state.raise("Unterminated group");
	    }
	    state.pos = start;
	  }
	  return false
	};
	pp$9.regexp_eatCapturingGroup = function(state) {
	  if (state.eat(0x28 /* ( */)) {
	    if (this.options.ecmaVersion >= 9) {
	      this.regexp_groupSpecifier(state);
	    } else if (state.current() === 0x3F /* ? */) {
	      state.raise("Invalid group");
	    }
	    this.regexp_disjunction(state);
	    if (state.eat(0x29 /* ) */)) {
	      state.numCapturingParens += 1;
	      return true
	    }
	    state.raise("Unterminated group");
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
	pp$9.regexp_eatExtendedAtom = function(state) {
	  return (
	    state.eat(0x2E /* . */) ||
	    this.regexp_eatReverseSolidusAtomEscape(state) ||
	    this.regexp_eatCharacterClass(state) ||
	    this.regexp_eatUncapturingGroup(state) ||
	    this.regexp_eatCapturingGroup(state) ||
	    this.regexp_eatInvalidBracedQuantifier(state) ||
	    this.regexp_eatExtendedPatternCharacter(state)
	  )
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
	pp$9.regexp_eatInvalidBracedQuantifier = function(state) {
	  if (this.regexp_eatBracedQuantifier(state, true)) {
	    state.raise("Nothing to repeat");
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
	pp$9.regexp_eatSyntaxCharacter = function(state) {
	  var ch = state.current();
	  if (isSyntaxCharacter(ch)) {
	    state.lastIntValue = ch;
	    state.advance();
	    return true
	  }
	  return false
	};
	function isSyntaxCharacter(ch) {
	  return (
	    ch === 0x24 /* $ */ ||
	    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
	    ch === 0x2E /* . */ ||
	    ch === 0x3F /* ? */ ||
	    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
	    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
	  )
	}
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
	// But eat eager.
	pp$9.regexp_eatPatternCharacters = function(state) {
	  var start = state.pos;
	  var ch = 0;
	  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
	    state.advance();
	  }
	  return state.pos !== start
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
	pp$9.regexp_eatExtendedPatternCharacter = function(state) {
	  var ch = state.current();
	  if (
	    ch !== -1 &&
	    ch !== 0x24 /* $ */ &&
	    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
	    ch !== 0x2E /* . */ &&
	    ch !== 0x3F /* ? */ &&
	    ch !== 0x5B /* [ */ &&
	    ch !== 0x5E /* ^ */ &&
	    ch !== 0x7C /* | */
	  ) {
	    state.advance();
	    return true
	  }
	  return false
	};
	
	// GroupSpecifier[U] ::
	//   [empty]
	//   `?` GroupName[?U]
	pp$9.regexp_groupSpecifier = function(state) {
	  if (state.eat(0x3F /* ? */)) {
	    if (this.regexp_eatGroupName(state)) {
	      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
	        state.raise("Duplicate capture group name");
	      }
	      state.groupNames.push(state.lastStringValue);
	      return
	    }
	    state.raise("Invalid group");
	  }
	};
	
	// GroupName[U] ::
	//   `<` RegExpIdentifierName[?U] `>`
	// Note: this updates `state.lastStringValue` property with the eaten name.
	pp$9.regexp_eatGroupName = function(state) {
	  state.lastStringValue = "";
	  if (state.eat(0x3C /* < */)) {
	    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
	      return true
	    }
	    state.raise("Invalid capture group name");
	  }
	  return false
	};
	
	// RegExpIdentifierName[U] ::
	//   RegExpIdentifierStart[?U]
	//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
	// Note: this updates `state.lastStringValue` property with the eaten name.
	pp$9.regexp_eatRegExpIdentifierName = function(state) {
	  state.lastStringValue = "";
	  if (this.regexp_eatRegExpIdentifierStart(state)) {
	    state.lastStringValue += codePointToString$1(state.lastIntValue);
	    while (this.regexp_eatRegExpIdentifierPart(state)) {
	      state.lastStringValue += codePointToString$1(state.lastIntValue);
	    }
	    return true
	  }
	  return false
	};
	
	// RegExpIdentifierStart[U] ::
	//   UnicodeIDStart
	//   `$`
	//   `_`
	//   `\` RegExpUnicodeEscapeSequence[?U]
	pp$9.regexp_eatRegExpIdentifierStart = function(state) {
	  var start = state.pos;
	  var ch = state.current();
	  state.advance();
	
	  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
	    ch = state.lastIntValue;
	  }
	  if (isRegExpIdentifierStart(ch)) {
	    state.lastIntValue = ch;
	    return true
	  }
	
	  state.pos = start;
	  return false
	};
	function isRegExpIdentifierStart(ch) {
	  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
	}
	
	// RegExpIdentifierPart[U] ::
	//   UnicodeIDContinue
	//   `$`
	//   `_`
	//   `\` RegExpUnicodeEscapeSequence[?U]
	//   <ZWNJ>
	//   <ZWJ>
	pp$9.regexp_eatRegExpIdentifierPart = function(state) {
	  var start = state.pos;
	  var ch = state.current();
	  state.advance();
	
	  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
	    ch = state.lastIntValue;
	  }
	  if (isRegExpIdentifierPart(ch)) {
	    state.lastIntValue = ch;
	    return true
	  }
	
	  state.pos = start;
	  return false
	};
	function isRegExpIdentifierPart(ch) {
	  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
	}
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
	pp$9.regexp_eatAtomEscape = function(state) {
	  if (
	    this.regexp_eatBackReference(state) ||
	    this.regexp_eatCharacterClassEscape(state) ||
	    this.regexp_eatCharacterEscape(state) ||
	    (state.switchN && this.regexp_eatKGroupName(state))
	  ) {
	    return true
	  }
	  if (state.switchU) {
	    // Make the same message as V8.
	    if (state.current() === 0x63 /* c */) {
	      state.raise("Invalid unicode escape");
	    }
	    state.raise("Invalid escape");
	  }
	  return false
	};
	pp$9.regexp_eatBackReference = function(state) {
	  var start = state.pos;
	  if (this.regexp_eatDecimalEscape(state)) {
	    var n = state.lastIntValue;
	    if (state.switchU) {
	      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
	      if (n > state.maxBackReference) {
	        state.maxBackReference = n;
	      }
	      return true
	    }
	    if (n <= state.numCapturingParens) {
	      return true
	    }
	    state.pos = start;
	  }
	  return false
	};
	pp$9.regexp_eatKGroupName = function(state) {
	  if (state.eat(0x6B /* k */)) {
	    if (this.regexp_eatGroupName(state)) {
	      state.backReferenceNames.push(state.lastStringValue);
	      return true
	    }
	    state.raise("Invalid named reference");
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
	pp$9.regexp_eatCharacterEscape = function(state) {
	  return (
	    this.regexp_eatControlEscape(state) ||
	    this.regexp_eatCControlLetter(state) ||
	    this.regexp_eatZero(state) ||
	    this.regexp_eatHexEscapeSequence(state) ||
	    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
	    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
	    this.regexp_eatIdentityEscape(state)
	  )
	};
	pp$9.regexp_eatCControlLetter = function(state) {
	  var start = state.pos;
	  if (state.eat(0x63 /* c */)) {
	    if (this.regexp_eatControlLetter(state)) {
	      return true
	    }
	    state.pos = start;
	  }
	  return false
	};
	pp$9.regexp_eatZero = function(state) {
	  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
	    state.lastIntValue = 0;
	    state.advance();
	    return true
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
	pp$9.regexp_eatControlEscape = function(state) {
	  var ch = state.current();
	  if (ch === 0x74 /* t */) {
	    state.lastIntValue = 0x09; /* \t */
	    state.advance();
	    return true
	  }
	  if (ch === 0x6E /* n */) {
	    state.lastIntValue = 0x0A; /* \n */
	    state.advance();
	    return true
	  }
	  if (ch === 0x76 /* v */) {
	    state.lastIntValue = 0x0B; /* \v */
	    state.advance();
	    return true
	  }
	  if (ch === 0x66 /* f */) {
	    state.lastIntValue = 0x0C; /* \f */
	    state.advance();
	    return true
	  }
	  if (ch === 0x72 /* r */) {
	    state.lastIntValue = 0x0D; /* \r */
	    state.advance();
	    return true
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
	pp$9.regexp_eatControlLetter = function(state) {
	  var ch = state.current();
	  if (isControlLetter(ch)) {
	    state.lastIntValue = ch % 0x20;
	    state.advance();
	    return true
	  }
	  return false
	};
	function isControlLetter(ch) {
	  return (
	    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
	    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
	  )
	}
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
	pp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
	  var start = state.pos;
	
	  if (state.eat(0x75 /* u */)) {
	    if (this.regexp_eatFixedHexDigits(state, 4)) {
	      var lead = state.lastIntValue;
	      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
	        var leadSurrogateEnd = state.pos;
	        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
	          var trail = state.lastIntValue;
	          if (trail >= 0xDC00 && trail <= 0xDFFF) {
	            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	            return true
	          }
	        }
	        state.pos = leadSurrogateEnd;
	        state.lastIntValue = lead;
	      }
	      return true
	    }
	    if (
	      state.switchU &&
	      state.eat(0x7B /* { */) &&
	      this.regexp_eatHexDigits(state) &&
	      state.eat(0x7D /* } */) &&
	      isValidUnicode(state.lastIntValue)
	    ) {
	      return true
	    }
	    if (state.switchU) {
	      state.raise("Invalid unicode escape");
	    }
	    state.pos = start;
	  }
	
	  return false
	};
	function isValidUnicode(ch) {
	  return ch >= 0 && ch <= 0x10FFFF
	}
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
	pp$9.regexp_eatIdentityEscape = function(state) {
	  if (state.switchU) {
	    if (this.regexp_eatSyntaxCharacter(state)) {
	      return true
	    }
	    if (state.eat(0x2F /* / */)) {
	      state.lastIntValue = 0x2F; /* / */
	      return true
	    }
	    return false
	  }
	
	  var ch = state.current();
	  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
	    state.lastIntValue = ch;
	    state.advance();
	    return true
	  }
	
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
	pp$9.regexp_eatDecimalEscape = function(state) {
	  state.lastIntValue = 0;
	  var ch = state.current();
	  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
	    do {
	      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
	      state.advance();
	    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
	    return true
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
	pp$9.regexp_eatCharacterClassEscape = function(state) {
	  var ch = state.current();
	
	  if (isCharacterClassEscape(ch)) {
	    state.lastIntValue = -1;
	    state.advance();
	    return true
	  }
	
	  if (
	    state.switchU &&
	    this.options.ecmaVersion >= 9 &&
	    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
	  ) {
	    state.lastIntValue = -1;
	    state.advance();
	    if (
	      state.eat(0x7B /* { */) &&
	      this.regexp_eatUnicodePropertyValueExpression(state) &&
	      state.eat(0x7D /* } */)
	    ) {
	      return true
	    }
	    state.raise("Invalid property name");
	  }
	
	  return false
	};
	function isCharacterClassEscape(ch) {
	  return (
	    ch === 0x64 /* d */ ||
	    ch === 0x44 /* D */ ||
	    ch === 0x73 /* s */ ||
	    ch === 0x53 /* S */ ||
	    ch === 0x77 /* w */ ||
	    ch === 0x57 /* W */
	  )
	}
	
	// UnicodePropertyValueExpression ::
	//   UnicodePropertyName `=` UnicodePropertyValue
	//   LoneUnicodePropertyNameOrValue
	pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {
	  var start = state.pos;
	
	  // UnicodePropertyName `=` UnicodePropertyValue
	  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
	    var name = state.lastStringValue;
	    if (this.regexp_eatUnicodePropertyValue(state)) {
	      var value = state.lastStringValue;
	      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
	      return true
	    }
	  }
	  state.pos = start;
	
	  // LoneUnicodePropertyNameOrValue
	  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
	    var nameOrValue = state.lastStringValue;
	    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
	    return true
	  }
	  return false
	};
	pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
	  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {
	    state.raise("Invalid property name");
	  }
	};
	pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
	  if (data.$LONE.indexOf(nameOrValue) === -1) {
	    state.raise("Invalid property name");
	  }
	};
	
	// UnicodePropertyName ::
	//   UnicodePropertyNameCharacters
	pp$9.regexp_eatUnicodePropertyName = function(state) {
	  var ch = 0;
	  state.lastStringValue = "";
	  while (isUnicodePropertyNameCharacter(ch = state.current())) {
	    state.lastStringValue += codePointToString$1(ch);
	    state.advance();
	  }
	  return state.lastStringValue !== ""
	};
	function isUnicodePropertyNameCharacter(ch) {
	  return isControlLetter(ch) || ch === 0x5F /* _ */
	}
	
	// UnicodePropertyValue ::
	//   UnicodePropertyValueCharacters
	pp$9.regexp_eatUnicodePropertyValue = function(state) {
	  var ch = 0;
	  state.lastStringValue = "";
	  while (isUnicodePropertyValueCharacter(ch = state.current())) {
	    state.lastStringValue += codePointToString$1(ch);
	    state.advance();
	  }
	  return state.lastStringValue !== ""
	};
	function isUnicodePropertyValueCharacter(ch) {
	  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
	}
	
	// LoneUnicodePropertyNameOrValue ::
	//   UnicodePropertyValueCharacters
	pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
	  return this.regexp_eatUnicodePropertyValue(state)
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
	pp$9.regexp_eatCharacterClass = function(state) {
	  if (state.eat(0x5B /* [ */)) {
	    state.eat(0x5E /* ^ */);
	    this.regexp_classRanges(state);
	    if (state.eat(0x5D /* [ */)) {
	      return true
	    }
	    // Unreachable since it threw "unterminated regular expression" error before.
	    state.raise("Unterminated character class");
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
	// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
	// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
	pp$9.regexp_classRanges = function(state) {
	  var this$1 = this;
	
	  while (this.regexp_eatClassAtom(state)) {
	    var left = state.lastIntValue;
	    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {
	      var right = state.lastIntValue;
	      if (state.switchU && (left === -1 || right === -1)) {
	        state.raise("Invalid character class");
	      }
	      if (left !== -1 && right !== -1 && left > right) {
	        state.raise("Range out of order in character class");
	      }
	    }
	  }
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
	// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
	pp$9.regexp_eatClassAtom = function(state) {
	  var start = state.pos;
	
	  if (state.eat(0x5C /* \ */)) {
	    if (this.regexp_eatClassEscape(state)) {
	      return true
	    }
	    if (state.switchU) {
	      // Make the same message as V8.
	      var ch$1 = state.current();
	      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
	        state.raise("Invalid class escape");
	      }
	      state.raise("Invalid escape");
	    }
	    state.pos = start;
	  }
	
	  var ch = state.current();
	  if (ch !== 0x5D /* [ */) {
	    state.lastIntValue = ch;
	    state.advance();
	    return true
	  }
	
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
	pp$9.regexp_eatClassEscape = function(state) {
	  var start = state.pos;
	
	  if (state.eat(0x62 /* b */)) {
	    state.lastIntValue = 0x08; /* <BS> */
	    return true
	  }
	
	  if (state.switchU && state.eat(0x2D /* - */)) {
	    state.lastIntValue = 0x2D; /* - */
	    return true
	  }
	
	  if (!state.switchU && state.eat(0x63 /* c */)) {
	    if (this.regexp_eatClassControlLetter(state)) {
	      return true
	    }
	    state.pos = start;
	  }
	
	  return (
	    this.regexp_eatCharacterClassEscape(state) ||
	    this.regexp_eatCharacterEscape(state)
	  )
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
	pp$9.regexp_eatClassControlLetter = function(state) {
	  var ch = state.current();
	  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
	    state.lastIntValue = ch % 0x20;
	    state.advance();
	    return true
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
	pp$9.regexp_eatHexEscapeSequence = function(state) {
	  var start = state.pos;
	  if (state.eat(0x78 /* x */)) {
	    if (this.regexp_eatFixedHexDigits(state, 2)) {
	      return true
	    }
	    if (state.switchU) {
	      state.raise("Invalid escape");
	    }
	    state.pos = start;
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
	pp$9.regexp_eatDecimalDigits = function(state) {
	  var start = state.pos;
	  var ch = 0;
	  state.lastIntValue = 0;
	  while (isDecimalDigit(ch = state.current())) {
	    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
	    state.advance();
	  }
	  return state.pos !== start
	};
	function isDecimalDigit(ch) {
	  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
	}
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
	pp$9.regexp_eatHexDigits = function(state) {
	  var start = state.pos;
	  var ch = 0;
	  state.lastIntValue = 0;
	  while (isHexDigit(ch = state.current())) {
	    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
	    state.advance();
	  }
	  return state.pos !== start
	};
	function isHexDigit(ch) {
	  return (
	    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
	    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
	    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
	  )
	}
	function hexToInt(ch) {
	  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
	    return 10 + (ch - 0x41 /* A */)
	  }
	  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
	    return 10 + (ch - 0x61 /* a */)
	  }
	  return ch - 0x30 /* 0 */
	}
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
	// Allows only 0-377(octal) i.e. 0-255(decimal).
	pp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {
	  if (this.regexp_eatOctalDigit(state)) {
	    var n1 = state.lastIntValue;
	    if (this.regexp_eatOctalDigit(state)) {
	      var n2 = state.lastIntValue;
	      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
	        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
	      } else {
	        state.lastIntValue = n1 * 8 + n2;
	      }
	    } else {
	      state.lastIntValue = n1;
	    }
	    return true
	  }
	  return false
	};
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
	pp$9.regexp_eatOctalDigit = function(state) {
	  var ch = state.current();
	  if (isOctalDigit(ch)) {
	    state.lastIntValue = ch - 0x30; /* 0 */
	    state.advance();
	    return true
	  }
	  state.lastIntValue = 0;
	  return false
	};
	function isOctalDigit(ch) {
	  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
	}
	
	// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
	// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
	// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
	pp$9.regexp_eatFixedHexDigits = function(state, length) {
	  var start = state.pos;
	  state.lastIntValue = 0;
	  for (var i = 0; i < length; ++i) {
	    var ch = state.current();
	    if (!isHexDigit(ch)) {
	      state.pos = start;
	      return false
	    }
	    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
	    state.advance();
	  }
	  return true
	};
	
	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.
	
	var Token = function Token(p) {
	  this.type = p.type;
	  this.value = p.value;
	  this.start = p.start;
	  this.end = p.end;
	  if (p.options.locations)
	    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
	  if (p.options.ranges)
	    { this.range = [p.start, p.end]; }
	};
	
	// ## Tokenizer
	
	var pp$8 = Parser.prototype;
	
	// Move to the next token
	
	pp$8.next = function() {
	  if (this.options.onToken)
	    { this.options.onToken(new Token(this)); }
	
	  this.lastTokEnd = this.end;
	  this.lastTokStart = this.start;
	  this.lastTokEndLoc = this.endLoc;
	  this.lastTokStartLoc = this.startLoc;
	  this.nextToken();
	};
	
	pp$8.getToken = function() {
	  this.next();
	  return new Token(this)
	};
	
	// If we're in an ES6 environment, make parsers iterable
	if (typeof Symbol !== "undefined")
	  { pp$8[Symbol.iterator] = function() {
	    var this$1 = this;
	
	    return {
	      next: function () {
	        var token = this$1.getToken();
	        return {
	          done: token.type === types.eof,
	          value: token
	        }
	      }
	    }
	  }; }
	
	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).
	
	pp$8.curContext = function() {
	  return this.context[this.context.length - 1]
	};
	
	// Read a single token, updating the parser object's token-related
	// properties.
	
	pp$8.nextToken = function() {
	  var curContext = this.curContext();
	  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }
	
	  this.start = this.pos;
	  if (this.options.locations) { this.startLoc = this.curPosition(); }
	  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }
	
	  if (curContext.override) { return curContext.override(this) }
	  else { this.readToken(this.fullCharCodeAtPos()); }
	};
	
	pp$8.readToken = function(code) {
	  // Identifier or keyword. '\uXXXX' sequences are allowed in
	  // identifiers, so '\' also dispatches to that.
	  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
	    { return this.readWord() }
	
	  return this.getTokenFromCode(code)
	};
	
	pp$8.fullCharCodeAtPos = function() {
	  var code = this.input.charCodeAt(this.pos);
	  if (code <= 0xd7ff || code >= 0xe000) { return code }
	  var next = this.input.charCodeAt(this.pos + 1);
	  return (code << 10) + next - 0x35fdc00
	};
	
	pp$8.skipBlockComment = function() {
	  var this$1 = this;
	
	  var startLoc = this.options.onComment && this.curPosition();
	  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
	  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
	  this.pos = end + 2;
	  if (this.options.locations) {
	    lineBreakG.lastIndex = start;
	    var match;
	    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
	      ++this$1.curLine;
	      this$1.lineStart = match.index + match[0].length;
	    }
	  }
	  if (this.options.onComment)
	    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
	                           startLoc, this.curPosition()); }
	};
	
	pp$8.skipLineComment = function(startSkip) {
	  var this$1 = this;
	
	  var start = this.pos;
	  var startLoc = this.options.onComment && this.curPosition();
	  var ch = this.input.charCodeAt(this.pos += startSkip);
	  while (this.pos < this.input.length && !isNewLine(ch)) {
	    ch = this$1.input.charCodeAt(++this$1.pos);
	  }
	  if (this.options.onComment)
	    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
	                           startLoc, this.curPosition()); }
	};
	
	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.
	
	pp$8.skipSpace = function() {
	  var this$1 = this;
	
	  loop: while (this.pos < this.input.length) {
	    var ch = this$1.input.charCodeAt(this$1.pos);
	    switch (ch) {
	    case 32: case 160: // ' '
	      ++this$1.pos;
	      break
	    case 13:
	      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
	        ++this$1.pos;
	      }
	    case 10: case 8232: case 8233:
	      ++this$1.pos;
	      if (this$1.options.locations) {
	        ++this$1.curLine;
	        this$1.lineStart = this$1.pos;
	      }
	      break
	    case 47: // '/'
	      switch (this$1.input.charCodeAt(this$1.pos + 1)) {
	      case 42: // '*'
	        this$1.skipBlockComment();
	        break
	      case 47:
	        this$1.skipLineComment(2);
	        break
	      default:
	        break loop
	      }
	      break
	    default:
	      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	        ++this$1.pos;
	      } else {
	        break loop
	      }
	    }
	  }
	};
	
	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.
	
	pp$8.finishToken = function(type, val) {
	  this.end = this.pos;
	  if (this.options.locations) { this.endLoc = this.curPosition(); }
	  var prevType = this.type;
	  this.type = type;
	  this.value = val;
	
	  this.updateContext(prevType);
	};
	
	// ### Token reading
	
	// This is the function that is called to fetch the next token. It
	// is somewhat obscure, because it works in character codes rather
	// than characters, and because operator parsing has been inlined
	// into it.
	//
	// All in the name of speed.
	//
	pp$8.readToken_dot = function() {
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next >= 48 && next <= 57) { return this.readNumber(true) }
	  var next2 = this.input.charCodeAt(this.pos + 2);
	  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
	    this.pos += 3;
	    return this.finishToken(types.ellipsis)
	  } else {
	    ++this.pos;
	    return this.finishToken(types.dot)
	  }
	};
	
	pp$8.readToken_slash = function() { // '/'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
	  if (next === 61) { return this.finishOp(types.assign, 2) }
	  return this.finishOp(types.slash, 1)
	};
	
	pp$8.readToken_mult_modulo_exp = function(code) { // '%*'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  var tokentype = code === 42 ? types.star : types.modulo;
	
	  // exponentiation operator ** and **=
	  if (this.options.ecmaVersion >= 7 && code == 42 && next === 42) {
	    ++size;
	    tokentype = types.starstar;
	    next = this.input.charCodeAt(this.pos + 2);
	  }
	
	  if (next === 61) { return this.finishOp(types.assign, size + 1) }
	  return this.finishOp(tokentype, size)
	};
	
	pp$8.readToken_pipe_amp = function(code) { // '|&'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
	  if (next === 61) { return this.finishOp(types.assign, 2) }
	  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
	};
	
	pp$8.readToken_caret = function() { // '^'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) { return this.finishOp(types.assign, 2) }
	  return this.finishOp(types.bitwiseXOR, 1)
	};
	
	pp$8.readToken_plus_min = function(code) { // '+-'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) {
	    if (next == 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 62 &&
	        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
	      // A `-->` line comment
	      this.skipLineComment(3);
	      this.skipSpace();
	      return this.nextToken()
	    }
	    return this.finishOp(types.incDec, 2)
	  }
	  if (next === 61) { return this.finishOp(types.assign, 2) }
	  return this.finishOp(types.plusMin, 1)
	};
	
	pp$8.readToken_lt_gt = function(code) { // '<>'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  if (next === code) {
	    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
	    return this.finishOp(types.bitShift, size)
	  }
	  if (next == 33 && code == 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 45 &&
	      this.input.charCodeAt(this.pos + 3) == 45) {
	    // `<!--`, an XML-style comment that should be interpreted as a line comment
	    this.skipLineComment(4);
	    this.skipSpace();
	    return this.nextToken()
	  }
	  if (next === 61) { size = 2; }
	  return this.finishOp(types.relational, size)
	};
	
	pp$8.readToken_eq_excl = function(code) { // '=!'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
	  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
	    this.pos += 2;
	    return this.finishToken(types.arrow)
	  }
	  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
	};
	
	pp$8.getTokenFromCode = function(code) {
	  switch (code) {
	  // The interpretation of a dot depends on whether it is followed
	  // by a digit or another two dots.
	  case 46: // '.'
	    return this.readToken_dot()
	
	  // Punctuation tokens.
	  case 40: ++this.pos; return this.finishToken(types.parenL)
	  case 41: ++this.pos; return this.finishToken(types.parenR)
	  case 59: ++this.pos; return this.finishToken(types.semi)
	  case 44: ++this.pos; return this.finishToken(types.comma)
	  case 91: ++this.pos; return this.finishToken(types.bracketL)
	  case 93: ++this.pos; return this.finishToken(types.bracketR)
	  case 123: ++this.pos; return this.finishToken(types.braceL)
	  case 125: ++this.pos; return this.finishToken(types.braceR)
	  case 58: ++this.pos; return this.finishToken(types.colon)
	  case 63: ++this.pos; return this.finishToken(types.question)
	
	  case 96: // '`'
	    if (this.options.ecmaVersion < 6) { break }
	    ++this.pos;
	    return this.finishToken(types.backQuote)
	
	  case 48: // '0'
	    var next = this.input.charCodeAt(this.pos + 1);
	    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
	    if (this.options.ecmaVersion >= 6) {
	      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
	      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
	    }
	
	  // Anything else beginning with a digit is an integer, octal
	  // number, or float.
	  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
	    return this.readNumber(false)
	
	  // Quotes produce strings.
	  case 34: case 39: // '"', "'"
	    return this.readString(code)
	
	  // Operators are parsed inline in tiny state machines. '=' (61) is
	  // often referred to. `finishOp` simply skips the amount of
	  // characters it is given as second argument, and returns a token
	  // of the type given by its first argument.
	
	  case 47: // '/'
	    return this.readToken_slash()
	
	  case 37: case 42: // '%*'
	    return this.readToken_mult_modulo_exp(code)
	
	  case 124: case 38: // '|&'
	    return this.readToken_pipe_amp(code)
	
	  case 94: // '^'
	    return this.readToken_caret()
	
	  case 43: case 45: // '+-'
	    return this.readToken_plus_min(code)
	
	  case 60: case 62: // '<>'
	    return this.readToken_lt_gt(code)
	
	  case 61: case 33: // '=!'
	    return this.readToken_eq_excl(code)
	
	  case 126: // '~'
	    return this.finishOp(types.prefix, 1)
	  }
	
	  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};
	
	pp$8.finishOp = function(type, size) {
	  var str = this.input.slice(this.pos, this.pos + size);
	  this.pos += size;
	  return this.finishToken(type, str)
	};
	
	pp$8.readRegexp = function() {
	  var this$1 = this;
	
	  var escaped, inClass, start = this.pos;
	  for (;;) {
	    if (this$1.pos >= this$1.input.length) { this$1.raise(start, "Unterminated regular expression"); }
	    var ch = this$1.input.charAt(this$1.pos);
	    if (lineBreak.test(ch)) { this$1.raise(start, "Unterminated regular expression"); }
	    if (!escaped) {
	      if (ch === "[") { inClass = true; }
	      else if (ch === "]" && inClass) { inClass = false; }
	      else if (ch === "/" && !inClass) { break }
	      escaped = ch === "\\";
	    } else { escaped = false; }
	    ++this$1.pos;
	  }
	  var pattern = this.input.slice(start, this.pos);
	  ++this.pos;
	  var flagsStart = this.pos;
	  var flags = this.readWord1();
	  if (this.containsEsc) { this.unexpected(flagsStart); }
	
	  // Validate pattern
	  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
	  state.reset(start, pattern, flags);
	  this.validateRegExpFlags(state);
	  this.validateRegExpPattern(state);
	
	  // Create Literal#value property value.
	  var value = null;
	  try {
	    value = new RegExp(pattern, flags);
	  } catch (e) {
	    // ESTree requires null if it failed to instantiate RegExp object.
	    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
	  }
	
	  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
	};
	
	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.
	
	pp$8.readInt = function(radix, len) {
	  var this$1 = this;
	
	  var start = this.pos, total = 0;
	  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);
	    if (code >= 97) { val = code - 97 + 10; } // a
	    else if (code >= 65) { val = code - 65 + 10; } // A
	    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
	    else { val = Infinity; }
	    if (val >= radix) { break }
	    ++this$1.pos;
	    total = total * radix + val;
	  }
	  if (this.pos === start || len != null && this.pos - start !== len) { return null }
	
	  return total
	};
	
	pp$8.readRadixNumber = function(radix) {
	  this.pos += 2; // 0x
	  var val = this.readInt(radix);
	  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
	  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
	  return this.finishToken(types.num, val)
	};
	
	// Read an integer, octal integer, or floating-point number.
	
	pp$8.readNumber = function(startsWithDot) {
	  var start = this.pos;
	  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
	  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	  if (octal && this.strict) { this.raise(start, "Invalid number"); }
	  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
	  var next = this.input.charCodeAt(this.pos);
	  if (next === 46 && !octal) { // '.'
	    ++this.pos;
	    this.readInt(10);
	    next = this.input.charCodeAt(this.pos);
	  }
	  if ((next === 69 || next === 101) && !octal) { // 'eE'
	    next = this.input.charCodeAt(++this.pos);
	    if (next === 43 || next === 45) { ++this.pos; } // '+-'
	    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
	  }
	  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
	
	  var str = this.input.slice(start, this.pos);
	  var val = octal ? parseInt(str, 8) : parseFloat(str);
	  return this.finishToken(types.num, val)
	};
	
	// Read a string value, interpreting backslash-escapes.
	
	pp$8.readCodePoint = function() {
	  var ch = this.input.charCodeAt(this.pos), code;
	
	  if (ch === 123) { // '{'
	    if (this.options.ecmaVersion < 6) { this.unexpected(); }
	    var codePos = ++this.pos;
	    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
	    ++this.pos;
	    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
	  } else {
	    code = this.readHexChar(4);
	  }
	  return code
	};
	
	function codePointToString(code) {
	  // UTF-16 Decoding
	  if (code <= 0xFFFF) { return String.fromCharCode(code) }
	  code -= 0x10000;
	  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
	}
	
	pp$8.readString = function(quote) {
	  var this$1 = this;
	
	  var out = "", chunkStart = ++this.pos;
	  for (;;) {
	    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated string constant"); }
	    var ch = this$1.input.charCodeAt(this$1.pos);
	    if (ch === quote) { break }
	    if (ch === 92) { // '\'
	      out += this$1.input.slice(chunkStart, this$1.pos);
	      out += this$1.readEscapedChar(false);
	      chunkStart = this$1.pos;
	    } else {
	      if (isNewLine(ch)) { this$1.raise(this$1.start, "Unterminated string constant"); }
	      ++this$1.pos;
	    }
	  }
	  out += this.input.slice(chunkStart, this.pos++);
	  return this.finishToken(types.string, out)
	};
	
	// Reads template string tokens.
	
	var INVALID_TEMPLATE_ESCAPE_ERROR = {};
	
	pp$8.tryReadTemplateToken = function() {
	  this.inTemplateElement = true;
	  try {
	    this.readTmplToken();
	  } catch (err) {
	    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
	      this.readInvalidTemplateToken();
	    } else {
	      throw err
	    }
	  }
	
	  this.inTemplateElement = false;
	};
	
	pp$8.invalidStringToken = function(position, message) {
	  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
	    throw INVALID_TEMPLATE_ESCAPE_ERROR
	  } else {
	    this.raise(position, message);
	  }
	};
	
	pp$8.readTmplToken = function() {
	  var this$1 = this;
	
	  var out = "", chunkStart = this.pos;
	  for (;;) {
	    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated template"); }
	    var ch = this$1.input.charCodeAt(this$1.pos);
	    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
	      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
	        if (ch === 36) {
	          this$1.pos += 2;
	          return this$1.finishToken(types.dollarBraceL)
	        } else {
	          ++this$1.pos;
	          return this$1.finishToken(types.backQuote)
	        }
	      }
	      out += this$1.input.slice(chunkStart, this$1.pos);
	      return this$1.finishToken(types.template, out)
	    }
	    if (ch === 92) { // '\'
	      out += this$1.input.slice(chunkStart, this$1.pos);
	      out += this$1.readEscapedChar(true);
	      chunkStart = this$1.pos;
	    } else if (isNewLine(ch)) {
	      out += this$1.input.slice(chunkStart, this$1.pos);
	      ++this$1.pos;
	      switch (ch) {
	      case 13:
	        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }
	      case 10:
	        out += "\n";
	        break
	      default:
	        out += String.fromCharCode(ch);
	        break
	      }
	      if (this$1.options.locations) {
	        ++this$1.curLine;
	        this$1.lineStart = this$1.pos;
	      }
	      chunkStart = this$1.pos;
	    } else {
	      ++this$1.pos;
	    }
	  }
	};
	
	// Reads a template token to search for the end, without validating any escape sequences
	pp$8.readInvalidTemplateToken = function() {
	  var this$1 = this;
	
	  for (; this.pos < this.input.length; this.pos++) {
	    switch (this$1.input[this$1.pos]) {
	    case "\\":
	      ++this$1.pos;
	      break
	
	    case "$":
	      if (this$1.input[this$1.pos + 1] !== "{") {
	        break
	      }
	    // falls through
	
	    case "`":
	      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))
	
	    // no default
	    }
	  }
	  this.raise(this.start, "Unterminated template");
	};
	
	// Used to read escaped characters
	
	pp$8.readEscapedChar = function(inTemplate) {
	  var ch = this.input.charCodeAt(++this.pos);
	  ++this.pos;
	  switch (ch) {
	  case 110: return "\n" // 'n' -> '\n'
	  case 114: return "\r" // 'r' -> '\r'
	  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
	  case 117: return codePointToString(this.readCodePoint()) // 'u'
	  case 116: return "\t" // 't' -> '\t'
	  case 98: return "\b" // 'b' -> '\b'
	  case 118: return "\u000b" // 'v' -> '\u000b'
	  case 102: return "\f" // 'f' -> '\f'
	  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
	  case 10: // ' \n'
	    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
	    return ""
	  default:
	    if (ch >= 48 && ch <= 55) {
	      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
	      var octal = parseInt(octalStr, 8);
	      if (octal > 255) {
	        octalStr = octalStr.slice(0, -1);
	        octal = parseInt(octalStr, 8);
	      }
	      this.pos += octalStr.length - 1;
	      ch = this.input.charCodeAt(this.pos);
	      if ((octalStr !== "0" || ch == 56 || ch == 57) && (this.strict || inTemplate)) {
	        this.invalidStringToken(
	          this.pos - 1 - octalStr.length,
	          inTemplate
	            ? "Octal literal in template string"
	            : "Octal literal in strict mode"
	        );
	      }
	      return String.fromCharCode(octal)
	    }
	    return String.fromCharCode(ch)
	  }
	};
	
	// Used to read character escape sequences ('\x', '\u', '\U').
	
	pp$8.readHexChar = function(len) {
	  var codePos = this.pos;
	  var n = this.readInt(16, len);
	  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
	  return n
	};
	
	// Read an identifier, and return it as a string. Sets `this.containsEsc`
	// to whether the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.
	
	pp$8.readWord1 = function() {
	  var this$1 = this;
	
	  this.containsEsc = false;
	  var word = "", first = true, chunkStart = this.pos;
	  var astral = this.options.ecmaVersion >= 6;
	  while (this.pos < this.input.length) {
	    var ch = this$1.fullCharCodeAtPos();
	    if (isIdentifierChar(ch, astral)) {
	      this$1.pos += ch <= 0xffff ? 1 : 2;
	    } else if (ch === 92) { // "\"
	      this$1.containsEsc = true;
	      word += this$1.input.slice(chunkStart, this$1.pos);
	      var escStart = this$1.pos;
	      if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
	        { this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX"); }
	      ++this$1.pos;
	      var esc = this$1.readCodePoint();
	      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
	        { this$1.invalidStringToken(escStart, "Invalid Unicode escape"); }
	      word += codePointToString(esc);
	      chunkStart = this$1.pos;
	    } else {
	      break
	    }
	    first = false;
	  }
	  return word + this.input.slice(chunkStart, this.pos)
	};
	
	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.
	
	pp$8.readWord = function() {
	  var word = this.readWord1();
	  var type = types.name;
	  if (this.keywords.test(word)) {
	    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
	    type = keywords$1[word];
	  }
	  return this.finishToken(type, word)
	};
	
	// Acorn is a tiny, fast JavaScript parser written in JavaScript.
	//
	// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
	// various contributors and released under an MIT license.
	//
	// Git repositories for Acorn are available at
	//
	//     http://marijnhaverbeke.nl/git/acorn
	//     https://github.com/acornjs/acorn.git
	//
	// Please use the [github bug tracker][ghbt] to report issues.
	//
	// [ghbt]: https://github.com/acornjs/acorn/issues
	//
	// This file defines the main parser interface. The library also comes
	// with a [error-tolerant parser][dammit] and an
	// [abstract syntax tree walker][walk], defined in other files.
	//
	// [dammit]: acorn_loose.js
	// [walk]: util/walk.js
	
	var version = "5.5.3";
	
	// The main exported interface (under `self.acorn` when in the
	// browser) is a `parse` function that takes a code string and
	// returns an abstract syntax tree as specified by [Mozilla parser
	// API][api].
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
	
	function parse(input, options) {
	  return new Parser(options, input).parse()
	}
	
	// This function tries to parse a single expression at a given
	// offset in a string. Useful for parsing mixed-language formats
	// that embed JavaScript expressions.
	
	function parseExpressionAt(input, pos, options) {
	  var p = new Parser(options, input, pos);
	  p.nextToken();
	  return p.parseExpression()
	}
	
	// Acorn is organized as a tokenizer and a recursive-descent parser.
	// The `tokenizer` export provides an interface to the tokenizer.
	
	function tokenizer(input, options) {
	  return new Parser(options, input)
	}
	
	// This is a terrible kludge to support the existing, pre-ES6
	// interface where the loose parser module retroactively adds exports
	// to this module.
	 // eslint-disable-line camelcase
	function addLooseExports(parse, Parser$$1, plugins$$1) {
	  exports.parse_dammit = parse; // eslint-disable-line camelcase
	  exports.LooseParser = Parser$$1;
	  exports.pluginsLoose = plugins$$1;
	}
	
	exports.version = version;
	exports.parse = parse;
	exports.parseExpressionAt = parseExpressionAt;
	exports.tokenizer = tokenizer;
	exports.addLooseExports = addLooseExports;
	exports.Parser = Parser;
	exports.plugins = plugins;
	exports.defaultOptions = defaultOptions;
	exports.Position = Position;
	exports.SourceLocation = SourceLocation;
	exports.getLineInfo = getLineInfo;
	exports.Node = Node;
	exports.TokenType = TokenType;
	exports.tokTypes = types;
	exports.keywordTypes = keywords$1;
	exports.TokContext = TokContext;
	exports.tokContexts = types$1;
	exports.isIdentifierChar = isIdentifierChar;
	exports.isIdentifierStart = isIdentifierStart;
	exports.Token = Token;
	exports.isNewLine = isNewLine;
	exports.lineBreak = lineBreak;
	exports.lineBreakG = lineBreakG;
	exports.nonASCIIwhitespace = nonASCIIwhitespace;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },
/* 23 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/index.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = {};
	module.exports.F = /*#__PURE__*/__webpack_require__(/*! ./F */ 24);
	module.exports.T = /*#__PURE__*/__webpack_require__(/*! ./T */ 28);
	module.exports.__ = /*#__PURE__*/__webpack_require__(/*! ./__ */ 29);
	module.exports.add = /*#__PURE__*/__webpack_require__(/*! ./add */ 30);
	module.exports.addIndex = /*#__PURE__*/__webpack_require__(/*! ./addIndex */ 32);
	module.exports.adjust = /*#__PURE__*/__webpack_require__(/*! ./adjust */ 37);
	module.exports.all = /*#__PURE__*/__webpack_require__(/*! ./all */ 39);
	module.exports.allPass = /*#__PURE__*/__webpack_require__(/*! ./allPass */ 46);
	module.exports.always = /*#__PURE__*/__webpack_require__(/*! ./always */ 25);
	module.exports.and = /*#__PURE__*/__webpack_require__(/*! ./and */ 63);
	module.exports.any = /*#__PURE__*/__webpack_require__(/*! ./any */ 64);
	module.exports.anyPass = /*#__PURE__*/__webpack_require__(/*! ./anyPass */ 66);
	module.exports.ap = /*#__PURE__*/__webpack_require__(/*! ./ap */ 67);
	module.exports.aperture = /*#__PURE__*/__webpack_require__(/*! ./aperture */ 68);
	module.exports.append = /*#__PURE__*/__webpack_require__(/*! ./append */ 71);
	module.exports.apply = /*#__PURE__*/__webpack_require__(/*! ./apply */ 72);
	module.exports.applySpec = /*#__PURE__*/__webpack_require__(/*! ./applySpec */ 73);
	module.exports.applyTo = /*#__PURE__*/__webpack_require__(/*! ./applyTo */ 75);
	module.exports.ascend = /*#__PURE__*/__webpack_require__(/*! ./ascend */ 76);
	module.exports.assoc = /*#__PURE__*/__webpack_require__(/*! ./assoc */ 77);
	module.exports.assocPath = /*#__PURE__*/__webpack_require__(/*! ./assocPath */ 78);
	module.exports.binary = /*#__PURE__*/__webpack_require__(/*! ./binary */ 81);
	module.exports.bind = /*#__PURE__*/__webpack_require__(/*! ./bind */ 55);
	module.exports.both = /*#__PURE__*/__webpack_require__(/*! ./both */ 83);
	module.exports.call = /*#__PURE__*/__webpack_require__(/*! ./call */ 87);
	module.exports.chain = /*#__PURE__*/__webpack_require__(/*! ./chain */ 89);
	module.exports.clamp = /*#__PURE__*/__webpack_require__(/*! ./clamp */ 94);
	module.exports.clone = /*#__PURE__*/__webpack_require__(/*! ./clone */ 95);
	module.exports.comparator = /*#__PURE__*/__webpack_require__(/*! ./comparator */ 99);
	module.exports.complement = /*#__PURE__*/__webpack_require__(/*! ./complement */ 100);
	module.exports.compose = /*#__PURE__*/__webpack_require__(/*! ./compose */ 102);
	module.exports.composeK = /*#__PURE__*/__webpack_require__(/*! ./composeK */ 109);
	module.exports.composeP = /*#__PURE__*/__webpack_require__(/*! ./composeP */ 110);
	module.exports.concat = /*#__PURE__*/__webpack_require__(/*! ./concat */ 113);
	module.exports.cond = /*#__PURE__*/__webpack_require__(/*! ./cond */ 132);
	module.exports.construct = /*#__PURE__*/__webpack_require__(/*! ./construct */ 133);
	module.exports.constructN = /*#__PURE__*/__webpack_require__(/*! ./constructN */ 134);
	module.exports.contains = /*#__PURE__*/__webpack_require__(/*! ./contains */ 135);
	module.exports.converge = /*#__PURE__*/__webpack_require__(/*! ./converge */ 136);
	module.exports.countBy = /*#__PURE__*/__webpack_require__(/*! ./countBy */ 137);
	module.exports.curry = /*#__PURE__*/__webpack_require__(/*! ./curry */ 88);
	module.exports.curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	module.exports.dec = /*#__PURE__*/__webpack_require__(/*! ./dec */ 140);
	module.exports.defaultTo = /*#__PURE__*/__webpack_require__(/*! ./defaultTo */ 141);
	module.exports.descend = /*#__PURE__*/__webpack_require__(/*! ./descend */ 142);
	module.exports.difference = /*#__PURE__*/__webpack_require__(/*! ./difference */ 143);
	module.exports.differenceWith = /*#__PURE__*/__webpack_require__(/*! ./differenceWith */ 144);
	module.exports.dissoc = /*#__PURE__*/__webpack_require__(/*! ./dissoc */ 145);
	module.exports.dissocPath = /*#__PURE__*/__webpack_require__(/*! ./dissocPath */ 146);
	module.exports.divide = /*#__PURE__*/__webpack_require__(/*! ./divide */ 149);
	module.exports.drop = /*#__PURE__*/__webpack_require__(/*! ./drop */ 150);
	module.exports.dropLast = /*#__PURE__*/__webpack_require__(/*! ./dropLast */ 152);
	module.exports.dropLastWhile = /*#__PURE__*/__webpack_require__(/*! ./dropLastWhile */ 157);
	module.exports.dropRepeats = /*#__PURE__*/__webpack_require__(/*! ./dropRepeats */ 160);
	module.exports.dropRepeatsWith = /*#__PURE__*/__webpack_require__(/*! ./dropRepeatsWith */ 162);
	module.exports.dropWhile = /*#__PURE__*/__webpack_require__(/*! ./dropWhile */ 165);
	module.exports.either = /*#__PURE__*/__webpack_require__(/*! ./either */ 167);
	module.exports.empty = /*#__PURE__*/__webpack_require__(/*! ./empty */ 169);
	module.exports.endsWith = /*#__PURE__*/__webpack_require__(/*! ./endsWith */ 170);
	module.exports.eqBy = /*#__PURE__*/__webpack_require__(/*! ./eqBy */ 172);
	module.exports.eqProps = /*#__PURE__*/__webpack_require__(/*! ./eqProps */ 173);
	module.exports.equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	module.exports.evolve = /*#__PURE__*/__webpack_require__(/*! ./evolve */ 174);
	module.exports.filter = /*#__PURE__*/__webpack_require__(/*! ./filter */ 128);
	module.exports.find = /*#__PURE__*/__webpack_require__(/*! ./find */ 175);
	module.exports.findIndex = /*#__PURE__*/__webpack_require__(/*! ./findIndex */ 177);
	module.exports.findLast = /*#__PURE__*/__webpack_require__(/*! ./findLast */ 179);
	module.exports.findLastIndex = /*#__PURE__*/__webpack_require__(/*! ./findLastIndex */ 181);
	module.exports.flatten = /*#__PURE__*/__webpack_require__(/*! ./flatten */ 183);
	module.exports.flip = /*#__PURE__*/__webpack_require__(/*! ./flip */ 184);
	module.exports.forEach = /*#__PURE__*/__webpack_require__(/*! ./forEach */ 185);
	module.exports.forEachObjIndexed = /*#__PURE__*/__webpack_require__(/*! ./forEachObjIndexed */ 186);
	module.exports.fromPairs = /*#__PURE__*/__webpack_require__(/*! ./fromPairs */ 187);
	module.exports.groupBy = /*#__PURE__*/__webpack_require__(/*! ./groupBy */ 188);
	module.exports.groupWith = /*#__PURE__*/__webpack_require__(/*! ./groupWith */ 189);
	module.exports.gt = /*#__PURE__*/__webpack_require__(/*! ./gt */ 190);
	module.exports.gte = /*#__PURE__*/__webpack_require__(/*! ./gte */ 191);
	module.exports.has = /*#__PURE__*/__webpack_require__(/*! ./has */ 192);
	module.exports.hasIn = /*#__PURE__*/__webpack_require__(/*! ./hasIn */ 193);
	module.exports.head = /*#__PURE__*/__webpack_require__(/*! ./head */ 194);
	module.exports.identical = /*#__PURE__*/__webpack_require__(/*! ./identical */ 123);
	module.exports.identity = /*#__PURE__*/__webpack_require__(/*! ./identity */ 195);
	module.exports.ifElse = /*#__PURE__*/__webpack_require__(/*! ./ifElse */ 197);
	module.exports.inc = /*#__PURE__*/__webpack_require__(/*! ./inc */ 198);
	module.exports.indexBy = /*#__PURE__*/__webpack_require__(/*! ./indexBy */ 199);
	module.exports.indexOf = /*#__PURE__*/__webpack_require__(/*! ./indexOf */ 200);
	module.exports.init = /*#__PURE__*/__webpack_require__(/*! ./init */ 201);
	module.exports.innerJoin = /*#__PURE__*/__webpack_require__(/*! ./innerJoin */ 202);
	module.exports.insert = /*#__PURE__*/__webpack_require__(/*! ./insert */ 203);
	module.exports.insertAll = /*#__PURE__*/__webpack_require__(/*! ./insertAll */ 204);
	module.exports.intersection = /*#__PURE__*/__webpack_require__(/*! ./intersection */ 205);
	module.exports.intersperse = /*#__PURE__*/__webpack_require__(/*! ./intersperse */ 209);
	module.exports.into = /*#__PURE__*/__webpack_require__(/*! ./into */ 210);
	module.exports.invert = /*#__PURE__*/__webpack_require__(/*! ./invert */ 215);
	module.exports.invertObj = /*#__PURE__*/__webpack_require__(/*! ./invertObj */ 216);
	module.exports.invoker = /*#__PURE__*/__webpack_require__(/*! ./invoker */ 217);
	module.exports.is = /*#__PURE__*/__webpack_require__(/*! ./is */ 218);
	module.exports.isEmpty = /*#__PURE__*/__webpack_require__(/*! ./isEmpty */ 219);
	module.exports.isNil = /*#__PURE__*/__webpack_require__(/*! ./isNil */ 80);
	module.exports.join = /*#__PURE__*/__webpack_require__(/*! ./join */ 220);
	module.exports.juxt = /*#__PURE__*/__webpack_require__(/*! ./juxt */ 221);
	module.exports.keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ 57);
	module.exports.keysIn = /*#__PURE__*/__webpack_require__(/*! ./keysIn */ 222);
	module.exports.last = /*#__PURE__*/__webpack_require__(/*! ./last */ 163);
	module.exports.lastIndexOf = /*#__PURE__*/__webpack_require__(/*! ./lastIndexOf */ 223);
	module.exports.length = /*#__PURE__*/__webpack_require__(/*! ./length */ 224);
	module.exports.lens = /*#__PURE__*/__webpack_require__(/*! ./lens */ 226);
	module.exports.lensIndex = /*#__PURE__*/__webpack_require__(/*! ./lensIndex */ 227);
	module.exports.lensPath = /*#__PURE__*/__webpack_require__(/*! ./lensPath */ 228);
	module.exports.lensProp = /*#__PURE__*/__webpack_require__(/*! ./lensProp */ 229);
	module.exports.lift = /*#__PURE__*/__webpack_require__(/*! ./lift */ 85);
	module.exports.liftN = /*#__PURE__*/__webpack_require__(/*! ./liftN */ 86);
	module.exports.lt = /*#__PURE__*/__webpack_require__(/*! ./lt */ 230);
	module.exports.lte = /*#__PURE__*/__webpack_require__(/*! ./lte */ 231);
	module.exports.map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	module.exports.mapAccum = /*#__PURE__*/__webpack_require__(/*! ./mapAccum */ 232);
	module.exports.mapAccumRight = /*#__PURE__*/__webpack_require__(/*! ./mapAccumRight */ 233);
	module.exports.mapObjIndexed = /*#__PURE__*/__webpack_require__(/*! ./mapObjIndexed */ 234);
	module.exports.match = /*#__PURE__*/__webpack_require__(/*! ./match */ 235);
	module.exports.mathMod = /*#__PURE__*/__webpack_require__(/*! ./mathMod */ 236);
	module.exports.max = /*#__PURE__*/__webpack_require__(/*! ./max */ 47);
	module.exports.maxBy = /*#__PURE__*/__webpack_require__(/*! ./maxBy */ 237);
	module.exports.mean = /*#__PURE__*/__webpack_require__(/*! ./mean */ 238);
	module.exports.median = /*#__PURE__*/__webpack_require__(/*! ./median */ 240);
	module.exports.memoize = /*#__PURE__*/__webpack_require__(/*! ./memoize */ 241);
	module.exports.memoizeWith = /*#__PURE__*/__webpack_require__(/*! ./memoizeWith */ 242);
	module.exports.merge = /*#__PURE__*/__webpack_require__(/*! ./merge */ 243);
	module.exports.mergeAll = /*#__PURE__*/__webpack_require__(/*! ./mergeAll */ 244);
	module.exports.mergeDeepLeft = /*#__PURE__*/__webpack_require__(/*! ./mergeDeepLeft */ 245);
	module.exports.mergeDeepRight = /*#__PURE__*/__webpack_require__(/*! ./mergeDeepRight */ 248);
	module.exports.mergeDeepWith = /*#__PURE__*/__webpack_require__(/*! ./mergeDeepWith */ 249);
	module.exports.mergeDeepWithKey = /*#__PURE__*/__webpack_require__(/*! ./mergeDeepWithKey */ 246);
	module.exports.mergeWith = /*#__PURE__*/__webpack_require__(/*! ./mergeWith */ 250);
	module.exports.mergeWithKey = /*#__PURE__*/__webpack_require__(/*! ./mergeWithKey */ 247);
	module.exports.min = /*#__PURE__*/__webpack_require__(/*! ./min */ 251);
	module.exports.minBy = /*#__PURE__*/__webpack_require__(/*! ./minBy */ 252);
	module.exports.modulo = /*#__PURE__*/__webpack_require__(/*! ./modulo */ 253);
	module.exports.multiply = /*#__PURE__*/__webpack_require__(/*! ./multiply */ 254);
	module.exports.nAry = /*#__PURE__*/__webpack_require__(/*! ./nAry */ 82);
	module.exports.negate = /*#__PURE__*/__webpack_require__(/*! ./negate */ 255);
	module.exports.none = /*#__PURE__*/__webpack_require__(/*! ./none */ 256);
	module.exports.not = /*#__PURE__*/__webpack_require__(/*! ./not */ 101);
	module.exports.nth = /*#__PURE__*/__webpack_require__(/*! ./nth */ 164);
	module.exports.nthArg = /*#__PURE__*/__webpack_require__(/*! ./nthArg */ 257);
	module.exports.o = /*#__PURE__*/__webpack_require__(/*! ./o */ 258);
	module.exports.objOf = /*#__PURE__*/__webpack_require__(/*! ./objOf */ 214);
	module.exports.of = /*#__PURE__*/__webpack_require__(/*! ./of */ 259);
	module.exports.omit = /*#__PURE__*/__webpack_require__(/*! ./omit */ 261);
	module.exports.once = /*#__PURE__*/__webpack_require__(/*! ./once */ 262);
	module.exports.or = /*#__PURE__*/__webpack_require__(/*! ./or */ 168);
	module.exports.over = /*#__PURE__*/__webpack_require__(/*! ./over */ 263);
	module.exports.pair = /*#__PURE__*/__webpack_require__(/*! ./pair */ 264);
	module.exports.partial = /*#__PURE__*/__webpack_require__(/*! ./partial */ 265);
	module.exports.partialRight = /*#__PURE__*/__webpack_require__(/*! ./partialRight */ 267);
	module.exports.partition = /*#__PURE__*/__webpack_require__(/*! ./partition */ 268);
	module.exports.path = /*#__PURE__*/__webpack_require__(/*! ./path */ 61);
	module.exports.pathEq = /*#__PURE__*/__webpack_require__(/*! ./pathEq */ 269);
	module.exports.pathOr = /*#__PURE__*/__webpack_require__(/*! ./pathOr */ 270);
	module.exports.pathSatisfies = /*#__PURE__*/__webpack_require__(/*! ./pathSatisfies */ 271);
	module.exports.pick = /*#__PURE__*/__webpack_require__(/*! ./pick */ 272);
	module.exports.pickAll = /*#__PURE__*/__webpack_require__(/*! ./pickAll */ 273);
	module.exports.pickBy = /*#__PURE__*/__webpack_require__(/*! ./pickBy */ 274);
	module.exports.pipe = /*#__PURE__*/__webpack_require__(/*! ./pipe */ 103);
	module.exports.pipeK = /*#__PURE__*/__webpack_require__(/*! ./pipeK */ 275);
	module.exports.pipeP = /*#__PURE__*/__webpack_require__(/*! ./pipeP */ 111);
	module.exports.pluck = /*#__PURE__*/__webpack_require__(/*! ./pluck */ 48);
	module.exports.prepend = /*#__PURE__*/__webpack_require__(/*! ./prepend */ 276);
	module.exports.product = /*#__PURE__*/__webpack_require__(/*! ./product */ 277);
	module.exports.project = /*#__PURE__*/__webpack_require__(/*! ./project */ 278);
	module.exports.prop = /*#__PURE__*/__webpack_require__(/*! ./prop */ 60);
	module.exports.propEq = /*#__PURE__*/__webpack_require__(/*! ./propEq */ 280);
	module.exports.propIs = /*#__PURE__*/__webpack_require__(/*! ./propIs */ 281);
	module.exports.propOr = /*#__PURE__*/__webpack_require__(/*! ./propOr */ 282);
	module.exports.propSatisfies = /*#__PURE__*/__webpack_require__(/*! ./propSatisfies */ 283);
	module.exports.props = /*#__PURE__*/__webpack_require__(/*! ./props */ 284);
	module.exports.range = /*#__PURE__*/__webpack_require__(/*! ./range */ 285);
	module.exports.reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	module.exports.reduceBy = /*#__PURE__*/__webpack_require__(/*! ./reduceBy */ 138);
	module.exports.reduceRight = /*#__PURE__*/__webpack_require__(/*! ./reduceRight */ 286);
	module.exports.reduceWhile = /*#__PURE__*/__webpack_require__(/*! ./reduceWhile */ 287);
	module.exports.reduced = /*#__PURE__*/__webpack_require__(/*! ./reduced */ 288);
	module.exports.reject = /*#__PURE__*/__webpack_require__(/*! ./reject */ 126);
	module.exports.remove = /*#__PURE__*/__webpack_require__(/*! ./remove */ 147);
	module.exports.repeat = /*#__PURE__*/__webpack_require__(/*! ./repeat */ 289);
	module.exports.replace = /*#__PURE__*/__webpack_require__(/*! ./replace */ 291);
	module.exports.reverse = /*#__PURE__*/__webpack_require__(/*! ./reverse */ 108);
	module.exports.scan = /*#__PURE__*/__webpack_require__(/*! ./scan */ 292);
	module.exports.sequence = /*#__PURE__*/__webpack_require__(/*! ./sequence */ 293);
	module.exports.set = /*#__PURE__*/__webpack_require__(/*! ./set */ 294);
	module.exports.slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	module.exports.sort = /*#__PURE__*/__webpack_require__(/*! ./sort */ 295);
	module.exports.sortBy = /*#__PURE__*/__webpack_require__(/*! ./sortBy */ 296);
	module.exports.sortWith = /*#__PURE__*/__webpack_require__(/*! ./sortWith */ 297);
	module.exports.split = /*#__PURE__*/__webpack_require__(/*! ./split */ 298);
	module.exports.splitAt = /*#__PURE__*/__webpack_require__(/*! ./splitAt */ 299);
	module.exports.splitEvery = /*#__PURE__*/__webpack_require__(/*! ./splitEvery */ 300);
	module.exports.splitWhen = /*#__PURE__*/__webpack_require__(/*! ./splitWhen */ 301);
	module.exports.startsWith = /*#__PURE__*/__webpack_require__(/*! ./startsWith */ 302);
	module.exports.subtract = /*#__PURE__*/__webpack_require__(/*! ./subtract */ 303);
	module.exports.sum = /*#__PURE__*/__webpack_require__(/*! ./sum */ 239);
	module.exports.symmetricDifference = /*#__PURE__*/__webpack_require__(/*! ./symmetricDifference */ 304);
	module.exports.symmetricDifferenceWith = /*#__PURE__*/__webpack_require__(/*! ./symmetricDifferenceWith */ 305);
	module.exports.tail = /*#__PURE__*/__webpack_require__(/*! ./tail */ 105);
	module.exports.take = /*#__PURE__*/__webpack_require__(/*! ./take */ 154);
	module.exports.takeLast = /*#__PURE__*/__webpack_require__(/*! ./takeLast */ 171);
	module.exports.takeLastWhile = /*#__PURE__*/__webpack_require__(/*! ./takeLastWhile */ 306);
	module.exports.takeWhile = /*#__PURE__*/__webpack_require__(/*! ./takeWhile */ 307);
	module.exports.tap = /*#__PURE__*/__webpack_require__(/*! ./tap */ 309);
	module.exports.test = /*#__PURE__*/__webpack_require__(/*! ./test */ 311);
	module.exports.times = /*#__PURE__*/__webpack_require__(/*! ./times */ 290);
	module.exports.toLower = /*#__PURE__*/__webpack_require__(/*! ./toLower */ 313);
	module.exports.toPairs = /*#__PURE__*/__webpack_require__(/*! ./toPairs */ 314);
	module.exports.toPairsIn = /*#__PURE__*/__webpack_require__(/*! ./toPairsIn */ 315);
	module.exports.toString = /*#__PURE__*/__webpack_require__(/*! ./toString */ 114);
	module.exports.toUpper = /*#__PURE__*/__webpack_require__(/*! ./toUpper */ 316);
	module.exports.transduce = /*#__PURE__*/__webpack_require__(/*! ./transduce */ 317);
	module.exports.transpose = /*#__PURE__*/__webpack_require__(/*! ./transpose */ 318);
	module.exports.traverse = /*#__PURE__*/__webpack_require__(/*! ./traverse */ 319);
	module.exports.trim = /*#__PURE__*/__webpack_require__(/*! ./trim */ 320);
	module.exports.tryCatch = /*#__PURE__*/__webpack_require__(/*! ./tryCatch */ 321);
	module.exports.type = /*#__PURE__*/__webpack_require__(/*! ./type */ 98);
	module.exports.unapply = /*#__PURE__*/__webpack_require__(/*! ./unapply */ 322);
	module.exports.unary = /*#__PURE__*/__webpack_require__(/*! ./unary */ 323);
	module.exports.uncurryN = /*#__PURE__*/__webpack_require__(/*! ./uncurryN */ 324);
	module.exports.unfold = /*#__PURE__*/__webpack_require__(/*! ./unfold */ 325);
	module.exports.union = /*#__PURE__*/__webpack_require__(/*! ./union */ 326);
	module.exports.unionWith = /*#__PURE__*/__webpack_require__(/*! ./unionWith */ 327);
	module.exports.uniq = /*#__PURE__*/__webpack_require__(/*! ./uniq */ 206);
	module.exports.uniqBy = /*#__PURE__*/__webpack_require__(/*! ./uniqBy */ 207);
	module.exports.uniqWith = /*#__PURE__*/__webpack_require__(/*! ./uniqWith */ 328);
	module.exports.unless = /*#__PURE__*/__webpack_require__(/*! ./unless */ 329);
	module.exports.unnest = /*#__PURE__*/__webpack_require__(/*! ./unnest */ 330);
	module.exports.until = /*#__PURE__*/__webpack_require__(/*! ./until */ 331);
	module.exports.update = /*#__PURE__*/__webpack_require__(/*! ./update */ 148);
	module.exports.useWith = /*#__PURE__*/__webpack_require__(/*! ./useWith */ 279);
	module.exports.values = /*#__PURE__*/__webpack_require__(/*! ./values */ 74);
	module.exports.valuesIn = /*#__PURE__*/__webpack_require__(/*! ./valuesIn */ 332);
	module.exports.view = /*#__PURE__*/__webpack_require__(/*! ./view */ 333);
	module.exports.when = /*#__PURE__*/__webpack_require__(/*! ./when */ 334);
	module.exports.where = /*#__PURE__*/__webpack_require__(/*! ./where */ 335);
	module.exports.whereEq = /*#__PURE__*/__webpack_require__(/*! ./whereEq */ 336);
	module.exports.without = /*#__PURE__*/__webpack_require__(/*! ./without */ 337);
	module.exports.xprod = /*#__PURE__*/__webpack_require__(/*! ./xprod */ 338);
	module.exports.zip = /*#__PURE__*/__webpack_require__(/*! ./zip */ 339);
	module.exports.zipObj = /*#__PURE__*/__webpack_require__(/*! ./zipObj */ 340);
	module.exports.zipWith = /*#__PURE__*/__webpack_require__(/*! ./zipWith */ 341);

/***/ },
/* 24 */
/*!**************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/F.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var always = /*#__PURE__*/__webpack_require__(/*! ./always */ 25);
	
	/**
	 * A function that always returns `false`. Any passed in parameters are ignored.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Function
	 * @sig * -> Boolean
	 * @param {*}
	 * @return {Boolean}
	 * @see R.always, R.T
	 * @example
	 *
	 *      R.F(); //=> false
	 */
	
	
	var F = /*#__PURE__*/always(false);
	module.exports = F;

/***/ },
/* 25 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/always.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Returns a function that always returns the given value. Note that for
	 * non-primitives the value returned is a reference to the original value.
	 *
	 * This function is known as `const`, `constant`, or `K` (for K combinator) in
	 * other languages and libraries.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig a -> (* -> a)
	 * @param {*} val The value to wrap in a function
	 * @return {Function} A Function :: * -> val.
	 * @example
	 *
	 *      var t = R.always('Tee');
	 *      t(); //=> 'Tee'
	 */
	
	
	var always = /*#__PURE__*/_curry1(function always(val) {
	  return function () {
	    return val;
	  };
	});
	module.exports = always;

/***/ },
/* 26 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_curry1.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ 27);
	
	/**
	 * Optimized internal one-arity curry function.
	 *
	 * @private
	 * @category Function
	 * @param {Function} fn The function to curry.
	 * @return {Function} The curried function.
	 */
	
	
	function _curry1(fn) {
	  return function f1(a) {
	    if (arguments.length === 0 || _isPlaceholder(a)) {
	      return f1;
	    } else {
	      return fn.apply(this, arguments);
	    }
	  };
	}
	module.exports = _curry1;

/***/ },
/* 27 */
/*!************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isPlaceholder.js ***!
  \************************************************************************************/
/***/ function(module, exports) {

	function _isPlaceholder(a) {
	       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
	}
	module.exports = _isPlaceholder;

/***/ },
/* 28 */
/*!**************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/T.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var always = /*#__PURE__*/__webpack_require__(/*! ./always */ 25);
	
	/**
	 * A function that always returns `true`. Any passed in parameters are ignored.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Function
	 * @sig * -> Boolean
	 * @param {*}
	 * @return {Boolean}
	 * @see R.always, R.F
	 * @example
	 *
	 *      R.T(); //=> true
	 */
	
	
	var T = /*#__PURE__*/always(true);
	module.exports = T;

/***/ },
/* 29 */
/*!***************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/__.js ***!
  \***************************************************************/
/***/ function(module, exports) {

	/**
	 * A special placeholder value used to specify "gaps" within curried functions,
	 * allowing partial application of any combination of arguments, regardless of
	 * their positions.
	 *
	 * If `g` is a curried ternary function and `_` is `R.__`, the following are
	 * equivalent:
	 *
	 *   - `g(1, 2, 3)`
	 *   - `g(_, 2, 3)(1)`
	 *   - `g(_, _, 3)(1)(2)`
	 *   - `g(_, _, 3)(1, 2)`
	 *   - `g(_, 2, _)(1, 3)`
	 *   - `g(_, 2)(1)(3)`
	 *   - `g(_, 2)(1, 3)`
	 *   - `g(_, 2)(_, 3)(1)`
	 *
	 * @constant
	 * @memberOf R
	 * @since v0.6.0
	 * @category Function
	 * @example
	 *
	 *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
	 *      greet('Alice'); //=> 'Hello, Alice!'
	 */
	module.exports = { '@@functional/placeholder': true };

/***/ },
/* 30 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/add.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Adds two values.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a
	 * @param {Number} b
	 * @return {Number}
	 * @see R.subtract
	 * @example
	 *
	 *      R.add(2, 3);       //=>  5
	 *      R.add(7)(10);      //=> 17
	 */
	
	
	var add = /*#__PURE__*/_curry2(function add(a, b) {
	  return Number(a) + Number(b);
	});
	module.exports = add;

/***/ },
/* 31 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_curry2.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ 26);
	
	var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ 27);
	
	/**
	 * Optimized internal two-arity curry function.
	 *
	 * @private
	 * @category Function
	 * @param {Function} fn The function to curry.
	 * @return {Function} The curried function.
	 */
	
	
	function _curry2(fn) {
	  return function f2(a, b) {
	    switch (arguments.length) {
	      case 0:
	        return f2;
	      case 1:
	        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
	          return fn(a, _b);
	        });
	      default:
	        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
	          return fn(_a, b);
	        }) : _isPlaceholder(b) ? _curry1(function (_b) {
	          return fn(a, _b);
	        }) : fn(a, b);
	    }
	  };
	}
	module.exports = _curry2;

/***/ },
/* 32 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/addIndex.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	/**
	 * Creates a new list iteration function from an existing one by adding two new
	 * parameters to its callback function: the current index, and the entire list.
	 *
	 * This would turn, for instance, [`R.map`](#map) function into one that
	 * more closely resembles `Array.prototype.map`. Note that this will only work
	 * for functions in which the iteration callback function is the first
	 * parameter, and where the list is the last parameter. (This latter might be
	 * unimportant if the list parameter is not used.)
	 *
	 * @func
	 * @memberOf R
	 * @since v0.15.0
	 * @category Function
	 * @category List
	 * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
	 * @param {Function} fn A list iteration function that does not pass index or list to its callback
	 * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
	 * @example
	 *
	 *      var mapIndexed = R.addIndex(R.map);
	 *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
	 *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
	 */
	
	
	var addIndex = /*#__PURE__*/_curry1(function addIndex(fn) {
	  return curryN(fn.length, function () {
	    var idx = 0;
	    var origFn = arguments[0];
	    var list = arguments[arguments.length - 1];
	    var args = Array.prototype.slice.call(arguments, 0);
	    args[0] = function () {
	      var result = origFn.apply(this, _concat(arguments, [idx, list]));
	      idx += 1;
	      return result;
	    };
	    return fn.apply(this, args);
	  });
	});
	module.exports = addIndex;

/***/ },
/* 33 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_concat.js ***!
  \*****************************************************************************/
/***/ function(module, exports) {

	/**
	 * Private `concat` function to merge two array-like objects.
	 *
	 * @private
	 * @param {Array|Arguments} [set1=[]] An array-like object.
	 * @param {Array|Arguments} [set2=[]] An array-like object.
	 * @return {Array} A new, merged array.
	 * @example
	 *
	 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	 */
	function _concat(set1, set2) {
	  set1 = set1 || [];
	  set2 = set2 || [];
	  var idx;
	  var len1 = set1.length;
	  var len2 = set2.length;
	  var result = [];
	
	  idx = 0;
	  while (idx < len1) {
	    result[result.length] = set1[idx];
	    idx += 1;
	  }
	  idx = 0;
	  while (idx < len2) {
	    result[result.length] = set2[idx];
	    idx += 1;
	  }
	  return result;
	}
	module.exports = _concat;

/***/ },
/* 34 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/curryN.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ 35);
	
	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _curryN = /*#__PURE__*/__webpack_require__(/*! ./internal/_curryN */ 36);
	
	/**
	 * Returns a curried equivalent of the provided function, with the specified
	 * arity. The curried function has two unusual capabilities. First, its
	 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
	 * following are equivalent:
	 *
	 *   - `g(1)(2)(3)`
	 *   - `g(1)(2, 3)`
	 *   - `g(1, 2)(3)`
	 *   - `g(1, 2, 3)`
	 *
	 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
	 * "gaps", allowing partial application of any combination of arguments,
	 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
	 * the following are equivalent:
	 *
	 *   - `g(1, 2, 3)`
	 *   - `g(_, 2, 3)(1)`
	 *   - `g(_, _, 3)(1)(2)`
	 *   - `g(_, _, 3)(1, 2)`
	 *   - `g(_, 2)(1)(3)`
	 *   - `g(_, 2)(1, 3)`
	 *   - `g(_, 2)(_, 3)(1)`
	 *
	 * @func
	 * @memberOf R
	 * @since v0.5.0
	 * @category Function
	 * @sig Number -> (* -> a) -> (* -> a)
	 * @param {Number} length The arity for the returned function.
	 * @param {Function} fn The function to curry.
	 * @return {Function} A new, curried function.
	 * @see R.curry
	 * @example
	 *
	 *      var sumArgs = (...args) => R.sum(args);
	 *
	 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
	 *      var f = curriedAddFourNumbers(1, 2);
	 *      var g = f(3);
	 *      g(4); //=> 10
	 */
	
	
	var curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {
	  if (length === 1) {
	    return _curry1(fn);
	  }
	  return _arity(length, _curryN(length, [], fn));
	});
	module.exports = curryN;

/***/ },
/* 35 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_arity.js ***!
  \****************************************************************************/
/***/ function(module, exports) {

	function _arity(n, fn) {
	  /* eslint-disable no-unused-vars */
	  switch (n) {
	    case 0:
	      return function () {
	        return fn.apply(this, arguments);
	      };
	    case 1:
	      return function (a0) {
	        return fn.apply(this, arguments);
	      };
	    case 2:
	      return function (a0, a1) {
	        return fn.apply(this, arguments);
	      };
	    case 3:
	      return function (a0, a1, a2) {
	        return fn.apply(this, arguments);
	      };
	    case 4:
	      return function (a0, a1, a2, a3) {
	        return fn.apply(this, arguments);
	      };
	    case 5:
	      return function (a0, a1, a2, a3, a4) {
	        return fn.apply(this, arguments);
	      };
	    case 6:
	      return function (a0, a1, a2, a3, a4, a5) {
	        return fn.apply(this, arguments);
	      };
	    case 7:
	      return function (a0, a1, a2, a3, a4, a5, a6) {
	        return fn.apply(this, arguments);
	      };
	    case 8:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	        return fn.apply(this, arguments);
	      };
	    case 9:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	        return fn.apply(this, arguments);
	      };
	    case 10:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	        return fn.apply(this, arguments);
	      };
	    default:
	      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
	  }
	}
	module.exports = _arity;

/***/ },
/* 36 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_curryN.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./_arity */ 35);
	
	var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ 27);
	
	/**
	 * Internal curryN function.
	 *
	 * @private
	 * @category Function
	 * @param {Number} length The arity of the curried function.
	 * @param {Array} received An array of arguments received thus far.
	 * @param {Function} fn The function to curry.
	 * @return {Function} The curried function.
	 */
	
	
	function _curryN(length, received, fn) {
	  return function () {
	    var combined = [];
	    var argsIdx = 0;
	    var left = length;
	    var combinedIdx = 0;
	    while (combinedIdx < received.length || argsIdx < arguments.length) {
	      var result;
	      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
	        result = received[combinedIdx];
	      } else {
	        result = arguments[argsIdx];
	        argsIdx += 1;
	      }
	      combined[combinedIdx] = result;
	      if (!_isPlaceholder(result)) {
	        left -= 1;
	      }
	      combinedIdx += 1;
	    }
	    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
	  };
	}
	module.exports = _curryN;

/***/ },
/* 37 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/adjust.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Applies a function to the value at the given index of an array, returning a
	 * new copy of the array with the element at the given index replaced with the
	 * result of the function application.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig (a -> a) -> Number -> [a] -> [a]
	 * @param {Function} fn The function to apply.
	 * @param {Number} idx The index.
	 * @param {Array|Arguments} list An array-like object whose value
	 *        at the supplied index will be replaced.
	 * @return {Array} A copy of the supplied array-like object with
	 *         the element at index `idx` replaced with the value
	 *         returned by applying `fn` to the existing element.
	 * @see R.update
	 * @example
	 *
	 *      R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
	 *      R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
	 * @symb R.adjust(f, -1, [a, b]) = [a, f(b)]
	 * @symb R.adjust(f, 0, [a, b]) = [f(a), b]
	 */
	
	
	var adjust = /*#__PURE__*/_curry3(function adjust(fn, idx, list) {
	  if (idx >= list.length || idx < -list.length) {
	    return list;
	  }
	  var start = idx < 0 ? list.length : 0;
	  var _idx = start + idx;
	  var _list = _concat(list);
	  _list[_idx] = fn(list[_idx]);
	  return _list;
	});
	module.exports = adjust;

/***/ },
/* 38 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_curry3.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ 26);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ 27);
	
	/**
	 * Optimized internal three-arity curry function.
	 *
	 * @private
	 * @category Function
	 * @param {Function} fn The function to curry.
	 * @return {Function} The curried function.
	 */
	
	
	function _curry3(fn) {
	  return function f3(a, b, c) {
	    switch (arguments.length) {
	      case 0:
	        return f3;
	      case 1:
	        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
	          return fn(a, _b, _c);
	        });
	      case 2:
	        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
	          return fn(_a, b, _c);
	        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
	          return fn(a, _b, _c);
	        }) : _curry1(function (_c) {
	          return fn(a, b, _c);
	        });
	      default:
	        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
	          return fn(_a, _b, c);
	        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
	          return fn(_a, b, _c);
	        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
	          return fn(a, _b, _c);
	        }) : _isPlaceholder(a) ? _curry1(function (_a) {
	          return fn(_a, b, c);
	        }) : _isPlaceholder(b) ? _curry1(function (_b) {
	          return fn(a, _b, c);
	        }) : _isPlaceholder(c) ? _curry1(function (_c) {
	          return fn(a, b, _c);
	        }) : fn(a, b, c);
	    }
	  };
	}
	module.exports = _curry3;

/***/ },
/* 39 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/all.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xall = /*#__PURE__*/__webpack_require__(/*! ./internal/_xall */ 43);
	
	/**
	 * Returns `true` if all elements of the list match the predicate, `false` if
	 * there are any that don't.
	 *
	 * Dispatches to the `all` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Boolean
	 * @param {Function} fn The predicate function.
	 * @param {Array} list The array to consider.
	 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
	 *         otherwise.
	 * @see R.any, R.none, R.transduce
	 * @example
	 *
	 *      var equals3 = R.equals(3);
	 *      R.all(equals3)([3, 3, 3, 3]); //=> true
	 *      R.all(equals3)([3, 3, 1, 3]); //=> false
	 */
	
	
	var all = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['all'], _xall, function all(fn, list) {
	  var idx = 0;
	  while (idx < list.length) {
	    if (!fn(list[idx])) {
	      return false;
	    }
	    idx += 1;
	  }
	  return true;
	}));
	module.exports = all;

/***/ },
/* 40 */
/*!***********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_dispatchable.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _isArray = /*#__PURE__*/__webpack_require__(/*! ./_isArray */ 41);
	
	var _isTransformer = /*#__PURE__*/__webpack_require__(/*! ./_isTransformer */ 42);
	
	/**
	 * Returns a function that dispatches with different strategies based on the
	 * object in list position (last argument). If it is an array, executes [fn].
	 * Otherwise, if it has a function with one of the given method names, it will
	 * execute that function (functor case). Otherwise, if it is a transformer,
	 * uses transducer [xf] to return a new transformer (transducer case).
	 * Otherwise, it will default to executing [fn].
	 *
	 * @private
	 * @param {Array} methodNames properties to check for a custom implementation
	 * @param {Function} xf transducer to initialize if object is transformer
	 * @param {Function} fn default ramda implementation
	 * @return {Function} A function that dispatches on object in list position
	 */
	
	
	function _dispatchable(methodNames, xf, fn) {
	  return function () {
	    if (arguments.length === 0) {
	      return fn();
	    }
	    var args = Array.prototype.slice.call(arguments, 0);
	    var obj = args.pop();
	    if (!_isArray(obj)) {
	      var idx = 0;
	      while (idx < methodNames.length) {
	        if (typeof obj[methodNames[idx]] === 'function') {
	          return obj[methodNames[idx]].apply(obj, args);
	        }
	        idx += 1;
	      }
	      if (_isTransformer(obj)) {
	        var transducer = xf.apply(null, args);
	        return transducer(obj);
	      }
	    }
	    return fn.apply(this, arguments);
	  };
	}
	module.exports = _dispatchable;

/***/ },
/* 41 */
/*!******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isArray.js ***!
  \******************************************************************************/
/***/ function(module, exports) {

	/**
	 * Tests whether or not an object is an array.
	 *
	 * @private
	 * @param {*} val The object to test.
	 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
	 * @example
	 *
	 *      _isArray([]); //=> true
	 *      _isArray(null); //=> false
	 *      _isArray({}); //=> false
	 */
	module.exports = Array.isArray || function _isArray(val) {
	  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
	};

/***/ },
/* 42 */
/*!************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isTransformer.js ***!
  \************************************************************************************/
/***/ function(module, exports) {

	function _isTransformer(obj) {
	  return typeof obj['@@transducer/step'] === 'function';
	}
	module.exports = _isTransformer;

/***/ },
/* 43 */
/*!***************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xall.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _reduced = /*#__PURE__*/__webpack_require__(/*! ./_reduced */ 44);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XAll = /*#__PURE__*/function () {
	
	  function XAll(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.all = true;
	  }
	  XAll.prototype['@@transducer/init'] = _xfBase.init;
	  XAll.prototype['@@transducer/result'] = function (result) {
	    if (this.all) {
	      result = this.xf['@@transducer/step'](result, true);
	    }
	    return this.xf['@@transducer/result'](result);
	  };
	  XAll.prototype['@@transducer/step'] = function (result, input) {
	    if (!this.f(input)) {
	      this.all = false;
	      result = _reduced(this.xf['@@transducer/step'](result, false));
	    }
	    return result;
	  };
	
	  return XAll;
	}();
	
	var _xall = /*#__PURE__*/_curry2(function _xall(f, xf) {
	  return new XAll(f, xf);
	});
	module.exports = _xall;

/***/ },
/* 44 */
/*!******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_reduced.js ***!
  \******************************************************************************/
/***/ function(module, exports) {

	function _reduced(x) {
	  return x && x['@@transducer/reduced'] ? x : {
	    '@@transducer/value': x,
	    '@@transducer/reduced': true
	  };
	}
	module.exports = _reduced;

/***/ },
/* 45 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xfBase.js ***!
  \*****************************************************************************/
/***/ function(module, exports) {

	module.exports = {
	  init: function () {
	    return this.xf['@@transducer/init']();
	  },
	  result: function (result) {
	    return this.xf['@@transducer/result'](result);
	  }
	};

/***/ },
/* 46 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/allPass.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	var max = /*#__PURE__*/__webpack_require__(/*! ./max */ 47);
	
	var pluck = /*#__PURE__*/__webpack_require__(/*! ./pluck */ 48);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	/**
	 * Takes a list of predicates and returns a predicate that returns true for a
	 * given list of arguments if every one of the provided predicates is satisfied
	 * by those arguments.
	 *
	 * The function returned is a curried function whose arity matches that of the
	 * highest-arity predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Logic
	 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	 * @param {Array} predicates An array of predicates to check
	 * @return {Function} The combined predicate
	 * @see R.anyPass
	 * @example
	 *
	 *      var isQueen = R.propEq('rank', 'Q');
	 *      var isSpade = R.propEq('suit', '');
	 *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
	 *
	 *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
	 *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
	 */
	
	
	var allPass = /*#__PURE__*/_curry1(function allPass(preds) {
	  return curryN(reduce(max, 0, pluck('length', preds)), function () {
	    var idx = 0;
	    var len = preds.length;
	    while (idx < len) {
	      if (!preds[idx].apply(this, arguments)) {
	        return false;
	      }
	      idx += 1;
	    }
	    return true;
	  });
	});
	module.exports = allPass;

/***/ },
/* 47 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/max.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns the larger of its two arguments.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> a
	 * @param {*} a
	 * @param {*} b
	 * @return {*}
	 * @see R.maxBy, R.min
	 * @example
	 *
	 *      R.max(789, 123); //=> 789
	 *      R.max('a', 'b'); //=> 'b'
	 */
	
	
	var max = /*#__PURE__*/_curry2(function max(a, b) {
	  return b > a ? b : a;
	});
	module.exports = max;

/***/ },
/* 48 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pluck.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	var prop = /*#__PURE__*/__webpack_require__(/*! ./prop */ 60);
	
	/**
	 * Returns a new list by plucking the same named property off all objects in
	 * the list supplied.
	 *
	 * `pluck` will work on
	 * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
	 * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Functor f => k -> f {k: v} -> f v
	 * @param {Number|String} key The key name to pluck off of each object.
	 * @param {Array} f The array or functor to consider.
	 * @return {Array} The list of values for the given key.
	 * @see R.props
	 * @example
	 *
	 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
	 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
	 *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
	 * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
	 * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
	 */
	
	
	var pluck = /*#__PURE__*/_curry2(function pluck(p, list) {
	  return map(prop(p), list);
	});
	module.exports = pluck;

/***/ },
/* 49 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/map.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _map = /*#__PURE__*/__webpack_require__(/*! ./internal/_map */ 50);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var _xmap = /*#__PURE__*/__webpack_require__(/*! ./internal/_xmap */ 56);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ 57);
	
	/**
	 * Takes a function and
	 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
	 * applies the function to each of the functor's values, and returns
	 * a functor of the same shape.
	 *
	 * Ramda provides suitable `map` implementations for `Array` and `Object`,
	 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
	 *
	 * Dispatches to the `map` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * Also treats functions as functors and will compose them together.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Functor f => (a -> b) -> f a -> f b
	 * @param {Function} fn The function to be called on every element of the input `list`.
	 * @param {Array} list The list to be iterated over.
	 * @return {Array} The new list.
	 * @see R.transduce, R.addIndex
	 * @example
	 *
	 *      var double = x => x * 2;
	 *
	 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
	 *
	 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
	 * @symb R.map(f, [a, b]) = [f(a), f(b)]
	 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
	 * @symb R.map(f, functor_o) = functor_o.map(f)
	 */
	
	
	var map = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
	  switch (Object.prototype.toString.call(functor)) {
	    case '[object Function]':
	      return curryN(functor.length, function () {
	        return fn.call(this, functor.apply(this, arguments));
	      });
	    case '[object Object]':
	      return _reduce(function (acc, key) {
	        acc[key] = fn(functor[key]);
	        return acc;
	      }, {}, keys(functor));
	    default:
	      return _map(fn, functor);
	  }
	}));
	module.exports = map;

/***/ },
/* 50 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_map.js ***!
  \**************************************************************************/
/***/ function(module, exports) {

	function _map(fn, functor) {
	  var idx = 0;
	  var len = functor.length;
	  var result = Array(len);
	  while (idx < len) {
	    result[idx] = fn(functor[idx]);
	    idx += 1;
	  }
	  return result;
	}
	module.exports = _map;

/***/ },
/* 51 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_reduce.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _isArrayLike = /*#__PURE__*/__webpack_require__(/*! ./_isArrayLike */ 52);
	
	var _xwrap = /*#__PURE__*/__webpack_require__(/*! ./_xwrap */ 54);
	
	var bind = /*#__PURE__*/__webpack_require__(/*! ../bind */ 55);
	
	function _arrayReduce(xf, acc, list) {
	  var idx = 0;
	  var len = list.length;
	  while (idx < len) {
	    acc = xf['@@transducer/step'](acc, list[idx]);
	    if (acc && acc['@@transducer/reduced']) {
	      acc = acc['@@transducer/value'];
	      break;
	    }
	    idx += 1;
	  }
	  return xf['@@transducer/result'](acc);
	}
	
	function _iterableReduce(xf, acc, iter) {
	  var step = iter.next();
	  while (!step.done) {
	    acc = xf['@@transducer/step'](acc, step.value);
	    if (acc && acc['@@transducer/reduced']) {
	      acc = acc['@@transducer/value'];
	      break;
	    }
	    step = iter.next();
	  }
	  return xf['@@transducer/result'](acc);
	}
	
	function _methodReduce(xf, acc, obj, methodName) {
	  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
	}
	
	var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
	
	function _reduce(fn, acc, list) {
	  if (typeof fn === 'function') {
	    fn = _xwrap(fn);
	  }
	  if (_isArrayLike(list)) {
	    return _arrayReduce(fn, acc, list);
	  }
	  if (typeof list['fantasy-land/reduce'] === 'function') {
	    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
	  }
	  if (list[symIterator] != null) {
	    return _iterableReduce(fn, acc, list[symIterator]());
	  }
	  if (typeof list.next === 'function') {
	    return _iterableReduce(fn, acc, list);
	  }
	  if (typeof list.reduce === 'function') {
	    return _methodReduce(fn, acc, list, 'reduce');
	  }
	
	  throw new TypeError('reduce: list must be array or iterable');
	}
	module.exports = _reduce;

/***/ },
/* 52 */
/*!**********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isArrayLike.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ 26);
	
	var _isArray = /*#__PURE__*/__webpack_require__(/*! ./_isArray */ 41);
	
	var _isString = /*#__PURE__*/__webpack_require__(/*! ./_isString */ 53);
	
	/**
	 * Tests whether or not an object is similar to an array.
	 *
	 * @private
	 * @category Type
	 * @category List
	 * @sig * -> Boolean
	 * @param {*} x The object to test.
	 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
	 * @example
	 *
	 *      _isArrayLike([]); //=> true
	 *      _isArrayLike(true); //=> false
	 *      _isArrayLike({}); //=> false
	 *      _isArrayLike({length: 10}); //=> false
	 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
	 */
	
	
	var _isArrayLike = /*#__PURE__*/_curry1(function isArrayLike(x) {
	  if (_isArray(x)) {
	    return true;
	  }
	  if (!x) {
	    return false;
	  }
	  if (typeof x !== 'object') {
	    return false;
	  }
	  if (_isString(x)) {
	    return false;
	  }
	  if (x.nodeType === 1) {
	    return !!x.length;
	  }
	  if (x.length === 0) {
	    return true;
	  }
	  if (x.length > 0) {
	    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
	  }
	  return false;
	});
	module.exports = _isArrayLike;

/***/ },
/* 53 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isString.js ***!
  \*******************************************************************************/
/***/ function(module, exports) {

	function _isString(x) {
	  return Object.prototype.toString.call(x) === '[object String]';
	}
	module.exports = _isString;

/***/ },
/* 54 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xwrap.js ***!
  \****************************************************************************/
/***/ function(module, exports) {

	var XWrap = /*#__PURE__*/function () {
	  function XWrap(fn) {
	    this.f = fn;
	  }
	  XWrap.prototype['@@transducer/init'] = function () {
	    throw new Error('init not implemented on XWrap');
	  };
	  XWrap.prototype['@@transducer/result'] = function (acc) {
	    return acc;
	  };
	  XWrap.prototype['@@transducer/step'] = function (acc, x) {
	    return this.f(acc, x);
	  };
	
	  return XWrap;
	}();
	
	function _xwrap(fn) {
	  return new XWrap(fn);
	}
	module.exports = _xwrap;

/***/ },
/* 55 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/bind.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ 35);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Creates a function that is bound to a context.
	 * Note: `R.bind` does not provide the additional argument-binding capabilities of
	 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.6.0
	 * @category Function
	 * @category Object
	 * @sig (* -> *) -> {*} -> (* -> *)
	 * @param {Function} fn The function to bind to context
	 * @param {Object} thisObj The context to bind `fn` to
	 * @return {Function} A function that will execute in the context of `thisObj`.
	 * @see R.partial
	 * @example
	 *
	 *      var log = R.bind(console.log, console);
	 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
	 *      // logs {a: 2}
	 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
	 */
	
	
	var bind = /*#__PURE__*/_curry2(function bind(fn, thisObj) {
	  return _arity(fn.length, function () {
	    return fn.apply(thisObj, arguments);
	  });
	});
	module.exports = bind;

/***/ },
/* 56 */
/*!***************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xmap.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XMap = /*#__PURE__*/function () {
	
	  function XMap(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }
	  XMap.prototype['@@transducer/init'] = _xfBase.init;
	  XMap.prototype['@@transducer/result'] = _xfBase.result;
	  XMap.prototype['@@transducer/step'] = function (result, input) {
	    return this.xf['@@transducer/step'](result, this.f(input));
	  };
	
	  return XMap;
	}();
	
	var _xmap = /*#__PURE__*/_curry2(function _xmap(f, xf) {
	  return new XMap(f, xf);
	});
	module.exports = _xmap;

/***/ },
/* 57 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/keys.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	var _isArguments = /*#__PURE__*/__webpack_require__(/*! ./internal/_isArguments */ 59);
	
	// cover IE < 9 keys issues
	
	
	var hasEnumBug = ! /*#__PURE__*/{ toString: null }.propertyIsEnumerable('toString');
	var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
	// Safari bug
	var hasArgsEnumBug = /*#__PURE__*/function () {
	  'use strict';
	
	  return arguments.propertyIsEnumerable('length');
	}();
	
	var contains = function contains(list, item) {
	  var idx = 0;
	  while (idx < list.length) {
	    if (list[idx] === item) {
	      return true;
	    }
	    idx += 1;
	  }
	  return false;
	};
	
	/**
	 * Returns a list containing the names of all the enumerable own properties of
	 * the supplied object.
	 * Note that the order of the output array is not guaranteed to be consistent
	 * across different JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig {k: v} -> [k]
	 * @param {Object} obj The object to extract properties from
	 * @return {Array} An array of the object's own properties.
	 * @see R.keysIn, R.values
	 * @example
	 *
	 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
	 */
	var _keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? function keys(obj) {
	  return Object(obj) !== obj ? [] : Object.keys(obj);
	} : function keys(obj) {
	  if (Object(obj) !== obj) {
	    return [];
	  }
	  var prop, nIdx;
	  var ks = [];
	  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
	  for (prop in obj) {
	    if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
	      ks[ks.length] = prop;
	    }
	  }
	  if (hasEnumBug) {
	    nIdx = nonEnumerableProps.length - 1;
	    while (nIdx >= 0) {
	      prop = nonEnumerableProps[nIdx];
	      if (_has(prop, obj) && !contains(ks, prop)) {
	        ks[ks.length] = prop;
	      }
	      nIdx -= 1;
	    }
	  }
	  return ks;
	};
	var keys = /*#__PURE__*/_curry1(_keys);
	module.exports = keys;

/***/ },
/* 58 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_has.js ***!
  \**************************************************************************/
/***/ function(module, exports) {

	function _has(prop, obj) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	module.exports = _has;

/***/ },
/* 59 */
/*!**********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isArguments.js ***!
  \**********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _has = /*#__PURE__*/__webpack_require__(/*! ./_has */ 58);
	
	var toString = Object.prototype.toString;
	var _isArguments = function () {
	  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
	    return toString.call(x) === '[object Arguments]';
	  } : function _isArguments(x) {
	    return _has('callee', x);
	  };
	};
	
	module.exports = _isArguments;

/***/ },
/* 60 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/prop.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var path = /*#__PURE__*/__webpack_require__(/*! ./path */ 61);
	
	/**
	 * Returns a function that when supplied an object returns the indicated
	 * property of that object, if it exists.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig s -> {s: a} -> a | Undefined
	 * @param {String} p The property name
	 * @param {Object} obj The object to query
	 * @return {*} The value at `obj.p`.
	 * @see R.path
	 * @example
	 *
	 *      R.prop('x', {x: 100}); //=> 100
	 *      R.prop('x', {}); //=> undefined
	 */
	
	var prop = /*#__PURE__*/_curry2(function prop(p, obj) {
	  return path([p], obj);
	});
	module.exports = prop;

/***/ },
/* 61 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/path.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Retrieve the value at a given path.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @sig [Idx] -> {a} -> a | Undefined
	 * @param {Array} path The path to use.
	 * @param {Object} obj The object to retrieve the nested property from.
	 * @return {*} The data at `path`.
	 * @see R.prop
	 * @example
	 *
	 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
	 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
	 */
	
	
	var path = /*#__PURE__*/_curry2(function path(paths, obj) {
	  var val = obj;
	  var idx = 0;
	  while (idx < paths.length) {
	    if (val == null) {
	      return;
	    }
	    val = val[paths[idx]];
	    idx += 1;
	  }
	  return val;
	});
	module.exports = path;

/***/ },
/* 62 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/reduce.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	/**
	 * Returns a single item by iterating through the list, successively calling
	 * the iterator function and passing it an accumulator value and the current
	 * value from the array, and then passing the result to the next call.
	 *
	 * The iterator function receives two values: *(acc, value)*. It may use
	 * [`R.reduced`](#reduced) to shortcut the iteration.
	 *
	 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
	 * is *(value, acc)*.
	 *
	 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
	 * arrays), unlike the native `Array.prototype.reduce` method. For more details
	 * on this behavior, see:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
	 *
	 * Dispatches to the `reduce` method of the third argument, if present. When
	 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
	 * shortcuting, as this is not implemented by `reduce`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig ((a, b) -> a) -> a -> [b] -> a
	 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	 *        current element from the array.
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.reduced, R.addIndex, R.reduceRight
	 * @example
	 *
	 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
	 *      //          -               -10
	 *      //         / \              / \
	 *      //        -   4           -6   4
	 *      //       / \              / \
	 *      //      -   3   ==>     -3   3
	 *      //     / \              / \
	 *      //    -   2           -1   2
	 *      //   / \              / \
	 *      //  0   1            0   1
	 *
	 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
	 */
	
	
	var reduce = /*#__PURE__*/_curry3(_reduce);
	module.exports = reduce;

/***/ },
/* 63 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/and.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns `true` if both arguments are `true`; `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Logic
	 * @sig a -> b -> a | b
	 * @param {Any} a
	 * @param {Any} b
	 * @return {Any} the first argument if it is falsy, otherwise the second argument.
	 * @see R.both
	 * @example
	 *
	 *      R.and(true, true); //=> true
	 *      R.and(true, false); //=> false
	 *      R.and(false, true); //=> false
	 *      R.and(false, false); //=> false
	 */
	
	
	var and = /*#__PURE__*/_curry2(function and(a, b) {
	  return a && b;
	});
	module.exports = and;

/***/ },
/* 64 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/any.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xany = /*#__PURE__*/__webpack_require__(/*! ./internal/_xany */ 65);
	
	/**
	 * Returns `true` if at least one of elements of the list match the predicate,
	 * `false` otherwise.
	 *
	 * Dispatches to the `any` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Boolean
	 * @param {Function} fn The predicate function.
	 * @param {Array} list The array to consider.
	 * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
	 *         otherwise.
	 * @see R.all, R.none, R.transduce
	 * @example
	 *
	 *      var lessThan0 = R.flip(R.lt)(0);
	 *      var lessThan2 = R.flip(R.lt)(2);
	 *      R.any(lessThan0)([1, 2]); //=> false
	 *      R.any(lessThan2)([1, 2]); //=> true
	 */
	
	
	var any = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['any'], _xany, function any(fn, list) {
	  var idx = 0;
	  while (idx < list.length) {
	    if (fn(list[idx])) {
	      return true;
	    }
	    idx += 1;
	  }
	  return false;
	}));
	module.exports = any;

/***/ },
/* 65 */
/*!***************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xany.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _reduced = /*#__PURE__*/__webpack_require__(/*! ./_reduced */ 44);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XAny = /*#__PURE__*/function () {
	
	  function XAny(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.any = false;
	  }
	  XAny.prototype['@@transducer/init'] = _xfBase.init;
	  XAny.prototype['@@transducer/result'] = function (result) {
	    if (!this.any) {
	      result = this.xf['@@transducer/step'](result, false);
	    }
	    return this.xf['@@transducer/result'](result);
	  };
	  XAny.prototype['@@transducer/step'] = function (result, input) {
	    if (this.f(input)) {
	      this.any = true;
	      result = _reduced(this.xf['@@transducer/step'](result, true));
	    }
	    return result;
	  };
	
	  return XAny;
	}();
	
	var _xany = /*#__PURE__*/_curry2(function _xany(f, xf) {
	  return new XAny(f, xf);
	});
	module.exports = _xany;

/***/ },
/* 66 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/anyPass.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	var max = /*#__PURE__*/__webpack_require__(/*! ./max */ 47);
	
	var pluck = /*#__PURE__*/__webpack_require__(/*! ./pluck */ 48);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	/**
	 * Takes a list of predicates and returns a predicate that returns true for a
	 * given list of arguments if at least one of the provided predicates is
	 * satisfied by those arguments.
	 *
	 * The function returned is a curried function whose arity matches that of the
	 * highest-arity predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Logic
	 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
	 * @param {Array} predicates An array of predicates to check
	 * @return {Function} The combined predicate
	 * @see R.allPass
	 * @example
	 *
	 *      var isClub = R.propEq('suit', '');
	 *      var isSpade = R.propEq('suit', '');
	 *      var isBlackCard = R.anyPass([isClub, isSpade]);
	 *
	 *      isBlackCard({rank: '10', suit: ''}); //=> true
	 *      isBlackCard({rank: 'Q', suit: ''}); //=> true
	 *      isBlackCard({rank: 'Q', suit: ''}); //=> false
	 */
	
	
	var anyPass = /*#__PURE__*/_curry1(function anyPass(preds) {
	  return curryN(reduce(max, 0, pluck('length', preds)), function () {
	    var idx = 0;
	    var len = preds.length;
	    while (idx < len) {
	      if (preds[idx].apply(this, arguments)) {
	        return true;
	      }
	      idx += 1;
	    }
	    return false;
	  });
	});
	module.exports = anyPass;

/***/ },
/* 67 */
/*!***************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/ap.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	/**
	 * ap applies a list of functions to a list of values.
	 *
	 * Dispatches to the `ap` method of the second argument, if present. Also
	 * treats curried functions as applicatives.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Function
	 * @sig [a -> b] -> [a] -> [b]
	 * @sig Apply f => f (a -> b) -> f a -> f b
	 * @sig (a -> b -> c) -> (a -> b) -> (a -> c)
	 * @param {*} applyF
	 * @param {*} applyX
	 * @return {*}
	 * @example
	 *
	 *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
	 *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
	 *
	 *      // R.ap can also be used as S combinator
	 *      // when only two functions are passed
	 *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
	 * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
	 */
	
	
	var ap = /*#__PURE__*/_curry2(function ap(applyF, applyX) {
	  return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
	    return applyF(x)(applyX(x));
	  } :
	  // else
	  _reduce(function (acc, f) {
	    return _concat(acc, map(f, applyX));
	  }, [], applyF);
	});
	module.exports = ap;

/***/ },
/* 68 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/aperture.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _aperture = /*#__PURE__*/__webpack_require__(/*! ./internal/_aperture */ 69);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xaperture = /*#__PURE__*/__webpack_require__(/*! ./internal/_xaperture */ 70);
	
	/**
	 * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
	 * greater than the length of the list, an empty list is returned.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category List
	 * @sig Number -> [a] -> [[a]]
	 * @param {Number} n The size of the tuples to create
	 * @param {Array} list The list to split into `n`-length tuples
	 * @return {Array} The resulting list of `n`-length tuples
	 * @see R.transduce
	 * @example
	 *
	 *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
	 *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
	 *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
	 */
	
	
	var aperture = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xaperture, _aperture));
	module.exports = aperture;

/***/ },
/* 69 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_aperture.js ***!
  \*******************************************************************************/
/***/ function(module, exports) {

	function _aperture(n, list) {
	  var idx = 0;
	  var limit = list.length - (n - 1);
	  var acc = new Array(limit >= 0 ? limit : 0);
	  while (idx < limit) {
	    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
	    idx += 1;
	  }
	  return acc;
	}
	module.exports = _aperture;

/***/ },
/* 70 */
/*!********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xaperture.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./_concat */ 33);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XAperture = /*#__PURE__*/function () {
	
	  function XAperture(n, xf) {
	    this.xf = xf;
	    this.pos = 0;
	    this.full = false;
	    this.acc = new Array(n);
	  }
	  XAperture.prototype['@@transducer/init'] = _xfBase.init;
	  XAperture.prototype['@@transducer/result'] = function (result) {
	    this.acc = null;
	    return this.xf['@@transducer/result'](result);
	  };
	  XAperture.prototype['@@transducer/step'] = function (result, input) {
	    this.store(input);
	    return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
	  };
	  XAperture.prototype.store = function (input) {
	    this.acc[this.pos] = input;
	    this.pos += 1;
	    if (this.pos === this.acc.length) {
	      this.pos = 0;
	      this.full = true;
	    }
	  };
	  XAperture.prototype.getCopy = function () {
	    return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
	  };
	
	  return XAperture;
	}();
	
	var _xaperture = /*#__PURE__*/_curry2(function _xaperture(n, xf) {
	  return new XAperture(n, xf);
	});
	module.exports = _xaperture;

/***/ },
/* 71 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/append.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a new list containing the contents of the given list, followed by
	 * the given element.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> [a]
	 * @param {*} el The element to add to the end of the new list.
	 * @param {Array} list The list of elements to add a new item to.
	 *        list.
	 * @return {Array} A new list containing the elements of the old list followed by `el`.
	 * @see R.prepend
	 * @example
	 *
	 *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
	 *      R.append('tests', []); //=> ['tests']
	 *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
	 */
	
	
	var append = /*#__PURE__*/_curry2(function append(el, list) {
	  return _concat(list, [el]);
	});
	module.exports = append;

/***/ },
/* 72 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/apply.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Applies function `fn` to the argument list `args`. This is useful for
	 * creating a fixed-arity function from a variadic function. `fn` should be a
	 * bound function if context is significant.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Function
	 * @sig (*... -> a) -> [*] -> a
	 * @param {Function} fn The function which will be called with `args`
	 * @param {Array} args The arguments to call `fn` with
	 * @return {*} result The result, equivalent to `fn(...args)`
	 * @see R.call, R.unapply
	 * @example
	 *
	 *      var nums = [1, 2, 3, -99, 42, 6, 7];
	 *      R.apply(Math.max, nums); //=> 42
	 * @symb R.apply(f, [a, b, c]) = f(a, b, c)
	 */
	
	
	var apply = /*#__PURE__*/_curry2(function apply(fn, args) {
	  return fn.apply(this, args);
	});
	module.exports = apply;

/***/ },
/* 73 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/applySpec.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var apply = /*#__PURE__*/__webpack_require__(/*! ./apply */ 72);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	var max = /*#__PURE__*/__webpack_require__(/*! ./max */ 47);
	
	var pluck = /*#__PURE__*/__webpack_require__(/*! ./pluck */ 48);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	var values = /*#__PURE__*/__webpack_require__(/*! ./values */ 74);
	
	/**
	 * Given a spec object recursively mapping properties to functions, creates a
	 * function producing an object of the same structure, by mapping each property
	 * to the result of calling its associated function with the supplied arguments.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category Function
	 * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
	 * @param {Object} spec an object recursively mapping properties to functions for
	 *        producing the values for these properties.
	 * @return {Function} A function that returns an object of the same structure
	 * as `spec', with each property set to the value returned by calling its
	 * associated function with the supplied arguments.
	 * @see R.converge, R.juxt
	 * @example
	 *
	 *      var getMetrics = R.applySpec({
	 *        sum: R.add,
	 *        nested: { mul: R.multiply }
	 *      });
	 *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
	 * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
	 */
	
	
	var applySpec = /*#__PURE__*/_curry1(function applySpec(spec) {
	  spec = map(function (v) {
	    return typeof v == 'function' ? v : applySpec(v);
	  }, spec);
	  return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
	    var args = arguments;
	    return map(function (f) {
	      return apply(f, args);
	    }, spec);
	  });
	});
	module.exports = applySpec;

/***/ },
/* 74 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/values.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ 57);
	
	/**
	 * Returns a list of all the enumerable own properties of the supplied object.
	 * Note that the order of the output array is not guaranteed across different
	 * JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig {k: v} -> [v]
	 * @param {Object} obj The object to extract values from
	 * @return {Array} An array of the values of the object's own properties.
	 * @see R.valuesIn, R.keys
	 * @example
	 *
	 *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
	 */
	
	
	var values = /*#__PURE__*/_curry1(function values(obj) {
	  var props = keys(obj);
	  var len = props.length;
	  var vals = [];
	  var idx = 0;
	  while (idx < len) {
	    vals[idx] = obj[props[idx]];
	    idx += 1;
	  }
	  return vals;
	});
	module.exports = values;

/***/ },
/* 75 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/applyTo.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	* Takes a value and applies a function to it.
	*
	* This function is also known as the `thrush` combinator.
	*
	* @func
	* @memberOf R
	 * @since v0.25.0
	* @category Function
	* @sig a -> (a -> b) -> b
	* @param {*} x The value
	* @param {Function} f The function to apply
	* @return {*} The result of applying `f` to `x`
	* @example
	*
	*      var t42 = R.applyTo(42);
	*      t42(R.identity); //=> 42
	*      t42(R.add(1)); //=> 43
	*/
	
	
	var applyTo = /*#__PURE__*/_curry2(function applyTo(x, f) {
	  return f(x);
	});
	module.exports = applyTo;

/***/ },
/* 76 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/ascend.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Makes an ascending comparator function out of a function that returns a value
	 * that can be compared with `<` and `>`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.23.0
	 * @category Function
	 * @sig Ord b => (a -> b) -> a -> a -> Number
	 * @param {Function} fn A function of arity one that returns a value that can be compared
	 * @param {*} a The first item to be compared.
	 * @param {*} b The second item to be compared.
	 * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
	 * @see R.descend
	 * @example
	 *
	 *      var byAge = R.ascend(R.prop('age'));
	 *      var people = [
	 *        // ...
	 *      ];
	 *      var peopleByYoungestFirst = R.sort(byAge, people);
	 */
	
	
	var ascend = /*#__PURE__*/_curry3(function ascend(fn, a, b) {
	  var aa = fn(a);
	  var bb = fn(b);
	  return aa < bb ? -1 : aa > bb ? 1 : 0;
	});
	module.exports = ascend;

/***/ },
/* 77 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/assoc.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Makes a shallow clone of an object, setting or overriding the specified
	 * property with the given value. Note that this copies and flattens prototype
	 * properties onto the new object as well. All non-primitive properties are
	 * copied by reference.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Object
	 * @sig String -> a -> {k: v} -> {k: v}
	 * @param {String} prop The property name to set
	 * @param {*} val The new value
	 * @param {Object} obj The object to clone
	 * @return {Object} A new object equivalent to the original except for the changed property.
	 * @see R.dissoc
	 * @example
	 *
	 *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
	 */
	
	
	var assoc = /*#__PURE__*/_curry3(function assoc(prop, val, obj) {
	  var result = {};
	  for (var p in obj) {
	    result[p] = obj[p];
	  }
	  result[prop] = val;
	  return result;
	});
	module.exports = assoc;

/***/ },
/* 78 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/assocPath.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	var _isArray = /*#__PURE__*/__webpack_require__(/*! ./internal/_isArray */ 41);
	
	var _isInteger = /*#__PURE__*/__webpack_require__(/*! ./internal/_isInteger */ 79);
	
	var assoc = /*#__PURE__*/__webpack_require__(/*! ./assoc */ 77);
	
	var isNil = /*#__PURE__*/__webpack_require__(/*! ./isNil */ 80);
	
	/**
	 * Makes a shallow clone of an object, setting or overriding the nodes required
	 * to create the given path, and placing the specific value at the tail end of
	 * that path. Note that this copies and flattens prototype properties onto the
	 * new object as well. All non-primitive properties are copied by reference.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @sig [Idx] -> a -> {a} -> {a}
	 * @param {Array} path the path to set
	 * @param {*} val The new value
	 * @param {Object} obj The object to clone
	 * @return {Object} A new object equivalent to the original except along the specified path.
	 * @see R.dissocPath
	 * @example
	 *
	 *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
	 *
	 *      // Any missing or non-object keys in path will be overridden
	 *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
	 */
	
	
	var assocPath = /*#__PURE__*/_curry3(function assocPath(path, val, obj) {
	  if (path.length === 0) {
	    return val;
	  }
	  var idx = path[0];
	  if (path.length > 1) {
	    var nextObj = !isNil(obj) && _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
	    val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
	  }
	  if (_isInteger(idx) && _isArray(obj)) {
	    var arr = [].concat(obj);
	    arr[idx] = val;
	    return arr;
	  } else {
	    return assoc(idx, val, obj);
	  }
	});
	module.exports = assocPath;

/***/ },
/* 79 */
/*!********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isInteger.js ***!
  \********************************************************************************/
/***/ function(module, exports) {

	/**
	 * Determine if the passed argument is an integer.
	 *
	 * @private
	 * @param {*} n
	 * @category Type
	 * @return {Boolean}
	 */
	module.exports = Number.isInteger || function _isInteger(n) {
	  return n << 0 === n;
	};

/***/ },
/* 80 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/isNil.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Checks if the input value is `null` or `undefined`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Type
	 * @sig * -> Boolean
	 * @param {*} x The value to test.
	 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
	 * @example
	 *
	 *      R.isNil(null); //=> true
	 *      R.isNil(undefined); //=> true
	 *      R.isNil(0); //=> false
	 *      R.isNil([]); //=> false
	 */
	
	
	var isNil = /*#__PURE__*/_curry1(function isNil(x) {
	  return x == null;
	});
	module.exports = isNil;

/***/ },
/* 81 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/binary.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var nAry = /*#__PURE__*/__webpack_require__(/*! ./nAry */ 82);
	
	/**
	 * Wraps a function of any arity (including nullary) in a function that accepts
	 * exactly 2 parameters. Any extraneous parameters will not be passed to the
	 * supplied function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Function
	 * @sig (* -> c) -> (a, b -> c)
	 * @param {Function} fn The function to wrap.
	 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	 *         arity 2.
	 * @see R.nAry, R.unary
	 * @example
	 *
	 *      var takesThreeArgs = function(a, b, c) {
	 *        return [a, b, c];
	 *      };
	 *      takesThreeArgs.length; //=> 3
	 *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
	 *
	 *      var takesTwoArgs = R.binary(takesThreeArgs);
	 *      takesTwoArgs.length; //=> 2
	 *      // Only 2 arguments are passed to the wrapped function
	 *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
	 * @symb R.binary(f)(a, b, c) = f(a, b)
	 */
	
	
	var binary = /*#__PURE__*/_curry1(function binary(fn) {
	  return nAry(2, fn);
	});
	module.exports = binary;

/***/ },
/* 82 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/nAry.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Wraps a function of any arity (including nullary) in a function that accepts
	 * exactly `n` parameters. Any extraneous parameters will not be passed to the
	 * supplied function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig Number -> (* -> a) -> (* -> a)
	 * @param {Number} n The desired arity of the new function.
	 * @param {Function} fn The function to wrap.
	 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	 *         arity `n`.
	 * @see R.binary, R.unary
	 * @example
	 *
	 *      var takesTwoArgs = (a, b) => [a, b];
	 *
	 *      takesTwoArgs.length; //=> 2
	 *      takesTwoArgs(1, 2); //=> [1, 2]
	 *
	 *      var takesOneArg = R.nAry(1, takesTwoArgs);
	 *      takesOneArg.length; //=> 1
	 *      // Only `n` arguments are passed to the wrapped function
	 *      takesOneArg(1, 2); //=> [1, undefined]
	 * @symb R.nAry(0, f)(a, b) = f()
	 * @symb R.nAry(1, f)(a, b) = f(a)
	 * @symb R.nAry(2, f)(a, b) = f(a, b)
	 */
	
	
	var nAry = /*#__PURE__*/_curry2(function nAry(n, fn) {
	  switch (n) {
	    case 0:
	      return function () {
	        return fn.call(this);
	      };
	    case 1:
	      return function (a0) {
	        return fn.call(this, a0);
	      };
	    case 2:
	      return function (a0, a1) {
	        return fn.call(this, a0, a1);
	      };
	    case 3:
	      return function (a0, a1, a2) {
	        return fn.call(this, a0, a1, a2);
	      };
	    case 4:
	      return function (a0, a1, a2, a3) {
	        return fn.call(this, a0, a1, a2, a3);
	      };
	    case 5:
	      return function (a0, a1, a2, a3, a4) {
	        return fn.call(this, a0, a1, a2, a3, a4);
	      };
	    case 6:
	      return function (a0, a1, a2, a3, a4, a5) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5);
	      };
	    case 7:
	      return function (a0, a1, a2, a3, a4, a5, a6) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
	      };
	    case 8:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
	      };
	    case 9:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
	      };
	    case 10:
	      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	      };
	    default:
	      throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
	  }
	});
	module.exports = nAry;

/***/ },
/* 83 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/both.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isFunction = /*#__PURE__*/__webpack_require__(/*! ./internal/_isFunction */ 84);
	
	var and = /*#__PURE__*/__webpack_require__(/*! ./and */ 63);
	
	var lift = /*#__PURE__*/__webpack_require__(/*! ./lift */ 85);
	
	/**
	 * A function which calls the two provided functions and returns the `&&`
	 * of the results.
	 * It returns the result of the first function if it is false-y and the result
	 * of the second function otherwise. Note that this is short-circuited,
	 * meaning that the second function will not be invoked if the first returns a
	 * false-y value.
	 *
	 * In addition to functions, `R.both` also accepts any fantasy-land compatible
	 * applicative functor.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category Logic
	 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	 * @param {Function} f A predicate
	 * @param {Function} g Another predicate
	 * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
	 * @see R.and
	 * @example
	 *
	 *      var gt10 = R.gt(R.__, 10)
	 *      var lt20 = R.lt(R.__, 20)
	 *      var f = R.both(gt10, lt20);
	 *      f(15); //=> true
	 *      f(30); //=> false
	 */
	
	
	var both = /*#__PURE__*/_curry2(function both(f, g) {
	  return _isFunction(f) ? function _both() {
	    return f.apply(this, arguments) && g.apply(this, arguments);
	  } : lift(and)(f, g);
	});
	module.exports = both;

/***/ },
/* 84 */
/*!*********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isFunction.js ***!
  \*********************************************************************************/
/***/ function(module, exports) {

	function _isFunction(x) {
	  return Object.prototype.toString.call(x) === '[object Function]';
	}
	module.exports = _isFunction;

/***/ },
/* 85 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/lift.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var liftN = /*#__PURE__*/__webpack_require__(/*! ./liftN */ 86);
	
	/**
	 * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
	 * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Function
	 * @sig (*... -> *) -> ([*]... -> [*])
	 * @param {Function} fn The function to lift into higher context
	 * @return {Function} The lifted function.
	 * @see R.liftN
	 * @example
	 *
	 *      var madd3 = R.lift((a, b, c) => a + b + c);
	 *
	 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	 *
	 *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
	 *
	 *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
	 */
	
	
	var lift = /*#__PURE__*/_curry1(function lift(fn) {
	  return liftN(fn.length, fn);
	});
	module.exports = lift;

/***/ },
/* 86 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/liftN.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var ap = /*#__PURE__*/__webpack_require__(/*! ./ap */ 67);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	/**
	 * "lifts" a function to be the specified arity, so that it may "map over" that
	 * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Function
	 * @sig Number -> (*... -> *) -> ([*]... -> [*])
	 * @param {Function} fn The function to lift into higher context
	 * @return {Function} The lifted function.
	 * @see R.lift, R.ap
	 * @example
	 *
	 *      var madd3 = R.liftN(3, (...args) => R.sum(args));
	 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
	 */
	
	
	var liftN = /*#__PURE__*/_curry2(function liftN(arity, fn) {
	  var lifted = curryN(arity, fn);
	  return curryN(arity, function () {
	    return _reduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
	  });
	});
	module.exports = liftN;

/***/ },
/* 87 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/call.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var curry = /*#__PURE__*/__webpack_require__(/*! ./curry */ 88);
	
	/**
	 * Returns the result of calling its first argument with the remaining
	 * arguments. This is occasionally useful as a converging function for
	 * [`R.converge`](#converge): the first branch can produce a function while the
	 * remaining branches produce values to be passed to that function as its
	 * arguments.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Function
	 * @sig (*... -> a),*... -> a
	 * @param {Function} fn The function to apply to the remaining arguments.
	 * @param {...*} args Any number of positional arguments.
	 * @return {*}
	 * @see R.apply
	 * @example
	 *
	 *      R.call(R.add, 1, 2); //=> 3
	 *
	 *      var indentN = R.pipe(R.repeat(' '),
	 *                           R.join(''),
	 *                           R.replace(/^(?!$)/gm));
	 *
	 *      var format = R.converge(R.call, [
	 *                                  R.pipe(R.prop('indent'), indentN),
	 *                                  R.prop('value')
	 *                              ]);
	 *
	 *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
	 * @symb R.call(f, a, b) = f(a, b)
	 */
	
	
	var call = /*#__PURE__*/curry(function call(fn) {
	  return fn.apply(this, Array.prototype.slice.call(arguments, 1));
	});
	module.exports = call;

/***/ },
/* 88 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/curry.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	/**
	 * Returns a curried equivalent of the provided function. The curried function
	 * has two unusual capabilities. First, its arguments needn't be provided one
	 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
	 * following are equivalent:
	 *
	 *   - `g(1)(2)(3)`
	 *   - `g(1)(2, 3)`
	 *   - `g(1, 2)(3)`
	 *   - `g(1, 2, 3)`
	 *
	 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
	 * "gaps", allowing partial application of any combination of arguments,
	 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
	 * the following are equivalent:
	 *
	 *   - `g(1, 2, 3)`
	 *   - `g(_, 2, 3)(1)`
	 *   - `g(_, _, 3)(1)(2)`
	 *   - `g(_, _, 3)(1, 2)`
	 *   - `g(_, 2)(1)(3)`
	 *   - `g(_, 2)(1, 3)`
	 *   - `g(_, 2)(_, 3)(1)`
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (* -> a) -> (* -> a)
	 * @param {Function} fn The function to curry.
	 * @return {Function} A new, curried function.
	 * @see R.curryN
	 * @example
	 *
	 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
	 *
	 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
	 *      var f = curriedAddFourNumbers(1, 2);
	 *      var g = f(3);
	 *      g(4); //=> 10
	 */
	
	
	var curry = /*#__PURE__*/_curry1(function curry(fn) {
	  return curryN(fn.length, fn);
	});
	module.exports = curry;

/***/ },
/* 89 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/chain.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _makeFlat = /*#__PURE__*/__webpack_require__(/*! ./internal/_makeFlat */ 90);
	
	var _xchain = /*#__PURE__*/__webpack_require__(/*! ./internal/_xchain */ 91);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	/**
	 * `chain` maps a function over a list and concatenates the results. `chain`
	 * is also known as `flatMap` in some libraries
	 *
	 * Dispatches to the `chain` method of the second argument, if present,
	 * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig Chain m => (a -> m b) -> m a -> m b
	 * @param {Function} fn The function to map with
	 * @param {Array} list The list to map over
	 * @return {Array} The result of flat-mapping `list` with `fn`
	 * @example
	 *
	 *      var duplicate = n => [n, n];
	 *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
	 *
	 *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
	 */
	
	
	var chain = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/chain', 'chain'], _xchain, function chain(fn, monad) {
	  if (typeof monad === 'function') {
	    return function (x) {
	      return fn(monad(x))(x);
	    };
	  }
	  return _makeFlat(false)(map(fn, monad));
	}));
	module.exports = chain;

/***/ },
/* 90 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_makeFlat.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _isArrayLike = /*#__PURE__*/__webpack_require__(/*! ./_isArrayLike */ 52);
	
	/**
	 * `_makeFlat` is a helper function that returns a one-level or fully recursive
	 * function based on the flag passed in.
	 *
	 * @private
	 */
	
	
	function _makeFlat(recursive) {
	  return function flatt(list) {
	    var value, jlen, j;
	    var result = [];
	    var idx = 0;
	    var ilen = list.length;
	
	    while (idx < ilen) {
	      if (_isArrayLike(list[idx])) {
	        value = recursive ? flatt(list[idx]) : list[idx];
	        j = 0;
	        jlen = value.length;
	        while (j < jlen) {
	          result[result.length] = value[j];
	          j += 1;
	        }
	      } else {
	        result[result.length] = list[idx];
	      }
	      idx += 1;
	    }
	    return result;
	  };
	}
	module.exports = _makeFlat;

/***/ },
/* 91 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xchain.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _flatCat = /*#__PURE__*/__webpack_require__(/*! ./_flatCat */ 92);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ../map */ 49);
	
	var _xchain = /*#__PURE__*/_curry2(function _xchain(f, xf) {
	  return map(f, _flatCat(xf));
	});
	module.exports = _xchain;

/***/ },
/* 92 */
/*!******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_flatCat.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _forceReduced = /*#__PURE__*/__webpack_require__(/*! ./_forceReduced */ 93);
	
	var _isArrayLike = /*#__PURE__*/__webpack_require__(/*! ./_isArrayLike */ 52);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./_reduce */ 51);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var preservingReduced = function (xf) {
	  return {
	    '@@transducer/init': _xfBase.init,
	    '@@transducer/result': function (result) {
	      return xf['@@transducer/result'](result);
	    },
	    '@@transducer/step': function (result, input) {
	      var ret = xf['@@transducer/step'](result, input);
	      return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
	    }
	  };
	};
	
	var _flatCat = function _xcat(xf) {
	  var rxf = preservingReduced(xf);
	  return {
	    '@@transducer/init': _xfBase.init,
	    '@@transducer/result': function (result) {
	      return rxf['@@transducer/result'](result);
	    },
	    '@@transducer/step': function (result, input) {
	      return !_isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
	    }
	  };
	};
	
	module.exports = _flatCat;

/***/ },
/* 93 */
/*!***********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_forceReduced.js ***!
  \***********************************************************************************/
/***/ function(module, exports) {

	function _forceReduced(x) {
	  return {
	    '@@transducer/value': x,
	    '@@transducer/reduced': true
	  };
	}
	module.exports = _forceReduced;

/***/ },
/* 94 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/clamp.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Restricts a number to be within a range.
	 *
	 * Also works for other ordered types such as Strings and Dates.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category Relation
	 * @sig Ord a => a -> a -> a -> a
	 * @param {Number} minimum The lower limit of the clamp (inclusive)
	 * @param {Number} maximum The upper limit of the clamp (inclusive)
	 * @param {Number} value Value to be clamped
	 * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
	 * @example
	 *
	 *      R.clamp(1, 10, -5) // => 1
	 *      R.clamp(1, 10, 15) // => 10
	 *      R.clamp(1, 10, 4)  // => 4
	 */
	
	
	var clamp = /*#__PURE__*/_curry3(function clamp(min, max, value) {
	  if (min > max) {
	    throw new Error('min must not be greater than max in clamp(min, max, value)');
	  }
	  return value < min ? min : value > max ? max : value;
	});
	module.exports = clamp;

/***/ },
/* 95 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/clone.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _clone = /*#__PURE__*/__webpack_require__(/*! ./internal/_clone */ 96);
	
	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Creates a deep copy of the value which may contain (nested) `Array`s and
	 * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
	 * assigned by reference rather than copied
	 *
	 * Dispatches to a `clone` method if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig {*} -> {*}
	 * @param {*} value The object or array to clone
	 * @return {*} A deeply cloned copy of `val`
	 * @example
	 *
	 *      var objects = [{}, {}, {}];
	 *      var objectsClone = R.clone(objects);
	 *      objects === objectsClone; //=> false
	 *      objects[0] === objectsClone[0]; //=> false
	 */
	
	
	var clone = /*#__PURE__*/_curry1(function clone(value) {
	  return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
	});
	module.exports = clone;

/***/ },
/* 96 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_clone.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _cloneRegExp = /*#__PURE__*/__webpack_require__(/*! ./_cloneRegExp */ 97);
	
	var type = /*#__PURE__*/__webpack_require__(/*! ../type */ 98);
	
	/**
	 * Copies an object.
	 *
	 * @private
	 * @param {*} value The value to be copied
	 * @param {Array} refFrom Array containing the source references
	 * @param {Array} refTo Array containing the copied source references
	 * @param {Boolean} deep Whether or not to perform deep cloning.
	 * @return {*} The copied value.
	 */
	
	
	function _clone(value, refFrom, refTo, deep) {
	  var copy = function copy(copiedValue) {
	    var len = refFrom.length;
	    var idx = 0;
	    while (idx < len) {
	      if (value === refFrom[idx]) {
	        return refTo[idx];
	      }
	      idx += 1;
	    }
	    refFrom[idx + 1] = value;
	    refTo[idx + 1] = copiedValue;
	    for (var key in value) {
	      copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
	    }
	    return copiedValue;
	  };
	  switch (type(value)) {
	    case 'Object':
	      return copy({});
	    case 'Array':
	      return copy([]);
	    case 'Date':
	      return new Date(value.valueOf());
	    case 'RegExp':
	      return _cloneRegExp(value);
	    default:
	      return value;
	  }
	}
	module.exports = _clone;

/***/ },
/* 97 */
/*!**********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_cloneRegExp.js ***!
  \**********************************************************************************/
/***/ function(module, exports) {

	function _cloneRegExp(pattern) {
	                                  return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
	}
	module.exports = _cloneRegExp;

/***/ },
/* 98 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/type.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Gives a single-word string description of the (native) type of a value,
	 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
	 * attempt to distinguish user Object types any further, reporting them all as
	 * 'Object'.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Type
	 * @sig (* -> {*}) -> String
	 * @param {*} val The value to test
	 * @return {String}
	 * @example
	 *
	 *      R.type({}); //=> "Object"
	 *      R.type(1); //=> "Number"
	 *      R.type(false); //=> "Boolean"
	 *      R.type('s'); //=> "String"
	 *      R.type(null); //=> "Null"
	 *      R.type([]); //=> "Array"
	 *      R.type(/[A-z]/); //=> "RegExp"
	 *      R.type(() => {}); //=> "Function"
	 *      R.type(undefined); //=> "Undefined"
	 */
	
	
	var type = /*#__PURE__*/_curry1(function type(val) {
	  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
	});
	module.exports = type;

/***/ },
/* 99 */
/*!***********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/comparator.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Makes a comparator function out of a function that reports whether the first
	 * element is less than the second.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
	 * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
	 * is less than the second, `false` otherwise
	 * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
	 * @example
	 *
	 *      var byAge = R.comparator((a, b) => a.age < b.age);
	 *      var people = [
	 *        // ...
	 *      ];
	 *      var peopleByIncreasingAge = R.sort(byAge, people);
	 */
	
	
	var comparator = /*#__PURE__*/_curry1(function comparator(pred) {
	  return function (a, b) {
	    return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
	  };
	});
	module.exports = comparator;

/***/ },
/* 100 */
/*!***********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/complement.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var lift = /*#__PURE__*/__webpack_require__(/*! ./lift */ 85);
	
	var not = /*#__PURE__*/__webpack_require__(/*! ./not */ 101);
	
	/**
	 * Takes a function `f` and returns a function `g` such that if called with the same arguments
	 * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
	 *
	 * `R.complement` may be applied to any functor
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category Logic
	 * @sig (*... -> *) -> (*... -> Boolean)
	 * @param {Function} f
	 * @return {Function}
	 * @see R.not
	 * @example
	 *
	 *      var isNotNil = R.complement(R.isNil);
	 *      isNil(null); //=> true
	 *      isNotNil(null); //=> false
	 *      isNil(7); //=> false
	 *      isNotNil(7); //=> true
	 */
	
	
	var complement = /*#__PURE__*/lift(not);
	module.exports = complement;

/***/ },
/* 101 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/not.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * A function that returns the `!` of its argument. It will return `true` when
	 * passed false-y value, and `false` when passed a truth-y one.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Logic
	 * @sig * -> Boolean
	 * @param {*} a any value
	 * @return {Boolean} the logical inverse of passed argument.
	 * @see R.complement
	 * @example
	 *
	 *      R.not(true); //=> false
	 *      R.not(false); //=> true
	 *      R.not(0); //=> true
	 *      R.not(1); //=> false
	 */
	
	
	var not = /*#__PURE__*/_curry1(function not(a) {
	  return !a;
	});
	module.exports = not;

/***/ },
/* 102 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/compose.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var pipe = /*#__PURE__*/__webpack_require__(/*! ./pipe */ 103);
	
	var reverse = /*#__PURE__*/__webpack_require__(/*! ./reverse */ 108);
	
	/**
	 * Performs right-to-left function composition. The rightmost function may have
	 * any arity; the remaining functions must be unary.
	 *
	 * **Note:** The result of compose is not automatically curried.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
	 * @param {...Function} ...functions The functions to compose
	 * @return {Function}
	 * @see R.pipe
	 * @example
	 *
	 *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
	 *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
	 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
	 *
	 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
	 *
	 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
	 */
	
	
	function compose() {
	  if (arguments.length === 0) {
	    throw new Error('compose requires at least one argument');
	  }
	  return pipe.apply(this, reverse(arguments));
	}
	module.exports = compose;

/***/ },
/* 103 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pipe.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ 35);
	
	var _pipe = /*#__PURE__*/__webpack_require__(/*! ./internal/_pipe */ 104);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	var tail = /*#__PURE__*/__webpack_require__(/*! ./tail */ 105);
	
	/**
	 * Performs left-to-right function composition. The leftmost function may have
	 * any arity; the remaining functions must be unary.
	 *
	 * In some libraries this function is named `sequence`.
	 *
	 * **Note:** The result of pipe is not automatically curried.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
	 * @param {...Function} functions
	 * @return {Function}
	 * @see R.compose
	 * @example
	 *
	 *      var f = R.pipe(Math.pow, R.negate, R.inc);
	 *
	 *      f(3, 4); // -(3^4) + 1
	 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
	 */
	
	
	function pipe() {
	  if (arguments.length === 0) {
	    throw new Error('pipe requires at least one argument');
	  }
	  return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
	}
	module.exports = pipe;

/***/ },
/* 104 */
/*!***************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_pipe.js ***!
  \***************************************************************************/
/***/ function(module, exports) {

	function _pipe(f, g) {
	  return function () {
	    return g.call(this, f.apply(this, arguments));
	  };
	}
	module.exports = _pipe;

/***/ },
/* 105 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/tail.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _checkForMethod = /*#__PURE__*/__webpack_require__(/*! ./internal/_checkForMethod */ 106);
	
	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Returns all but the first element of the given list or string (or object
	 * with a `tail` method).
	 *
	 * Dispatches to the `slice` method of the first argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [a]
	 * @sig String -> String
	 * @param {*} list
	 * @return {*}
	 * @see R.head, R.init, R.last
	 * @example
	 *
	 *      R.tail([1, 2, 3]);  //=> [2, 3]
	 *      R.tail([1, 2]);     //=> [2]
	 *      R.tail([1]);        //=> []
	 *      R.tail([]);         //=> []
	 *
	 *      R.tail('abc');  //=> 'bc'
	 *      R.tail('ab');   //=> 'b'
	 *      R.tail('a');    //=> ''
	 *      R.tail('');     //=> ''
	 */
	
	
	var tail = /*#__PURE__*/_curry1( /*#__PURE__*/_checkForMethod('tail', /*#__PURE__*/slice(1, Infinity)));
	module.exports = tail;

/***/ },
/* 106 */
/*!*************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_checkForMethod.js ***!
  \*************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _isArray = /*#__PURE__*/__webpack_require__(/*! ./_isArray */ 41);
	
	/**
	 * This checks whether a function has a [methodname] function. If it isn't an
	 * array it will execute that function otherwise it will default to the ramda
	 * implementation.
	 *
	 * @private
	 * @param {Function} fn ramda implemtation
	 * @param {String} methodname property to check for a custom implementation
	 * @return {Object} Whatever the return value of the method is.
	 */
	
	
	function _checkForMethod(methodname, fn) {
	  return function () {
	    var length = arguments.length;
	    if (length === 0) {
	      return fn();
	    }
	    var obj = arguments[length - 1];
	    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
	  };
	}
	module.exports = _checkForMethod;

/***/ },
/* 107 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/slice.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _checkForMethod = /*#__PURE__*/__webpack_require__(/*! ./internal/_checkForMethod */ 106);
	
	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Returns the elements of the given list or string (or object with a `slice`
	 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
	 *
	 * Dispatches to the `slice` method of the third argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.4
	 * @category List
	 * @sig Number -> Number -> [a] -> [a]
	 * @sig Number -> Number -> String -> String
	 * @param {Number} fromIndex The start index (inclusive).
	 * @param {Number} toIndex The end index (exclusive).
	 * @param {*} list
	 * @return {*}
	 * @example
	 *
	 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
	 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
	 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
	 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
	 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
	 */
	
	
	var slice = /*#__PURE__*/_curry3( /*#__PURE__*/_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
	  return Array.prototype.slice.call(list, fromIndex, toIndex);
	}));
	module.exports = slice;

/***/ },
/* 108 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/reverse.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _isString = /*#__PURE__*/__webpack_require__(/*! ./internal/_isString */ 53);
	
	/**
	 * Returns a new list or string with the elements or characters in reverse
	 * order.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [a]
	 * @sig String -> String
	 * @param {Array|String} list
	 * @return {Array|String}
	 * @example
	 *
	 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
	 *      R.reverse([1, 2]);     //=> [2, 1]
	 *      R.reverse([1]);        //=> [1]
	 *      R.reverse([]);         //=> []
	 *
	 *      R.reverse('abc');      //=> 'cba'
	 *      R.reverse('ab');       //=> 'ba'
	 *      R.reverse('a');        //=> 'a'
	 *      R.reverse('');         //=> ''
	 */
	
	
	var reverse = /*#__PURE__*/_curry1(function reverse(list) {
	  return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
	});
	module.exports = reverse;

/***/ },
/* 109 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/composeK.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var chain = /*#__PURE__*/__webpack_require__(/*! ./chain */ 89);
	
	var compose = /*#__PURE__*/__webpack_require__(/*! ./compose */ 102);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	/**
	 * Returns the right-to-left Kleisli composition of the provided functions,
	 * each of which must return a value of a type supported by [`chain`](#chain).
	 *
	 * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), f)`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Function
	 * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
	 * @param {...Function} ...functions The functions to compose
	 * @return {Function}
	 * @see R.pipeK
	 * @example
	 *
	 *       //  get :: String -> Object -> Maybe *
	 *       var get = R.curry((propName, obj) => Maybe(obj[propName]))
	 *
	 *       //  getStateCode :: Maybe String -> Maybe String
	 *       var getStateCode = R.composeK(
	 *         R.compose(Maybe.of, R.toUpper),
	 *         get('state'),
	 *         get('address'),
	 *         get('user'),
	 *       );
	 *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
	 *       getStateCode({}); //=> Maybe.Nothing()
	 * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
	 */
	
	
	function composeK() {
	  if (arguments.length === 0) {
	    throw new Error('composeK requires at least one argument');
	  }
	  var init = Array.prototype.slice.call(arguments);
	  var last = init.pop();
	  return compose(compose.apply(this, map(chain, init)), last);
	}
	module.exports = composeK;

/***/ },
/* 110 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/composeP.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var pipeP = /*#__PURE__*/__webpack_require__(/*! ./pipeP */ 111);
	
	var reverse = /*#__PURE__*/__webpack_require__(/*! ./reverse */ 108);
	
	/**
	 * Performs right-to-left composition of one or more Promise-returning
	 * functions. The rightmost function may have any arity; the remaining
	 * functions must be unary.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Function
	 * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
	 * @param {...Function} functions The functions to compose
	 * @return {Function}
	 * @see R.pipeP
	 * @example
	 *
	 *      var db = {
	 *        users: {
	 *          JOE: {
	 *            name: 'Joe',
	 *            followers: ['STEVE', 'SUZY']
	 *          }
	 *        }
	 *      }
	 *
	 *      // We'll pretend to do a db lookup which returns a promise
	 *      var lookupUser = (userId) => Promise.resolve(db.users[userId])
	 *      var lookupFollowers = (user) => Promise.resolve(user.followers)
	 *      lookupUser('JOE').then(lookupFollowers)
	 *
	 *      //  followersForUser :: String -> Promise [UserId]
	 *      var followersForUser = R.composeP(lookupFollowers, lookupUser);
	 *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
	 *      // Followers: ["STEVE","SUZY"]
	 */
	
	
	function composeP() {
	  if (arguments.length === 0) {
	    throw new Error('composeP requires at least one argument');
	  }
	  return pipeP.apply(this, reverse(arguments));
	}
	module.exports = composeP;

/***/ },
/* 111 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pipeP.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ 35);
	
	var _pipeP = /*#__PURE__*/__webpack_require__(/*! ./internal/_pipeP */ 112);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	var tail = /*#__PURE__*/__webpack_require__(/*! ./tail */ 105);
	
	/**
	 * Performs left-to-right composition of one or more Promise-returning
	 * functions. The leftmost function may have any arity; the remaining functions
	 * must be unary.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Function
	 * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
	 * @param {...Function} functions
	 * @return {Function}
	 * @see R.composeP
	 * @example
	 *
	 *      //  followersForUser :: String -> Promise [User]
	 *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
	 */
	
	
	function pipeP() {
	  if (arguments.length === 0) {
	    throw new Error('pipeP requires at least one argument');
	  }
	  return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
	}
	module.exports = pipeP;

/***/ },
/* 112 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_pipeP.js ***!
  \****************************************************************************/
/***/ function(module, exports) {

	function _pipeP(f, g) {
	  return function () {
	    var ctx = this;
	    return f.apply(ctx, arguments).then(function (x) {
	      return g.call(ctx, x);
	    });
	  };
	}
	module.exports = _pipeP;

/***/ },
/* 113 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/concat.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isArray = /*#__PURE__*/__webpack_require__(/*! ./internal/_isArray */ 41);
	
	var _isFunction = /*#__PURE__*/__webpack_require__(/*! ./internal/_isFunction */ 84);
	
	var _isString = /*#__PURE__*/__webpack_require__(/*! ./internal/_isString */ 53);
	
	var toString = /*#__PURE__*/__webpack_require__(/*! ./toString */ 114);
	
	/**
	 * Returns the result of concatenating the given lists or strings.
	 *
	 * Note: `R.concat` expects both arguments to be of the same type,
	 * unlike the native `Array.prototype.concat` method. It will throw
	 * an error if you `concat` an Array with a non-Array value.
	 *
	 * Dispatches to the `concat` method of the first argument, if present.
	 * Can also concatenate two members of a [fantasy-land
	 * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [a] -> [a]
	 * @sig String -> String -> String
	 * @param {Array|String} firstList The first list
	 * @param {Array|String} secondList The second list
	 * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
	 * `secondList`.
	 *
	 * @example
	 *
	 *      R.concat('ABC', 'DEF'); // 'ABCDEF'
	 *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
	 *      R.concat([], []); //=> []
	 */
	
	
	var concat = /*#__PURE__*/_curry2(function concat(a, b) {
	  if (_isArray(a)) {
	    if (_isArray(b)) {
	      return a.concat(b);
	    }
	    throw new TypeError(toString(b) + ' is not an array');
	  }
	  if (_isString(a)) {
	    if (_isString(b)) {
	      return a + b;
	    }
	    throw new TypeError(toString(b) + ' is not a string');
	  }
	  if (a != null && _isFunction(a['fantasy-land/concat'])) {
	    return a['fantasy-land/concat'](b);
	  }
	  if (a != null && _isFunction(a.concat)) {
	    return a.concat(b);
	  }
	  throw new TypeError(toString(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
	});
	module.exports = concat;

/***/ },
/* 114 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/toString.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _toString = /*#__PURE__*/__webpack_require__(/*! ./internal/_toString */ 115);
	
	/**
	 * Returns the string representation of the given value. `eval`'ing the output
	 * should result in a value equivalent to the input value. Many of the built-in
	 * `toString` methods do not satisfy this requirement.
	 *
	 * If the given value is an `[object Object]` with a `toString` method other
	 * than `Object.prototype.toString`, this method is invoked with no arguments
	 * to produce the return value. This means user-defined constructor functions
	 * can provide a suitable `toString` method. For example:
	 *
	 *     function Point(x, y) {
	 *       this.x = x;
	 *       this.y = y;
	 *     }
	 *
	 *     Point.prototype.toString = function() {
	 *       return 'new Point(' + this.x + ', ' + this.y + ')';
	 *     };
	 *
	 *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category String
	 * @sig * -> String
	 * @param {*} val
	 * @return {String}
	 * @example
	 *
	 *      R.toString(42); //=> '42'
	 *      R.toString('abc'); //=> '"abc"'
	 *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
	 *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
	 *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
	 */
	
	
	var toString = /*#__PURE__*/_curry1(function toString(val) {
	  return _toString(val, []);
	});
	module.exports = toString;

/***/ },
/* 115 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_toString.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _contains = /*#__PURE__*/__webpack_require__(/*! ./_contains */ 116);
	
	var _map = /*#__PURE__*/__webpack_require__(/*! ./_map */ 50);
	
	var _quote = /*#__PURE__*/__webpack_require__(/*! ./_quote */ 124);
	
	var _toISOString = /*#__PURE__*/__webpack_require__(/*! ./_toISOString */ 125);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ../keys */ 57);
	
	var reject = /*#__PURE__*/__webpack_require__(/*! ../reject */ 126);
	
	function _toString(x, seen) {
	  var recur = function recur(y) {
	    var xs = seen.concat([x]);
	    return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
	  };
	
	  //  mapPairs :: (Object, [String]) -> [String]
	  var mapPairs = function (obj, keys) {
	    return _map(function (k) {
	      return _quote(k) + ': ' + recur(obj[k]);
	    }, keys.slice().sort());
	  };
	
	  switch (Object.prototype.toString.call(x)) {
	    case '[object Arguments]':
	      return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
	    case '[object Array]':
	      return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
	        return (/^\d+$/.test(k)
	        );
	      }, keys(x)))).join(', ') + ']';
	    case '[object Boolean]':
	      return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
	    case '[object Date]':
	      return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
	    case '[object Null]':
	      return 'null';
	    case '[object Number]':
	      return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
	    case '[object String]':
	      return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
	    case '[object Undefined]':
	      return 'undefined';
	    default:
	      if (typeof x.toString === 'function') {
	        var repr = x.toString();
	        if (repr !== '[object Object]') {
	          return repr;
	        }
	      }
	      return '{' + mapPairs(x, keys(x)).join(', ') + '}';
	  }
	}
	module.exports = _toString;

/***/ },
/* 116 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_contains.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _indexOf = /*#__PURE__*/__webpack_require__(/*! ./_indexOf */ 117);
	
	function _contains(a, list) {
	  return _indexOf(list, a, 0) >= 0;
	}
	module.exports = _contains;

/***/ },
/* 117 */
/*!******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_indexOf.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var equals = /*#__PURE__*/__webpack_require__(/*! ../equals */ 118);
	
	function _indexOf(list, a, idx) {
	  var inf, item;
	  // Array.prototype.indexOf doesn't exist below IE9
	  if (typeof list.indexOf === 'function') {
	    switch (typeof a) {
	      case 'number':
	        if (a === 0) {
	          // manually crawl the list to distinguish between +0 and -0
	          inf = 1 / a;
	          while (idx < list.length) {
	            item = list[idx];
	            if (item === 0 && 1 / item === inf) {
	              return idx;
	            }
	            idx += 1;
	          }
	          return -1;
	        } else if (a !== a) {
	          // NaN
	          while (idx < list.length) {
	            item = list[idx];
	            if (typeof item === 'number' && item !== item) {
	              return idx;
	            }
	            idx += 1;
	          }
	          return -1;
	        }
	        // non-zero numbers can utilise Set
	        return list.indexOf(a, idx);
	
	      // all these types can utilise Set
	      case 'string':
	      case 'boolean':
	      case 'function':
	      case 'undefined':
	        return list.indexOf(a, idx);
	
	      case 'object':
	        if (a === null) {
	          // null can utilise Set
	          return list.indexOf(a, idx);
	        }
	    }
	  }
	  // anything else not covered above, defer to R.equals
	  while (idx < list.length) {
	    if (equals(list[idx], a)) {
	      return idx;
	    }
	    idx += 1;
	  }
	  return -1;
	}
	module.exports = _indexOf;

/***/ },
/* 118 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/equals.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _equals = /*#__PURE__*/__webpack_require__(/*! ./internal/_equals */ 119);
	
	/**
	 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
	 * cyclical data structures.
	 *
	 * Dispatches symmetrically to the `equals` methods of both arguments, if
	 * present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.15.0
	 * @category Relation
	 * @sig a -> b -> Boolean
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 * @example
	 *
	 *      R.equals(1, 1); //=> true
	 *      R.equals(1, '1'); //=> false
	 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
	 *
	 *      var a = {}; a.v = a;
	 *      var b = {}; b.v = b;
	 *      R.equals(a, b); //=> true
	 */
	
	
	var equals = /*#__PURE__*/_curry2(function equals(a, b) {
	  return _equals(a, b, [], []);
	});
	module.exports = equals;

/***/ },
/* 119 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_equals.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arrayFromIterator = /*#__PURE__*/__webpack_require__(/*! ./_arrayFromIterator */ 120);
	
	var _containsWith = /*#__PURE__*/__webpack_require__(/*! ./_containsWith */ 121);
	
	var _functionName = /*#__PURE__*/__webpack_require__(/*! ./_functionName */ 122);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./_has */ 58);
	
	var identical = /*#__PURE__*/__webpack_require__(/*! ../identical */ 123);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ../keys */ 57);
	
	var type = /*#__PURE__*/__webpack_require__(/*! ../type */ 98);
	
	/**
	 * private _uniqContentEquals function.
	 * That function is checking equality of 2 iterator contents with 2 assumptions
	 * - iterators lengths are the same
	 * - iterators values are unique
	 *
	 * false-positive result will be returned for comparision of, e.g.
	 * - [1,2,3] and [1,2,3,4]
	 * - [1,1,1] and [1,2,3]
	 * */
	
	function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
	  var a = _arrayFromIterator(aIterator);
	  var b = _arrayFromIterator(bIterator);
	
	  function eq(_a, _b) {
	    return _equals(_a, _b, stackA.slice(), stackB.slice());
	  }
	
	  // if *a* array contains any element that is not included in *b*
	  return !_containsWith(function (b, aItem) {
	    return !_containsWith(eq, aItem, b);
	  }, b, a);
	}
	
	function _equals(a, b, stackA, stackB) {
	  if (identical(a, b)) {
	    return true;
	  }
	
	  var typeA = type(a);
	
	  if (typeA !== type(b)) {
	    return false;
	  }
	
	  if (a == null || b == null) {
	    return false;
	  }
	
	  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
	    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
	  }
	
	  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
	    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
	  }
	
	  switch (typeA) {
	    case 'Arguments':
	    case 'Array':
	    case 'Object':
	      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
	        return a === b;
	      }
	      break;
	    case 'Boolean':
	    case 'Number':
	    case 'String':
	      if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
	        return false;
	      }
	      break;
	    case 'Date':
	      if (!identical(a.valueOf(), b.valueOf())) {
	        return false;
	      }
	      break;
	    case 'Error':
	      return a.name === b.name && a.message === b.message;
	    case 'RegExp':
	      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
	        return false;
	      }
	      break;
	  }
	
	  var idx = stackA.length - 1;
	  while (idx >= 0) {
	    if (stackA[idx] === a) {
	      return stackB[idx] === b;
	    }
	    idx -= 1;
	  }
	
	  switch (typeA) {
	    case 'Map':
	      if (a.size !== b.size) {
	        return false;
	      }
	
	      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
	    case 'Set':
	      if (a.size !== b.size) {
	        return false;
	      }
	
	      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
	    case 'Arguments':
	    case 'Array':
	    case 'Object':
	    case 'Boolean':
	    case 'Number':
	    case 'String':
	    case 'Date':
	    case 'Error':
	    case 'RegExp':
	    case 'Int8Array':
	    case 'Uint8Array':
	    case 'Uint8ClampedArray':
	    case 'Int16Array':
	    case 'Uint16Array':
	    case 'Int32Array':
	    case 'Uint32Array':
	    case 'Float32Array':
	    case 'Float64Array':
	    case 'ArrayBuffer':
	      break;
	    default:
	      // Values of other types are only equal if identical.
	      return false;
	  }
	
	  var keysA = keys(a);
	  if (keysA.length !== keys(b).length) {
	    return false;
	  }
	
	  var extendedStackA = stackA.concat([a]);
	  var extendedStackB = stackB.concat([b]);
	
	  idx = keysA.length - 1;
	  while (idx >= 0) {
	    var key = keysA[idx];
	    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
	      return false;
	    }
	    idx -= 1;
	  }
	  return true;
	}
	module.exports = _equals;

/***/ },
/* 120 */
/*!****************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_arrayFromIterator.js ***!
  \****************************************************************************************/
/***/ function(module, exports) {

	function _arrayFromIterator(iter) {
	  var list = [];
	  var next;
	  while (!(next = iter.next()).done) {
	    list.push(next.value);
	  }
	  return list;
	}
	module.exports = _arrayFromIterator;

/***/ },
/* 121 */
/*!***********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_containsWith.js ***!
  \***********************************************************************************/
/***/ function(module, exports) {

	function _containsWith(pred, x, list) {
	  var idx = 0;
	  var len = list.length;
	
	  while (idx < len) {
	    if (pred(x, list[idx])) {
	      return true;
	    }
	    idx += 1;
	  }
	  return false;
	}
	module.exports = _containsWith;

/***/ },
/* 122 */
/*!***********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_functionName.js ***!
  \***********************************************************************************/
/***/ function(module, exports) {

	function _functionName(f) {
	  // String(x => x) evaluates to "x => x", so the pattern may not match.
	  var match = String(f).match(/^function (\w*)/);
	  return match == null ? '' : match[1];
	}
	module.exports = _functionName;

/***/ },
/* 123 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/identical.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns true if its arguments are identical, false otherwise. Values are
	 * identical if they reference the same memory. `NaN` is identical to `NaN`;
	 * `0` and `-0` are not identical.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.15.0
	 * @category Relation
	 * @sig a -> a -> Boolean
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 * @example
	 *
	 *      var o = {};
	 *      R.identical(o, o); //=> true
	 *      R.identical(1, 1); //=> true
	 *      R.identical(1, '1'); //=> false
	 *      R.identical([], []); //=> false
	 *      R.identical(0, -0); //=> false
	 *      R.identical(NaN, NaN); //=> true
	 */
	
	
	var identical = /*#__PURE__*/_curry2(function identical(a, b) {
	  // SameValue algorithm
	  if (a === b) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return a !== 0 || 1 / a === 1 / b;
	  } else {
	    // Step 6.a: NaN == NaN
	    return a !== a && b !== b;
	  }
	});
	module.exports = identical;

/***/ },
/* 124 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_quote.js ***!
  \****************************************************************************/
/***/ function(module, exports) {

	function _quote(s) {
	  var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
	  .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
	
	  return '"' + escaped.replace(/"/g, '\\"') + '"';
	}
	module.exports = _quote;

/***/ },
/* 125 */
/*!**********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_toISOString.js ***!
  \**********************************************************************************/
/***/ function(module, exports) {

	/**
	 * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
	 */
	var pad = function pad(n) {
	  return (n < 10 ? '0' : '') + n;
	};
	
	var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
	  return d.toISOString();
	} : function _toISOString(d) {
	  return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
	};
	
	module.exports = _toISOString;

/***/ },
/* 126 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/reject.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _complement = /*#__PURE__*/__webpack_require__(/*! ./internal/_complement */ 127);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var filter = /*#__PURE__*/__webpack_require__(/*! ./filter */ 128);
	
	/**
	 * The complement of [`filter`](#filter).
	 *
	 * Acts as a transducer if a transformer is given in list position. Filterable
	 * objects include plain objects or any object that has a filter method such
	 * as `Array`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Filterable f => (a -> Boolean) -> f a -> f a
	 * @param {Function} pred
	 * @param {Array} filterable
	 * @return {Array}
	 * @see R.filter, R.transduce, R.addIndex
	 * @example
	 *
	 *      var isOdd = (n) => n % 2 === 1;
	 *
	 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
	 *
	 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	 */
	
	
	var reject = /*#__PURE__*/_curry2(function reject(pred, filterable) {
	  return filter(_complement(pred), filterable);
	});
	module.exports = reject;

/***/ },
/* 127 */
/*!*********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_complement.js ***!
  \*********************************************************************************/
/***/ function(module, exports) {

	function _complement(f) {
	  return function () {
	    return !f.apply(this, arguments);
	  };
	}
	module.exports = _complement;

/***/ },
/* 128 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/filter.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _filter = /*#__PURE__*/__webpack_require__(/*! ./internal/_filter */ 129);
	
	var _isObject = /*#__PURE__*/__webpack_require__(/*! ./internal/_isObject */ 130);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var _xfilter = /*#__PURE__*/__webpack_require__(/*! ./internal/_xfilter */ 131);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ 57);
	
	/**
	 * Takes a predicate and a `Filterable`, and returns a new filterable of the
	 * same type containing the members of the given filterable which satisfy the
	 * given predicate. Filterable objects include plain objects or any object
	 * that has a filter method such as `Array`.
	 *
	 * Dispatches to the `filter` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Filterable f => (a -> Boolean) -> f a -> f a
	 * @param {Function} pred
	 * @param {Array} filterable
	 * @return {Array} Filterable
	 * @see R.reject, R.transduce, R.addIndex
	 * @example
	 *
	 *      var isEven = n => n % 2 === 0;
	 *
	 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
	 *
	 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
	 */
	
	
	var filter = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['filter'], _xfilter, function (pred, filterable) {
	  return _isObject(filterable) ? _reduce(function (acc, key) {
	    if (pred(filterable[key])) {
	      acc[key] = filterable[key];
	    }
	    return acc;
	  }, {}, keys(filterable)) :
	  // else
	  _filter(pred, filterable);
	}));
	module.exports = filter;

/***/ },
/* 129 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_filter.js ***!
  \*****************************************************************************/
/***/ function(module, exports) {

	function _filter(fn, list) {
	  var idx = 0;
	  var len = list.length;
	  var result = [];
	
	  while (idx < len) {
	    if (fn(list[idx])) {
	      result[result.length] = list[idx];
	    }
	    idx += 1;
	  }
	  return result;
	}
	module.exports = _filter;

/***/ },
/* 130 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isObject.js ***!
  \*******************************************************************************/
/***/ function(module, exports) {

	function _isObject(x) {
	  return Object.prototype.toString.call(x) === '[object Object]';
	}
	module.exports = _isObject;

/***/ },
/* 131 */
/*!******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xfilter.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XFilter = /*#__PURE__*/function () {
	
	  function XFilter(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }
	  XFilter.prototype['@@transducer/init'] = _xfBase.init;
	  XFilter.prototype['@@transducer/result'] = _xfBase.result;
	  XFilter.prototype['@@transducer/step'] = function (result, input) {
	    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
	  };
	
	  return XFilter;
	}();
	
	var _xfilter = /*#__PURE__*/_curry2(function _xfilter(f, xf) {
	  return new XFilter(f, xf);
	});
	module.exports = _xfilter;

/***/ },
/* 132 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/cond.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ 35);
	
	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	var max = /*#__PURE__*/__webpack_require__(/*! ./max */ 47);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	/**
	 * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
	 * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
	 * to `fn` are applied to each of the predicates in turn until one returns a
	 * "truthy" value, at which point `fn` returns the result of applying its
	 * arguments to the corresponding transformer. If none of the predicates
	 * matches, `fn` returns undefined.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.6.0
	 * @category Logic
	 * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
	 * @param {Array} pairs A list of [predicate, transformer]
	 * @return {Function}
	 * @example
	 *
	 *      var fn = R.cond([
	 *        [R.equals(0),   R.always('water freezes at 0C')],
	 *        [R.equals(100), R.always('water boils at 100C')],
	 *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
	 *      ]);
	 *      fn(0); //=> 'water freezes at 0C'
	 *      fn(50); //=> 'nothing special happens at 50C'
	 *      fn(100); //=> 'water boils at 100C'
	 */
	
	
	var cond = /*#__PURE__*/_curry1(function cond(pairs) {
	  var arity = reduce(max, 0, map(function (pair) {
	    return pair[0].length;
	  }, pairs));
	  return _arity(arity, function () {
	    var idx = 0;
	    while (idx < pairs.length) {
	      if (pairs[idx][0].apply(this, arguments)) {
	        return pairs[idx][1].apply(this, arguments);
	      }
	      idx += 1;
	    }
	  });
	});
	module.exports = cond;

/***/ },
/* 133 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/construct.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var constructN = /*#__PURE__*/__webpack_require__(/*! ./constructN */ 134);
	
	/**
	 * Wraps a constructor function inside a curried function that can be called
	 * with the same arguments and returns the same type.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (* -> {*}) -> (* -> {*})
	 * @param {Function} fn The constructor function to wrap.
	 * @return {Function} A wrapped, curried constructor function.
	 * @see R.invoker
	 * @example
	 *
	 *      // Constructor function
	 *      function Animal(kind) {
	 *        this.kind = kind;
	 *      };
	 *      Animal.prototype.sighting = function() {
	 *        return "It's a " + this.kind + "!";
	 *      }
	 *
	 *      var AnimalConstructor = R.construct(Animal)
	 *
	 *      // Notice we no longer need the 'new' keyword:
	 *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
	 *
	 *      var animalTypes = ["Lion", "Tiger", "Bear"];
	 *      var animalSighting = R.invoker(0, 'sighting');
	 *      var sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
	 *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
	 */
	
	
	var construct = /*#__PURE__*/_curry1(function construct(Fn) {
	  return constructN(Fn.length, Fn);
	});
	module.exports = construct;

/***/ },
/* 134 */
/*!***********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/constructN.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var curry = /*#__PURE__*/__webpack_require__(/*! ./curry */ 88);
	
	var nAry = /*#__PURE__*/__webpack_require__(/*! ./nAry */ 82);
	
	/**
	 * Wraps a constructor function inside a curried function that can be called
	 * with the same arguments and returns the same type. The arity of the function
	 * returned is specified to allow using variadic constructor functions.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.4.0
	 * @category Function
	 * @sig Number -> (* -> {*}) -> (* -> {*})
	 * @param {Number} n The arity of the constructor function.
	 * @param {Function} Fn The constructor function to wrap.
	 * @return {Function} A wrapped, curried constructor function.
	 * @example
	 *
	 *      // Variadic Constructor function
	 *      function Salad() {
	 *        this.ingredients = arguments;
	 *      }
	 *
	 *      Salad.prototype.recipe = function() {
	 *        var instructions = R.map(ingredient => 'Add a dollop of ' + ingredient, this.ingredients);
	 *        return R.join('\n', instructions);
	 *      };
	 *
	 *      var ThreeLayerSalad = R.constructN(3, Salad);
	 *
	 *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
	 *      var salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup');
	 *
	 *      console.log(salad.recipe());
	 *      // Add a dollop of Mayonnaise
	 *      // Add a dollop of Potato Chips
	 *      // Add a dollop of Ketchup
	 */
	
	
	var constructN = /*#__PURE__*/_curry2(function constructN(n, Fn) {
	  if (n > 10) {
	    throw new Error('Constructor with greater than ten arguments');
	  }
	  if (n === 0) {
	    return function () {
	      return new Fn();
	    };
	  }
	  return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
	    switch (arguments.length) {
	      case 1:
	        return new Fn($0);
	      case 2:
	        return new Fn($0, $1);
	      case 3:
	        return new Fn($0, $1, $2);
	      case 4:
	        return new Fn($0, $1, $2, $3);
	      case 5:
	        return new Fn($0, $1, $2, $3, $4);
	      case 6:
	        return new Fn($0, $1, $2, $3, $4, $5);
	      case 7:
	        return new Fn($0, $1, $2, $3, $4, $5, $6);
	      case 8:
	        return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
	      case 9:
	        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
	      case 10:
	        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
	    }
	  }));
	});
	module.exports = constructN;

/***/ },
/* 135 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/contains.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _contains = /*#__PURE__*/__webpack_require__(/*! ./internal/_contains */ 116);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
	 * terms, to at least one element of the given list; `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> Boolean
	 * @param {Object} a The item to compare against.
	 * @param {Array} list The array to consider.
	 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
	 * @see R.any
	 * @example
	 *
	 *      R.contains(3, [1, 2, 3]); //=> true
	 *      R.contains(4, [1, 2, 3]); //=> false
	 *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
	 *      R.contains([42], [[42]]); //=> true
	 */
	
	
	var contains = /*#__PURE__*/_curry2(_contains);
	module.exports = contains;

/***/ },
/* 136 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/converge.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _map = /*#__PURE__*/__webpack_require__(/*! ./internal/_map */ 50);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	var max = /*#__PURE__*/__webpack_require__(/*! ./max */ 47);
	
	var pluck = /*#__PURE__*/__webpack_require__(/*! ./pluck */ 48);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	/**
	 * Accepts a converging function and a list of branching functions and returns
	 * a new function. When invoked, this new function is applied to some
	 * arguments, each branching function is applied to those same arguments. The
	 * results of each branching function are passed as arguments to the converging
	 * function to produce the return value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.4.2
	 * @category Function
	 * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
	 * @param {Function} after A function. `after` will be invoked with the return values of
	 *        `fn1` and `fn2` as its arguments.
	 * @param {Array} functions A list of functions.
	 * @return {Function} A new function.
	 * @see R.useWith
	 * @example
	 *
	 *      var average = R.converge(R.divide, [R.sum, R.length])
	 *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
	 *
	 *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
	 *      strangeConcat("Yodel") //=> "YODELyodel"
	 *
	 * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
	 */
	
	
	var converge = /*#__PURE__*/_curry2(function converge(after, fns) {
	  return curryN(reduce(max, 0, pluck('length', fns)), function () {
	    var args = arguments;
	    var context = this;
	    return after.apply(context, _map(function (fn) {
	      return fn.apply(context, args);
	    }, fns));
	  });
	});
	module.exports = converge;

/***/ },
/* 137 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/countBy.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var reduceBy = /*#__PURE__*/__webpack_require__(/*! ./reduceBy */ 138);
	
	/**
	 * Counts the elements of a list according to how many match each value of a
	 * key generated by the supplied function. Returns an object mapping the keys
	 * produced by `fn` to the number of occurrences in the list. Note that all
	 * keys are coerced to strings because of how JavaScript objects work.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig (a -> String) -> [a] -> {*}
	 * @param {Function} fn The function used to map values to keys.
	 * @param {Array} list The list to count elements from.
	 * @return {Object} An object mapping keys to number of occurrences in the list.
	 * @example
	 *
	 *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
	 *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
	 *
	 *      var letters = ['a', 'b', 'A', 'a', 'B', 'c'];
	 *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
	 */
	
	
	var countBy = /*#__PURE__*/reduceBy(function (acc, elem) {
	  return acc + 1;
	}, 0);
	module.exports = countBy;

/***/ },
/* 138 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/reduceBy.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curryN = /*#__PURE__*/__webpack_require__(/*! ./internal/_curryN */ 36);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var _xreduceBy = /*#__PURE__*/__webpack_require__(/*! ./internal/_xreduceBy */ 139);
	
	/**
	 * Groups the elements of the list according to the result of calling
	 * the String-returning function `keyFn` on each element and reduces the elements
	 * of each group to a single value via the reducer function `valueFn`.
	 *
	 * This function is basically a more general [`groupBy`](#groupBy) function.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category List
	 * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
	 * @param {Function} valueFn The function that reduces the elements of each group to a single
	 *        value. Receives two values, accumulator for a particular group and the current element.
	 * @param {*} acc The (initial) accumulator value for each group.
	 * @param {Function} keyFn The function that maps the list's element into a key.
	 * @param {Array} list The array to group.
	 * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
	 *         `valueFn` for elements which produced that key when passed to `keyFn`.
	 * @see R.groupBy, R.reduce
	 * @example
	 *
	 *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
	 *      var namesByGrade = reduceToNamesBy(function(student) {
	 *        var score = student.score;
	 *        return score < 65 ? 'F' :
	 *               score < 70 ? 'D' :
	 *               score < 80 ? 'C' :
	 *               score < 90 ? 'B' : 'A';
	 *      });
	 *      var students = [{name: 'Lucy', score: 92},
	 *                      {name: 'Drew', score: 85},
	 *                      // ...
	 *                      {name: 'Bart', score: 62}];
	 *      namesByGrade(students);
	 *      // {
	 *      //   'A': ['Lucy'],
	 *      //   'B': ['Drew']
	 *      //   // ...,
	 *      //   'F': ['Bart']
	 *      // }
	 */
	
	
	var reduceBy = /*#__PURE__*/_curryN(4, [], /*#__PURE__*/_dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
	  return _reduce(function (acc, elt) {
	    var key = keyFn(elt);
	    acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
	    return acc;
	  }, {}, list);
	}));
	module.exports = reduceBy;

/***/ },
/* 139 */
/*!********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xreduceBy.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curryN = /*#__PURE__*/__webpack_require__(/*! ./_curryN */ 36);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./_has */ 58);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XReduceBy = /*#__PURE__*/function () {
	
	  function XReduceBy(valueFn, valueAcc, keyFn, xf) {
	    this.valueFn = valueFn;
	    this.valueAcc = valueAcc;
	    this.keyFn = keyFn;
	    this.xf = xf;
	    this.inputs = {};
	  }
	  XReduceBy.prototype['@@transducer/init'] = _xfBase.init;
	  XReduceBy.prototype['@@transducer/result'] = function (result) {
	    var key;
	    for (key in this.inputs) {
	      if (_has(key, this.inputs)) {
	        result = this.xf['@@transducer/step'](result, this.inputs[key]);
	        if (result['@@transducer/reduced']) {
	          result = result['@@transducer/value'];
	          break;
	        }
	      }
	    }
	    this.inputs = null;
	    return this.xf['@@transducer/result'](result);
	  };
	  XReduceBy.prototype['@@transducer/step'] = function (result, input) {
	    var key = this.keyFn(input);
	    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
	    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
	    return result;
	  };
	
	  return XReduceBy;
	}();
	
	var _xreduceBy = /*#__PURE__*/_curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
	  return new XReduceBy(valueFn, valueAcc, keyFn, xf);
	});
	module.exports = _xreduceBy;

/***/ },
/* 140 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/dec.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var add = /*#__PURE__*/__webpack_require__(/*! ./add */ 30);
	
	/**
	 * Decrements its argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Math
	 * @sig Number -> Number
	 * @param {Number} n
	 * @return {Number} n - 1
	 * @see R.inc
	 * @example
	 *
	 *      R.dec(42); //=> 41
	 */
	
	
	var dec = /*#__PURE__*/add(-1);
	module.exports = dec;

/***/ },
/* 141 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/defaultTo.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns the second argument if it is not `null`, `undefined` or `NaN`;
	 * otherwise the first argument is returned.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Logic
	 * @sig a -> b -> a | b
	 * @param {a} default The default value.
	 * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
	 * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
	 * @example
	 *
	 *      var defaultTo42 = R.defaultTo(42);
	 *
	 *      defaultTo42(null);  //=> 42
	 *      defaultTo42(undefined);  //=> 42
	 *      defaultTo42('Ramda');  //=> 'Ramda'
	 *      // parseInt('string') results in NaN
	 *      defaultTo42(parseInt('string')); //=> 42
	 */
	
	
	var defaultTo = /*#__PURE__*/_curry2(function defaultTo(d, v) {
	  return v == null || v !== v ? d : v;
	});
	module.exports = defaultTo;

/***/ },
/* 142 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/descend.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Makes a descending comparator function out of a function that returns a value
	 * that can be compared with `<` and `>`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.23.0
	 * @category Function
	 * @sig Ord b => (a -> b) -> a -> a -> Number
	 * @param {Function} fn A function of arity one that returns a value that can be compared
	 * @param {*} a The first item to be compared.
	 * @param {*} b The second item to be compared.
	 * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
	 * @see R.ascend
	 * @example
	 *
	 *      var byAge = R.descend(R.prop('age'));
	 *      var people = [
	 *        // ...
	 *      ];
	 *      var peopleByOldestFirst = R.sort(byAge, people);
	 */
	
	
	var descend = /*#__PURE__*/_curry3(function descend(fn, a, b) {
	  var aa = fn(a);
	  var bb = fn(b);
	  return aa > bb ? -1 : aa < bb ? 1 : 0;
	});
	module.exports = descend;

/***/ },
/* 143 */
/*!***********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/difference.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _contains = /*#__PURE__*/__webpack_require__(/*! ./internal/_contains */ 116);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Finds the set (i.e. no duplicates) of all elements in the first list not
	 * contained in the second list. Objects and Arrays are compared in terms of
	 * value equality, not reference equality.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig [*] -> [*] -> [*]
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The elements in `list1` that are not in `list2`.
	 * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
	 * @example
	 *
	 *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
	 *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
	 *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
	 */
	
	
	var difference = /*#__PURE__*/_curry2(function difference(first, second) {
	  var out = [];
	  var idx = 0;
	  var firstLen = first.length;
	  while (idx < firstLen) {
	    if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
	      out[out.length] = first[idx];
	    }
	    idx += 1;
	  }
	  return out;
	});
	module.exports = difference;

/***/ },
/* 144 */
/*!***************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/differenceWith.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _containsWith = /*#__PURE__*/__webpack_require__(/*! ./internal/_containsWith */ 121);
	
	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Finds the set (i.e. no duplicates) of all elements in the first list not
	 * contained in the second list. Duplication is determined according to the
	 * value returned by applying the supplied predicate to two list elements.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The elements in `list1` that are not in `list2`.
	 * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
	 * @example
	 *
	 *      var cmp = (x, y) => x.a === y.a;
	 *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
	 *      var l2 = [{a: 3}, {a: 4}];
	 *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
	 */
	
	
	var differenceWith = /*#__PURE__*/_curry3(function differenceWith(pred, first, second) {
	  var out = [];
	  var idx = 0;
	  var firstLen = first.length;
	  while (idx < firstLen) {
	    if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
	      out.push(first[idx]);
	    }
	    idx += 1;
	  }
	  return out;
	});
	module.exports = differenceWith;

/***/ },
/* 145 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/dissoc.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a new object that does not contain a `prop` property.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Object
	 * @sig String -> {k: v} -> {k: v}
	 * @param {String} prop The name of the property to dissociate
	 * @param {Object} obj The object to clone
	 * @return {Object} A new object equivalent to the original but without the specified property
	 * @see R.assoc
	 * @example
	 *
	 *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
	 */
	
	
	var dissoc = /*#__PURE__*/_curry2(function dissoc(prop, obj) {
	  var result = {};
	  for (var p in obj) {
	    result[p] = obj[p];
	  }
	  delete result[prop];
	  return result;
	});
	module.exports = dissoc;

/***/ },
/* 146 */
/*!***********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/dissocPath.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isInteger = /*#__PURE__*/__webpack_require__(/*! ./internal/_isInteger */ 79);
	
	var assoc = /*#__PURE__*/__webpack_require__(/*! ./assoc */ 77);
	
	var dissoc = /*#__PURE__*/__webpack_require__(/*! ./dissoc */ 145);
	
	var remove = /*#__PURE__*/__webpack_require__(/*! ./remove */ 147);
	
	var update = /*#__PURE__*/__webpack_require__(/*! ./update */ 148);
	
	/**
	 * Makes a shallow clone of an object, omitting the property at the given path.
	 * Note that this copies and flattens prototype properties onto the new object
	 * as well. All non-primitive properties are copied by reference.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.11.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @sig [Idx] -> {k: v} -> {k: v}
	 * @param {Array} path The path to the value to omit
	 * @param {Object} obj The object to clone
	 * @return {Object} A new object without the property at path
	 * @see R.assocPath
	 * @example
	 *
	 *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
	 */
	
	
	var dissocPath = /*#__PURE__*/_curry2(function dissocPath(path, obj) {
	  switch (path.length) {
	    case 0:
	      return obj;
	    case 1:
	      return _isInteger(path[0]) ? remove(path[0], 1, obj) : dissoc(path[0], obj);
	    default:
	      var head = path[0];
	      var tail = Array.prototype.slice.call(path, 1);
	      if (obj[head] == null) {
	        return obj;
	      } else if (_isInteger(path[0])) {
	        return update(head, dissocPath(tail, obj[head]), obj);
	      } else {
	        return assoc(head, dissocPath(tail, obj[head]), obj);
	      }
	  }
	});
	module.exports = dissocPath;

/***/ },
/* 147 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/remove.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Removes the sub-list of `list` starting at index `start` and containing
	 * `count` elements. _Note that this is not destructive_: it returns a copy of
	 * the list with the changes.
	 * <small>No lists have been harmed in the application of this function.</small>
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.2
	 * @category List
	 * @sig Number -> Number -> [a] -> [a]
	 * @param {Number} start The position to start removing elements
	 * @param {Number} count The number of elements to remove
	 * @param {Array} list The list to remove from
	 * @return {Array} A new Array with `count` elements from `start` removed.
	 * @example
	 *
	 *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
	 */
	
	
	var remove = /*#__PURE__*/_curry3(function remove(start, count, list) {
	  var result = Array.prototype.slice.call(list, 0);
	  result.splice(start, count);
	  return result;
	});
	module.exports = remove;

/***/ },
/* 148 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/update.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var adjust = /*#__PURE__*/__webpack_require__(/*! ./adjust */ 37);
	
	var always = /*#__PURE__*/__webpack_require__(/*! ./always */ 25);
	
	/**
	 * Returns a new copy of the array with the element at the provided index
	 * replaced with the given value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig Number -> a -> [a] -> [a]
	 * @param {Number} idx The index to update.
	 * @param {*} x The value to exist at the given index of the returned array.
	 * @param {Array|Arguments} list The source array-like object to be updated.
	 * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
	 * @see R.adjust
	 * @example
	 *
	 *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
	 *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
	 * @symb R.update(-1, a, [b, c]) = [b, a]
	 * @symb R.update(0, a, [b, c]) = [a, c]
	 * @symb R.update(1, a, [b, c]) = [b, a]
	 */
	
	
	var update = /*#__PURE__*/_curry3(function update(idx, x, list) {
	  return adjust(always(x), idx, list);
	});
	module.exports = update;

/***/ },
/* 149 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/divide.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Divides two numbers. Equivalent to `a / b`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a The first value.
	 * @param {Number} b The second value.
	 * @return {Number} The result of `a / b`.
	 * @see R.multiply
	 * @example
	 *
	 *      R.divide(71, 100); //=> 0.71
	 *
	 *      var half = R.divide(R.__, 2);
	 *      half(42); //=> 21
	 *
	 *      var reciprocal = R.divide(1);
	 *      reciprocal(4);   //=> 0.25
	 */
	
	
	var divide = /*#__PURE__*/_curry2(function divide(a, b) {
	  return a / b;
	});
	module.exports = divide;

/***/ },
/* 150 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/drop.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xdrop = /*#__PURE__*/__webpack_require__(/*! ./internal/_xdrop */ 151);
	
	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Returns all but the first `n` elements of the given list, string, or
	 * transducer/transformer (or object with a `drop` method).
	 *
	 * Dispatches to the `drop` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Number -> [a] -> [a]
	 * @sig Number -> String -> String
	 * @param {Number} n
	 * @param {*} list
	 * @return {*} A copy of list without the first `n` elements
	 * @see R.take, R.transduce, R.dropLast, R.dropWhile
	 * @example
	 *
	 *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	 *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
	 *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
	 *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
	 *      R.drop(3, 'ramda');               //=> 'da'
	 */
	
	
	var drop = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['drop'], _xdrop, function drop(n, xs) {
	  return slice(Math.max(0, n), Infinity, xs);
	}));
	module.exports = drop;

/***/ },
/* 151 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xdrop.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XDrop = /*#__PURE__*/function () {
	
	  function XDrop(n, xf) {
	    this.xf = xf;
	    this.n = n;
	  }
	  XDrop.prototype['@@transducer/init'] = _xfBase.init;
	  XDrop.prototype['@@transducer/result'] = _xfBase.result;
	  XDrop.prototype['@@transducer/step'] = function (result, input) {
	    if (this.n > 0) {
	      this.n -= 1;
	      return result;
	    }
	    return this.xf['@@transducer/step'](result, input);
	  };
	
	  return XDrop;
	}();
	
	var _xdrop = /*#__PURE__*/_curry2(function _xdrop(n, xf) {
	  return new XDrop(n, xf);
	});
	module.exports = _xdrop;

/***/ },
/* 152 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/dropLast.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _dropLast = /*#__PURE__*/__webpack_require__(/*! ./internal/_dropLast */ 153);
	
	var _xdropLast = /*#__PURE__*/__webpack_require__(/*! ./internal/_xdropLast */ 156);
	
	/**
	 * Returns a list containing all but the last `n` elements of the given `list`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig Number -> [a] -> [a]
	 * @sig Number -> String -> String
	 * @param {Number} n The number of elements of `list` to skip.
	 * @param {Array} list The list of elements to consider.
	 * @return {Array} A copy of the list with only the first `list.length - n` elements
	 * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
	 * @example
	 *
	 *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	 *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
	 *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
	 *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
	 *      R.dropLast(3, 'ramda');               //=> 'ra'
	 */
	
	
	var dropLast = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xdropLast, _dropLast));
	module.exports = dropLast;

/***/ },
/* 153 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_dropLast.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var take = /*#__PURE__*/__webpack_require__(/*! ../take */ 154);
	
	function dropLast(n, xs) {
	  return take(n < xs.length ? xs.length - n : 0, xs);
	}
	module.exports = dropLast;

/***/ },
/* 154 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/take.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xtake = /*#__PURE__*/__webpack_require__(/*! ./internal/_xtake */ 155);
	
	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Returns the first `n` elements of the given list, string, or
	 * transducer/transformer (or object with a `take` method).
	 *
	 * Dispatches to the `take` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Number -> [a] -> [a]
	 * @sig Number -> String -> String
	 * @param {Number} n
	 * @param {*} list
	 * @return {*}
	 * @see R.drop
	 * @example
	 *
	 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
	 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
	 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	 *      R.take(3, 'ramda');               //=> 'ram'
	 *
	 *      var personnel = [
	 *        'Dave Brubeck',
	 *        'Paul Desmond',
	 *        'Eugene Wright',
	 *        'Joe Morello',
	 *        'Gerry Mulligan',
	 *        'Bob Bates',
	 *        'Joe Dodge',
	 *        'Ron Crotty'
	 *      ];
	 *
	 *      var takeFive = R.take(5);
	 *      takeFive(personnel);
	 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
	 * @symb R.take(-1, [a, b]) = [a, b]
	 * @symb R.take(0, [a, b]) = []
	 * @symb R.take(1, [a, b]) = [a]
	 * @symb R.take(2, [a, b]) = [a, b]
	 */
	
	
	var take = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['take'], _xtake, function take(n, xs) {
	  return slice(0, n < 0 ? Infinity : n, xs);
	}));
	module.exports = take;

/***/ },
/* 155 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xtake.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _reduced = /*#__PURE__*/__webpack_require__(/*! ./_reduced */ 44);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XTake = /*#__PURE__*/function () {
	
	  function XTake(n, xf) {
	    this.xf = xf;
	    this.n = n;
	    this.i = 0;
	  }
	  XTake.prototype['@@transducer/init'] = _xfBase.init;
	  XTake.prototype['@@transducer/result'] = _xfBase.result;
	  XTake.prototype['@@transducer/step'] = function (result, input) {
	    this.i += 1;
	    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
	    return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
	  };
	
	  return XTake;
	}();
	
	var _xtake = /*#__PURE__*/_curry2(function _xtake(n, xf) {
	  return new XTake(n, xf);
	});
	module.exports = _xtake;

/***/ },
/* 156 */
/*!********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xdropLast.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XDropLast = /*#__PURE__*/function () {
	
	  function XDropLast(n, xf) {
	    this.xf = xf;
	    this.pos = 0;
	    this.full = false;
	    this.acc = new Array(n);
	  }
	  XDropLast.prototype['@@transducer/init'] = _xfBase.init;
	  XDropLast.prototype['@@transducer/result'] = function (result) {
	    this.acc = null;
	    return this.xf['@@transducer/result'](result);
	  };
	  XDropLast.prototype['@@transducer/step'] = function (result, input) {
	    if (this.full) {
	      result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
	    }
	    this.store(input);
	    return result;
	  };
	  XDropLast.prototype.store = function (input) {
	    this.acc[this.pos] = input;
	    this.pos += 1;
	    if (this.pos === this.acc.length) {
	      this.pos = 0;
	      this.full = true;
	    }
	  };
	
	  return XDropLast;
	}();
	
	var _xdropLast = /*#__PURE__*/_curry2(function _xdropLast(n, xf) {
	  return new XDropLast(n, xf);
	});
	module.exports = _xdropLast;

/***/ },
/* 157 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/dropLastWhile.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _dropLastWhile = /*#__PURE__*/__webpack_require__(/*! ./internal/_dropLastWhile */ 158);
	
	var _xdropLastWhile = /*#__PURE__*/__webpack_require__(/*! ./internal/_xdropLastWhile */ 159);
	
	/**
	 * Returns a new list excluding all the tailing elements of a given list which
	 * satisfy the supplied predicate function. It passes each value from the right
	 * to the supplied predicate function, skipping elements until the predicate
	 * function returns a `falsy` value. The predicate function is applied to one argument:
	 * *(value)*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [a]
	 * @sig (a -> Boolean) -> String -> String
	 * @param {Function} predicate The function to be called on each element
	 * @param {Array} xs The collection to iterate over.
	 * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
	 * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
	 * @example
	 *
	 *      var lteThree = x => x <= 3;
	 *
	 *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
	 *
	 *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
	 */
	
	
	var dropLastWhile = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xdropLastWhile, _dropLastWhile));
	module.exports = dropLastWhile;

/***/ },
/* 158 */
/*!************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_dropLastWhile.js ***!
  \************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var slice = /*#__PURE__*/__webpack_require__(/*! ../slice */ 107);
	
	function dropLastWhile(pred, xs) {
	  var idx = xs.length - 1;
	  while (idx >= 0 && pred(xs[idx])) {
	    idx -= 1;
	  }
	  return slice(0, idx + 1, xs);
	}
	module.exports = dropLastWhile;

/***/ },
/* 159 */
/*!*************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xdropLastWhile.js ***!
  \*************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./_reduce */ 51);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XDropLastWhile = /*#__PURE__*/function () {
	
	  function XDropLastWhile(fn, xf) {
	    this.f = fn;
	    this.retained = [];
	    this.xf = xf;
	  }
	  XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
	  XDropLastWhile.prototype['@@transducer/result'] = function (result) {
	    this.retained = null;
	    return this.xf['@@transducer/result'](result);
	  };
	  XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
	    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
	  };
	  XDropLastWhile.prototype.flush = function (result, input) {
	    result = _reduce(this.xf['@@transducer/step'], result, this.retained);
	    this.retained = [];
	    return this.xf['@@transducer/step'](result, input);
	  };
	  XDropLastWhile.prototype.retain = function (result, input) {
	    this.retained.push(input);
	    return result;
	  };
	
	  return XDropLastWhile;
	}();
	
	var _xdropLastWhile = /*#__PURE__*/_curry2(function _xdropLastWhile(fn, xf) {
	  return new XDropLastWhile(fn, xf);
	});
	module.exports = _xdropLastWhile;

/***/ },
/* 160 */
/*!************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/dropRepeats.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xdropRepeatsWith = /*#__PURE__*/__webpack_require__(/*! ./internal/_xdropRepeatsWith */ 161);
	
	var dropRepeatsWith = /*#__PURE__*/__webpack_require__(/*! ./dropRepeatsWith */ 162);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	/**
	 * Returns a new list without any consecutively repeating elements.
	 * [`R.equals`](#equals) is used to determine equality.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig [a] -> [a]
	 * @param {Array} list The array to consider.
	 * @return {Array} `list` without repeating elements.
	 * @see R.transduce
	 * @example
	 *
	 *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
	 */
	
	
	var dropRepeats = /*#__PURE__*/_curry1( /*#__PURE__*/_dispatchable([], /*#__PURE__*/_xdropRepeatsWith(equals), /*#__PURE__*/dropRepeatsWith(equals)));
	module.exports = dropRepeats;

/***/ },
/* 161 */
/*!***************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xdropRepeatsWith.js ***!
  \***************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XDropRepeatsWith = /*#__PURE__*/function () {
	
	  function XDropRepeatsWith(pred, xf) {
	    this.xf = xf;
	    this.pred = pred;
	    this.lastValue = undefined;
	    this.seenFirstValue = false;
	  }
	
	  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
	  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;
	  XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
	    var sameAsLast = false;
	    if (!this.seenFirstValue) {
	      this.seenFirstValue = true;
	    } else if (this.pred(this.lastValue, input)) {
	      sameAsLast = true;
	    }
	    this.lastValue = input;
	    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
	  };
	
	  return XDropRepeatsWith;
	}();
	
	var _xdropRepeatsWith = /*#__PURE__*/_curry2(function _xdropRepeatsWith(pred, xf) {
	  return new XDropRepeatsWith(pred, xf);
	});
	module.exports = _xdropRepeatsWith;

/***/ },
/* 162 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/dropRepeatsWith.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xdropRepeatsWith = /*#__PURE__*/__webpack_require__(/*! ./internal/_xdropRepeatsWith */ 161);
	
	var last = /*#__PURE__*/__webpack_require__(/*! ./last */ 163);
	
	/**
	 * Returns a new list without any consecutively repeating elements. Equality is
	 * determined by applying the supplied predicate to each pair of consecutive elements. The
	 * first element in a series of equal elements will be preserved.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig ((a, a) -> Boolean) -> [a] -> [a]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list The array to consider.
	 * @return {Array} `list` without repeating elements.
	 * @see R.transduce
	 * @example
	 *
	 *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
	 *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
	 */
	
	
	var dropRepeatsWith = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
	  var result = [];
	  var idx = 1;
	  var len = list.length;
	  if (len !== 0) {
	    result[0] = list[0];
	    while (idx < len) {
	      if (!pred(last(result), list[idx])) {
	        result[result.length] = list[idx];
	      }
	      idx += 1;
	    }
	  }
	  return result;
	}));
	module.exports = dropRepeatsWith;

/***/ },
/* 163 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/last.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var nth = /*#__PURE__*/__webpack_require__(/*! ./nth */ 164);
	
	/**
	 * Returns the last element of the given list or string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.4
	 * @category List
	 * @sig [a] -> a | Undefined
	 * @sig String -> String
	 * @param {*} list
	 * @return {*}
	 * @see R.init, R.head, R.tail
	 * @example
	 *
	 *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
	 *      R.last([]); //=> undefined
	 *
	 *      R.last('abc'); //=> 'c'
	 *      R.last(''); //=> ''
	 */
	
	
	var last = /*#__PURE__*/nth(-1);
	module.exports = last;

/***/ },
/* 164 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/nth.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isString = /*#__PURE__*/__webpack_require__(/*! ./internal/_isString */ 53);
	
	/**
	 * Returns the nth element of the given list or string. If n is negative the
	 * element at index length + n is returned.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Number -> [a] -> a | Undefined
	 * @sig Number -> String -> String
	 * @param {Number} offset
	 * @param {*} list
	 * @return {*}
	 * @example
	 *
	 *      var list = ['foo', 'bar', 'baz', 'quux'];
	 *      R.nth(1, list); //=> 'bar'
	 *      R.nth(-1, list); //=> 'quux'
	 *      R.nth(-99, list); //=> undefined
	 *
	 *      R.nth(2, 'abc'); //=> 'c'
	 *      R.nth(3, 'abc'); //=> ''
	 * @symb R.nth(-1, [a, b, c]) = c
	 * @symb R.nth(0, [a, b, c]) = a
	 * @symb R.nth(1, [a, b, c]) = b
	 */
	
	
	var nth = /*#__PURE__*/_curry2(function nth(offset, list) {
	  var idx = offset < 0 ? list.length + offset : offset;
	  return _isString(list) ? list.charAt(idx) : list[idx];
	});
	module.exports = nth;

/***/ },
/* 165 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/dropWhile.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xdropWhile = /*#__PURE__*/__webpack_require__(/*! ./internal/_xdropWhile */ 166);
	
	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Returns a new list excluding the leading elements of a given list which
	 * satisfy the supplied predicate function. It passes each value to the supplied
	 * predicate function, skipping elements while the predicate function returns
	 * `true`. The predicate function is applied to one argument: *(value)*.
	 *
	 * Dispatches to the `dropWhile` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [a]
	 * @sig (a -> Boolean) -> String -> String
	 * @param {Function} fn The function called per iteration.
	 * @param {Array} xs The collection to iterate over.
	 * @return {Array} A new array.
	 * @see R.takeWhile, R.transduce, R.addIndex
	 * @example
	 *
	 *      var lteTwo = x => x <= 2;
	 *
	 *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
	 *
	 *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
	 */
	
	
	var dropWhile = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, xs) {
	  var idx = 0;
	  var len = xs.length;
	  while (idx < len && pred(xs[idx])) {
	    idx += 1;
	  }
	  return slice(idx, Infinity, xs);
	}));
	module.exports = dropWhile;

/***/ },
/* 166 */
/*!*********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xdropWhile.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XDropWhile = /*#__PURE__*/function () {
	
	  function XDropWhile(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }
	  XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
	  XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
	  XDropWhile.prototype['@@transducer/step'] = function (result, input) {
	    if (this.f) {
	      if (this.f(input)) {
	        return result;
	      }
	      this.f = null;
	    }
	    return this.xf['@@transducer/step'](result, input);
	  };
	
	  return XDropWhile;
	}();
	
	var _xdropWhile = /*#__PURE__*/_curry2(function _xdropWhile(f, xf) {
	  return new XDropWhile(f, xf);
	});
	module.exports = _xdropWhile;

/***/ },
/* 167 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/either.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isFunction = /*#__PURE__*/__webpack_require__(/*! ./internal/_isFunction */ 84);
	
	var lift = /*#__PURE__*/__webpack_require__(/*! ./lift */ 85);
	
	var or = /*#__PURE__*/__webpack_require__(/*! ./or */ 168);
	
	/**
	 * A function wrapping calls to the two functions in an `||` operation,
	 * returning the result of the first function if it is truth-y and the result
	 * of the second function otherwise. Note that this is short-circuited,
	 * meaning that the second function will not be invoked if the first returns a
	 * truth-y value.
	 *
	 * In addition to functions, `R.either` also accepts any fantasy-land compatible
	 * applicative functor.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category Logic
	 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
	 * @param {Function} f a predicate
	 * @param {Function} g another predicate
	 * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
	 * @see R.or
	 * @example
	 *
	 *      var gt10 = x => x > 10;
	 *      var even = x => x % 2 === 0;
	 *      var f = R.either(gt10, even);
	 *      f(101); //=> true
	 *      f(8); //=> true
	 */
	
	
	var either = /*#__PURE__*/_curry2(function either(f, g) {
	  return _isFunction(f) ? function _either() {
	    return f.apply(this, arguments) || g.apply(this, arguments);
	  } : lift(or)(f, g);
	});
	module.exports = either;

/***/ },
/* 168 */
/*!***************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/or.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns `true` if one or both of its arguments are `true`. Returns `false`
	 * if both arguments are `false`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Logic
	 * @sig a -> b -> a | b
	 * @param {Any} a
	 * @param {Any} b
	 * @return {Any} the first argument if truthy, otherwise the second argument.
	 * @see R.either
	 * @example
	 *
	 *      R.or(true, true); //=> true
	 *      R.or(true, false); //=> true
	 *      R.or(false, true); //=> true
	 *      R.or(false, false); //=> false
	 */
	
	
	var or = /*#__PURE__*/_curry2(function or(a, b) {
	  return a || b;
	});
	module.exports = or;

/***/ },
/* 169 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/empty.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _isArguments = /*#__PURE__*/__webpack_require__(/*! ./internal/_isArguments */ 59);
	
	var _isArray = /*#__PURE__*/__webpack_require__(/*! ./internal/_isArray */ 41);
	
	var _isObject = /*#__PURE__*/__webpack_require__(/*! ./internal/_isObject */ 130);
	
	var _isString = /*#__PURE__*/__webpack_require__(/*! ./internal/_isString */ 53);
	
	/**
	 * Returns the empty value of its argument's type. Ramda defines the empty
	 * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
	 * types are supported if they define `<Type>.empty`,
	 * `<Type>.prototype.empty` or implement the
	 * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
	 *
	 * Dispatches to the `empty` method of the first argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Function
	 * @sig a -> a
	 * @param {*} x
	 * @return {*}
	 * @example
	 *
	 *      R.empty(Just(42));      //=> Nothing()
	 *      R.empty([1, 2, 3]);     //=> []
	 *      R.empty('unicorns');    //=> ''
	 *      R.empty({x: 1, y: 2});  //=> {}
	 */
	
	
	var empty = /*#__PURE__*/_curry1(function empty(x) {
	  return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
	    return arguments;
	  }() :
	  // else
	  void 0;
	});
	module.exports = empty;

/***/ },
/* 170 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/endsWith.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	var takeLast = /*#__PURE__*/__webpack_require__(/*! ./takeLast */ 171);
	
	/**
	 * Checks if a list ends with the provided values
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category List
	 * @sig [a] -> Boolean
	 * @sig String -> Boolean
	 * @param {*} suffix
	 * @param {*} list
	 * @return {Boolean}
	 * @example
	 *
	 *      R.endsWith('c', 'abc')                //=> true
	 *      R.endsWith('b', 'abc')                //=> false
	 *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
	 *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
	 */
	
	
	var endsWith = /*#__PURE__*/_curry2(function (suffix, list) {
	  return equals(takeLast(suffix.length, list), suffix);
	});
	module.exports = endsWith;

/***/ },
/* 171 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/takeLast.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var drop = /*#__PURE__*/__webpack_require__(/*! ./drop */ 150);
	
	/**
	 * Returns a new list containing the last `n` elements of the given list.
	 * If `n > list.length`, returns a list of `list.length` elements.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig Number -> [a] -> [a]
	 * @sig Number -> String -> String
	 * @param {Number} n The number of elements to return.
	 * @param {Array} xs The collection to consider.
	 * @return {Array}
	 * @see R.dropLast
	 * @example
	 *
	 *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
	 *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
	 *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	 *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
	 *      R.takeLast(3, 'ramda');               //=> 'mda'
	 */
	
	
	var takeLast = /*#__PURE__*/_curry2(function takeLast(n, xs) {
	  return drop(n >= 0 ? xs.length - n : 0, xs);
	});
	module.exports = takeLast;

/***/ },
/* 172 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/eqBy.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	/**
	 * Takes a function and two values in its domain and returns `true` if the
	 * values map to the same value in the codomain; `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Relation
	 * @sig (a -> b) -> a -> a -> Boolean
	 * @param {Function} f
	 * @param {*} x
	 * @param {*} y
	 * @return {Boolean}
	 * @example
	 *
	 *      R.eqBy(Math.abs, 5, -5); //=> true
	 */
	
	
	var eqBy = /*#__PURE__*/_curry3(function eqBy(f, x, y) {
	  return equals(f(x), f(y));
	});
	module.exports = eqBy;

/***/ },
/* 173 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/eqProps.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	/**
	 * Reports whether two objects have the same value, in [`R.equals`](#equals)
	 * terms, for the specified property. Useful as a curried predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig k -> {k: v} -> {k: v} -> Boolean
	 * @param {String} prop The name of the property to compare
	 * @param {Object} obj1
	 * @param {Object} obj2
	 * @return {Boolean}
	 *
	 * @example
	 *
	 *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
	 *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
	 *      R.eqProps('a', o1, o2); //=> false
	 *      R.eqProps('c', o1, o2); //=> true
	 */
	
	
	var eqProps = /*#__PURE__*/_curry3(function eqProps(prop, obj1, obj2) {
	  return equals(obj1[prop], obj2[prop]);
	});
	module.exports = eqProps;

/***/ },
/* 174 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/evolve.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Creates a new object by recursively evolving a shallow copy of `object`,
	 * according to the `transformation` functions. All non-primitive properties
	 * are copied by reference.
	 *
	 * A `transformation` function will not be invoked if its corresponding key
	 * does not exist in the evolved object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Object
	 * @sig {k: (v -> v)} -> {k: v} -> {k: v}
	 * @param {Object} transformations The object specifying transformation functions to apply
	 *        to the object.
	 * @param {Object} object The object to be transformed.
	 * @return {Object} The transformed object.
	 * @example
	 *
	 *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
	 *      var transformations = {
	 *        firstName: R.trim,
	 *        lastName: R.trim, // Will not get invoked.
	 *        data: {elapsed: R.add(1), remaining: R.add(-1)}
	 *      };
	 *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
	 */
	
	
	var evolve = /*#__PURE__*/_curry2(function evolve(transformations, object) {
	  var result = {};
	  var transformation, key, type;
	  for (key in object) {
	    transformation = transformations[key];
	    type = typeof transformation;
	    result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
	  }
	  return result;
	});
	module.exports = evolve;

/***/ },
/* 175 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/find.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xfind = /*#__PURE__*/__webpack_require__(/*! ./internal/_xfind */ 176);
	
	/**
	 * Returns the first element of the list which matches the predicate, or
	 * `undefined` if no element matches.
	 *
	 * Dispatches to the `find` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> a | undefined
	 * @param {Function} fn The predicate function used to determine if the element is the
	 *        desired one.
	 * @param {Array} list The array to consider.
	 * @return {Object} The element found, or `undefined`.
	 * @see R.transduce
	 * @example
	 *
	 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
	 *      R.find(R.propEq('a', 4))(xs); //=> undefined
	 */
	
	
	var find = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['find'], _xfind, function find(fn, list) {
	  var idx = 0;
	  var len = list.length;
	  while (idx < len) {
	    if (fn(list[idx])) {
	      return list[idx];
	    }
	    idx += 1;
	  }
	}));
	module.exports = find;

/***/ },
/* 176 */
/*!****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xfind.js ***!
  \****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _reduced = /*#__PURE__*/__webpack_require__(/*! ./_reduced */ 44);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XFind = /*#__PURE__*/function () {
	
	  function XFind(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.found = false;
	  }
	  XFind.prototype['@@transducer/init'] = _xfBase.init;
	  XFind.prototype['@@transducer/result'] = function (result) {
	    if (!this.found) {
	      result = this.xf['@@transducer/step'](result, void 0);
	    }
	    return this.xf['@@transducer/result'](result);
	  };
	  XFind.prototype['@@transducer/step'] = function (result, input) {
	    if (this.f(input)) {
	      this.found = true;
	      result = _reduced(this.xf['@@transducer/step'](result, input));
	    }
	    return result;
	  };
	
	  return XFind;
	}();
	
	var _xfind = /*#__PURE__*/_curry2(function _xfind(f, xf) {
	  return new XFind(f, xf);
	});
	module.exports = _xfind;

/***/ },
/* 177 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/findIndex.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xfindIndex = /*#__PURE__*/__webpack_require__(/*! ./internal/_xfindIndex */ 178);
	
	/**
	 * Returns the index of the first element of the list which matches the
	 * predicate, or `-1` if no element matches.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Number
	 * @param {Function} fn The predicate function used to determine if the element is the
	 * desired one.
	 * @param {Array} list The array to consider.
	 * @return {Number} The index of the element found, or `-1`.
	 * @see R.transduce
	 * @example
	 *
	 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
	 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
	 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
	 */
	
	
	var findIndex = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xfindIndex, function findIndex(fn, list) {
	  var idx = 0;
	  var len = list.length;
	  while (idx < len) {
	    if (fn(list[idx])) {
	      return idx;
	    }
	    idx += 1;
	  }
	  return -1;
	}));
	module.exports = findIndex;

/***/ },
/* 178 */
/*!*********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xfindIndex.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _reduced = /*#__PURE__*/__webpack_require__(/*! ./_reduced */ 44);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XFindIndex = /*#__PURE__*/function () {
	
	  function XFindIndex(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.idx = -1;
	    this.found = false;
	  }
	  XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
	  XFindIndex.prototype['@@transducer/result'] = function (result) {
	    if (!this.found) {
	      result = this.xf['@@transducer/step'](result, -1);
	    }
	    return this.xf['@@transducer/result'](result);
	  };
	  XFindIndex.prototype['@@transducer/step'] = function (result, input) {
	    this.idx += 1;
	    if (this.f(input)) {
	      this.found = true;
	      result = _reduced(this.xf['@@transducer/step'](result, this.idx));
	    }
	    return result;
	  };
	
	  return XFindIndex;
	}();
	
	var _xfindIndex = /*#__PURE__*/_curry2(function _xfindIndex(f, xf) {
	  return new XFindIndex(f, xf);
	});
	module.exports = _xfindIndex;

/***/ },
/* 179 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/findLast.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xfindLast = /*#__PURE__*/__webpack_require__(/*! ./internal/_xfindLast */ 180);
	
	/**
	 * Returns the last element of the list which matches the predicate, or
	 * `undefined` if no element matches.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> a | undefined
	 * @param {Function} fn The predicate function used to determine if the element is the
	 * desired one.
	 * @param {Array} list The array to consider.
	 * @return {Object} The element found, or `undefined`.
	 * @see R.transduce
	 * @example
	 *
	 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	 *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
	 *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
	 */
	
	
	var findLast = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xfindLast, function findLast(fn, list) {
	  var idx = list.length - 1;
	  while (idx >= 0) {
	    if (fn(list[idx])) {
	      return list[idx];
	    }
	    idx -= 1;
	  }
	}));
	module.exports = findLast;

/***/ },
/* 180 */
/*!********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xfindLast.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XFindLast = /*#__PURE__*/function () {
	
	  function XFindLast(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }
	  XFindLast.prototype['@@transducer/init'] = _xfBase.init;
	  XFindLast.prototype['@@transducer/result'] = function (result) {
	    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
	  };
	  XFindLast.prototype['@@transducer/step'] = function (result, input) {
	    if (this.f(input)) {
	      this.last = input;
	    }
	    return result;
	  };
	
	  return XFindLast;
	}();
	
	var _xfindLast = /*#__PURE__*/_curry2(function _xfindLast(f, xf) {
	  return new XFindLast(f, xf);
	});
	module.exports = _xfindLast;

/***/ },
/* 181 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/findLastIndex.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xfindLastIndex = /*#__PURE__*/__webpack_require__(/*! ./internal/_xfindLastIndex */ 182);
	
	/**
	 * Returns the index of the last element of the list which matches the
	 * predicate, or `-1` if no element matches.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Number
	 * @param {Function} fn The predicate function used to determine if the element is the
	 * desired one.
	 * @param {Array} list The array to consider.
	 * @return {Number} The index of the element found, or `-1`.
	 * @see R.transduce
	 * @example
	 *
	 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
	 *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
	 *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
	 */
	
	
	var findLastIndex = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xfindLastIndex, function findLastIndex(fn, list) {
	  var idx = list.length - 1;
	  while (idx >= 0) {
	    if (fn(list[idx])) {
	      return idx;
	    }
	    idx -= 1;
	  }
	  return -1;
	}));
	module.exports = findLastIndex;

/***/ },
/* 182 */
/*!*************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xfindLastIndex.js ***!
  \*************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XFindLastIndex = /*#__PURE__*/function () {
	
	  function XFindLastIndex(f, xf) {
	    this.xf = xf;
	    this.f = f;
	    this.idx = -1;
	    this.lastIdx = -1;
	  }
	  XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
	  XFindLastIndex.prototype['@@transducer/result'] = function (result) {
	    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
	  };
	  XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
	    this.idx += 1;
	    if (this.f(input)) {
	      this.lastIdx = this.idx;
	    }
	    return result;
	  };
	
	  return XFindLastIndex;
	}();
	
	var _xfindLastIndex = /*#__PURE__*/_curry2(function _xfindLastIndex(f, xf) {
	  return new XFindLastIndex(f, xf);
	});
	module.exports = _xfindLastIndex;

/***/ },
/* 183 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/flatten.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _makeFlat = /*#__PURE__*/__webpack_require__(/*! ./internal/_makeFlat */ 90);
	
	/**
	 * Returns a new list by pulling every item out of it (and all its sub-arrays)
	 * and putting them in a new array, depth-first.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [b]
	 * @param {Array} list The array to consider.
	 * @return {Array} The flattened list.
	 * @see R.unnest
	 * @example
	 *
	 *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
	 *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
	 */
	
	
	var flatten = /*#__PURE__*/_curry1( /*#__PURE__*/_makeFlat(true));
	module.exports = flatten;

/***/ },
/* 184 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/flip.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	/**
	 * Returns a new function much like the supplied one, except that the first two
	 * arguments' order is reversed.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
	 * @param {Function} fn The function to invoke with its first two parameters reversed.
	 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
	 * @example
	 *
	 *      var mergeThree = (a, b, c) => [].concat(a, b, c);
	 *
	 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
	 *
	 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
	 * @symb R.flip(f)(a, b, c) = f(b, a, c)
	 */
	
	
	var flip = /*#__PURE__*/_curry1(function flip(fn) {
	  return curryN(fn.length, function (a, b) {
	    var args = Array.prototype.slice.call(arguments, 0);
	    args[0] = b;
	    args[1] = a;
	    return fn.apply(this, args);
	  });
	});
	module.exports = flip;

/***/ },
/* 185 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/forEach.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _checkForMethod = /*#__PURE__*/__webpack_require__(/*! ./internal/_checkForMethod */ 106);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Iterate over an input `list`, calling a provided function `fn` for each
	 * element in the list.
	 *
	 * `fn` receives one argument: *(value)*.
	 *
	 * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
	 * arrays), unlike the native `Array.prototype.forEach` method. For more
	 * details on this behavior, see:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
	 *
	 * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
	 * the original array. In some libraries this function is named `each`.
	 *
	 * Dispatches to the `forEach` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig (a -> *) -> [a] -> [a]
	 * @param {Function} fn The function to invoke. Receives one argument, `value`.
	 * @param {Array} list The list to iterate over.
	 * @return {Array} The original list.
	 * @see R.addIndex
	 * @example
	 *
	 *      var printXPlusFive = x => console.log(x + 5);
	 *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
	 *      // logs 6
	 *      // logs 7
	 *      // logs 8
	 * @symb R.forEach(f, [a, b, c]) = [a, b, c]
	 */
	
	
	var forEach = /*#__PURE__*/_curry2( /*#__PURE__*/_checkForMethod('forEach', function forEach(fn, list) {
	  var len = list.length;
	  var idx = 0;
	  while (idx < len) {
	    fn(list[idx]);
	    idx += 1;
	  }
	  return list;
	}));
	module.exports = forEach;

/***/ },
/* 186 */
/*!******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/forEachObjIndexed.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ 57);
	
	/**
	 * Iterate over an input `object`, calling a provided function `fn` for each
	 * key and value in the object.
	 *
	 * `fn` receives three argument: *(value, key, obj)*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.23.0
	 * @category Object
	 * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
	 * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
	 * @param {Object} obj The object to iterate over.
	 * @return {Object} The original object.
	 * @example
	 *
	 *      var printKeyConcatValue = (value, key) => console.log(key + ':' + value);
	 *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
	 *      // logs x:1
	 *      // logs y:2
	 * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
	 */
	
	
	var forEachObjIndexed = /*#__PURE__*/_curry2(function forEachObjIndexed(fn, obj) {
	  var keyList = keys(obj);
	  var idx = 0;
	  while (idx < keyList.length) {
	    var key = keyList[idx];
	    fn(obj[key], key, obj);
	    idx += 1;
	  }
	  return obj;
	});
	module.exports = forEachObjIndexed;

/***/ },
/* 187 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/fromPairs.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Creates a new object from a list key-value pairs. If a key appears in
	 * multiple pairs, the rightmost pair is included in the object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig [[k,v]] -> {k: v}
	 * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
	 * @return {Object} The object made by pairing up `keys` and `values`.
	 * @see R.toPairs, R.pair
	 * @example
	 *
	 *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
	 */
	
	
	var fromPairs = /*#__PURE__*/_curry1(function fromPairs(pairs) {
	  var result = {};
	  var idx = 0;
	  while (idx < pairs.length) {
	    result[pairs[idx][0]] = pairs[idx][1];
	    idx += 1;
	  }
	  return result;
	});
	module.exports = fromPairs;

/***/ },
/* 188 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/groupBy.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _checkForMethod = /*#__PURE__*/__webpack_require__(/*! ./internal/_checkForMethod */ 106);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var reduceBy = /*#__PURE__*/__webpack_require__(/*! ./reduceBy */ 138);
	
	/**
	 * Splits a list into sub-lists stored in an object, based on the result of
	 * calling a String-returning function on each element, and grouping the
	 * results according to values returned.
	 *
	 * Dispatches to the `groupBy` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> String) -> [a] -> {String: [a]}
	 * @param {Function} fn Function :: a -> String
	 * @param {Array} list The array to group
	 * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
	 *         that produced that key when passed to `fn`.
	 * @see R.transduce
	 * @example
	 *
	 *      var byGrade = R.groupBy(function(student) {
	 *        var score = student.score;
	 *        return score < 65 ? 'F' :
	 *               score < 70 ? 'D' :
	 *               score < 80 ? 'C' :
	 *               score < 90 ? 'B' : 'A';
	 *      });
	 *      var students = [{name: 'Abby', score: 84},
	 *                      {name: 'Eddy', score: 58},
	 *                      // ...
	 *                      {name: 'Jack', score: 69}];
	 *      byGrade(students);
	 *      // {
	 *      //   'A': [{name: 'Dianne', score: 99}],
	 *      //   'B': [{name: 'Abby', score: 84}]
	 *      //   // ...,
	 *      //   'F': [{name: 'Eddy', score: 58}]
	 *      // }
	 */
	
	
	var groupBy = /*#__PURE__*/_curry2( /*#__PURE__*/_checkForMethod('groupBy', /*#__PURE__*/reduceBy(function (acc, item) {
	  if (acc == null) {
	    acc = [];
	  }
	  acc.push(item);
	  return acc;
	}, null)));
	module.exports = groupBy;

/***/ },
/* 189 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/groupWith.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Takes a list and returns a list of lists where each sublist's elements are
	 * all satisfied pairwise comparison according to the provided function.
	 * Only adjacent elements are passed to the comparison function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.21.0
	 * @category List
	 * @sig ((a, a)  Boolean)  [a]  [[a]]
	 * @param {Function} fn Function for determining whether two given (adjacent)
	 *        elements should be in the same group
	 * @param {Array} list The array to group. Also accepts a string, which will be
	 *        treated as a list of characters.
	 * @return {List} A list that contains sublists of elements,
	 *         whose concatenations are equal to the original list.
	 * @example
	 *
	 * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
	 * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
	 *
	 * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])
	 * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]
	 *
	 * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
	 * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
	 *
	 * R.groupWith(R.eqBy(isVowel), 'aestiou')
	 * //=> ['ae', 'st', 'iou']
	 */
	
	
	var groupWith = /*#__PURE__*/_curry2(function (fn, list) {
	  var res = [];
	  var idx = 0;
	  var len = list.length;
	  while (idx < len) {
	    var nextidx = idx + 1;
	    while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
	      nextidx += 1;
	    }
	    res.push(list.slice(idx, nextidx));
	    idx = nextidx;
	  }
	  return res;
	});
	module.exports = groupWith;

/***/ },
/* 190 */
/*!***************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/gt.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns `true` if the first argument is greater than the second; `false`
	 * otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> Boolean
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 * @see R.lt
	 * @example
	 *
	 *      R.gt(2, 1); //=> true
	 *      R.gt(2, 2); //=> false
	 *      R.gt(2, 3); //=> false
	 *      R.gt('a', 'z'); //=> false
	 *      R.gt('z', 'a'); //=> true
	 */
	
	
	var gt = /*#__PURE__*/_curry2(function gt(a, b) {
	  return a > b;
	});
	module.exports = gt;

/***/ },
/* 191 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/gte.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns `true` if the first argument is greater than or equal to the second;
	 * `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> Boolean
	 * @param {Number} a
	 * @param {Number} b
	 * @return {Boolean}
	 * @see R.lte
	 * @example
	 *
	 *      R.gte(2, 1); //=> true
	 *      R.gte(2, 2); //=> true
	 *      R.gte(2, 3); //=> false
	 *      R.gte('a', 'z'); //=> false
	 *      R.gte('z', 'a'); //=> true
	 */
	
	
	var gte = /*#__PURE__*/_curry2(function gte(a, b) {
	  return a >= b;
	});
	module.exports = gte;

/***/ },
/* 192 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/has.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	/**
	 * Returns whether or not an object has an own property with the specified name
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Object
	 * @sig s -> {s: x} -> Boolean
	 * @param {String} prop The name of the property to check for.
	 * @param {Object} obj The object to query.
	 * @return {Boolean} Whether the property exists.
	 * @example
	 *
	 *      var hasName = R.has('name');
	 *      hasName({name: 'alice'});   //=> true
	 *      hasName({name: 'bob'});     //=> true
	 *      hasName({});                //=> false
	 *
	 *      var point = {x: 0, y: 0};
	 *      var pointHas = R.has(R.__, point);
	 *      pointHas('x');  //=> true
	 *      pointHas('y');  //=> true
	 *      pointHas('z');  //=> false
	 */
	
	
	var has = /*#__PURE__*/_curry2(_has);
	module.exports = has;

/***/ },
/* 193 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/hasIn.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns whether or not an object or its prototype chain has a property with
	 * the specified name
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Object
	 * @sig s -> {s: x} -> Boolean
	 * @param {String} prop The name of the property to check for.
	 * @param {Object} obj The object to query.
	 * @return {Boolean} Whether the property exists.
	 * @example
	 *
	 *      function Rectangle(width, height) {
	 *        this.width = width;
	 *        this.height = height;
	 *      }
	 *      Rectangle.prototype.area = function() {
	 *        return this.width * this.height;
	 *      };
	 *
	 *      var square = new Rectangle(2, 2);
	 *      R.hasIn('width', square);  //=> true
	 *      R.hasIn('area', square);  //=> true
	 */
	
	
	var hasIn = /*#__PURE__*/_curry2(function hasIn(prop, obj) {
	  return prop in obj;
	});
	module.exports = hasIn;

/***/ },
/* 194 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/head.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var nth = /*#__PURE__*/__webpack_require__(/*! ./nth */ 164);
	
	/**
	 * Returns the first element of the given list or string. In some libraries
	 * this function is named `first`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> a | Undefined
	 * @sig String -> String
	 * @param {Array|String} list
	 * @return {*}
	 * @see R.tail, R.init, R.last
	 * @example
	 *
	 *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
	 *      R.head([]); //=> undefined
	 *
	 *      R.head('abc'); //=> 'a'
	 *      R.head(''); //=> ''
	 */
	
	
	var head = /*#__PURE__*/nth(0);
	module.exports = head;

/***/ },
/* 195 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/identity.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _identity = /*#__PURE__*/__webpack_require__(/*! ./internal/_identity */ 196);
	
	/**
	 * A function that does nothing but return the parameter supplied to it. Good
	 * as a default or placeholder function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig a -> a
	 * @param {*} x The value to return.
	 * @return {*} The input value, `x`.
	 * @example
	 *
	 *      R.identity(1); //=> 1
	 *
	 *      var obj = {};
	 *      R.identity(obj) === obj; //=> true
	 * @symb R.identity(a) = a
	 */
	
	
	var identity = /*#__PURE__*/_curry1(_identity);
	module.exports = identity;

/***/ },
/* 196 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_identity.js ***!
  \*******************************************************************************/
/***/ function(module, exports) {

	function _identity(x) {
	  return x;
	}
	module.exports = _identity;

/***/ },
/* 197 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/ifElse.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	/**
	 * Creates a function that will process either the `onTrue` or the `onFalse`
	 * function depending upon the result of the `condition` predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Logic
	 * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
	 * @param {Function} condition A predicate function
	 * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
	 * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
	 * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
	 *                    function depending upon the result of the `condition` predicate.
	 * @see R.unless, R.when
	 * @example
	 *
	 *      var incCount = R.ifElse(
	 *        R.has('count'),
	 *        R.over(R.lensProp('count'), R.inc),
	 *        R.assoc('count', 1)
	 *      );
	 *      incCount({});           //=> { count: 1 }
	 *      incCount({ count: 1 }); //=> { count: 2 }
	 */
	
	
	var ifElse = /*#__PURE__*/_curry3(function ifElse(condition, onTrue, onFalse) {
	  return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
	    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
	  });
	});
	module.exports = ifElse;

/***/ },
/* 198 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/inc.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var add = /*#__PURE__*/__webpack_require__(/*! ./add */ 30);
	
	/**
	 * Increments its argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Math
	 * @sig Number -> Number
	 * @param {Number} n
	 * @return {Number} n + 1
	 * @see R.dec
	 * @example
	 *
	 *      R.inc(42); //=> 43
	 */
	
	
	var inc = /*#__PURE__*/add(1);
	module.exports = inc;

/***/ },
/* 199 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/indexBy.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var reduceBy = /*#__PURE__*/__webpack_require__(/*! ./reduceBy */ 138);
	
	/**
	 * Given a function that generates a key, turns a list of objects into an
	 * object indexing the objects by the given key. Note that if multiple
	 * objects generate the same value for the indexing key only the last value
	 * will be included in the generated object.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
	 * @param {Function} fn Function :: a -> String
	 * @param {Array} array The array of objects to index
	 * @return {Object} An object indexing each array element by the given property.
	 * @example
	 *
	 *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
	 *      R.indexBy(R.prop('id'), list);
	 *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
	 */
	
	
	var indexBy = /*#__PURE__*/reduceBy(function (acc, elem) {
	  return elem;
	}, null);
	module.exports = indexBy;

/***/ },
/* 200 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/indexOf.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _indexOf = /*#__PURE__*/__webpack_require__(/*! ./internal/_indexOf */ 117);
	
	var _isArray = /*#__PURE__*/__webpack_require__(/*! ./internal/_isArray */ 41);
	
	/**
	 * Returns the position of the first occurrence of an item in an array, or -1
	 * if the item is not included in the array. [`R.equals`](#equals) is used to
	 * determine equality.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> Number
	 * @param {*} target The item to find.
	 * @param {Array} xs The array to search in.
	 * @return {Number} the index of the target, or -1 if the target is not found.
	 * @see R.lastIndexOf
	 * @example
	 *
	 *      R.indexOf(3, [1,2,3,4]); //=> 2
	 *      R.indexOf(10, [1,2,3,4]); //=> -1
	 */
	
	
	var indexOf = /*#__PURE__*/_curry2(function indexOf(target, xs) {
	  return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
	});
	module.exports = indexOf;

/***/ },
/* 201 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/init.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Returns all but the last element of the given list or string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category List
	 * @sig [a] -> [a]
	 * @sig String -> String
	 * @param {*} list
	 * @return {*}
	 * @see R.last, R.head, R.tail
	 * @example
	 *
	 *      R.init([1, 2, 3]);  //=> [1, 2]
	 *      R.init([1, 2]);     //=> [1]
	 *      R.init([1]);        //=> []
	 *      R.init([]);         //=> []
	 *
	 *      R.init('abc');  //=> 'ab'
	 *      R.init('ab');   //=> 'a'
	 *      R.init('a');    //=> ''
	 *      R.init('');     //=> ''
	 */
	
	
	var init = /*#__PURE__*/slice(0, -1);
	module.exports = init;

/***/ },
/* 202 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/innerJoin.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _containsWith = /*#__PURE__*/__webpack_require__(/*! ./internal/_containsWith */ 121);
	
	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var _filter = /*#__PURE__*/__webpack_require__(/*! ./internal/_filter */ 129);
	
	/**
	 * Takes a predicate `pred`, a list `xs`, and a list `ys`, and returns a list
	 * `xs'` comprising each of the elements of `xs` which is equal to one or more
	 * elements of `ys` according to `pred`.
	 *
	 * `pred` must be a binary function expecting an element from each list.
	 *
	 * `xs`, `ys`, and `xs'` are treated as sets, semantically, so ordering should
	 * not be significant, but since `xs'` is ordered the implementation guarantees
	 * that its values are in the same order as they appear in `xs`. Duplicates are
	 * not removed, so `xs'` may contain duplicates if `xs` contains duplicates.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Relation
	 * @sig ((a, b) -> Boolean) -> [a] -> [b] -> [a]
	 * @param {Function} pred
	 * @param {Array} xs
	 * @param {Array} ys
	 * @return {Array}
	 * @see R.intersection
	 * @example
	 *
	 *      R.innerJoin(
	 *        (record, id) => record.id === id,
	 *        [{id: 824, name: 'Richie Furay'},
	 *         {id: 956, name: 'Dewey Martin'},
	 *         {id: 313, name: 'Bruce Palmer'},
	 *         {id: 456, name: 'Stephen Stills'},
	 *         {id: 177, name: 'Neil Young'}],
	 *        [177, 456, 999]
	 *      );
	 *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
	 */
	
	
	var innerJoin = /*#__PURE__*/_curry3(function innerJoin(pred, xs, ys) {
	  return _filter(function (x) {
	    return _containsWith(pred, x, ys);
	  }, xs);
	});
	module.exports = innerJoin;

/***/ },
/* 203 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/insert.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Inserts the supplied element into the list, at the specified `index`. _Note that
	
	 * this is not destructive_: it returns a copy of the list with the changes.
	 * <small>No lists have been harmed in the application of this function.</small>
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.2
	 * @category List
	 * @sig Number -> a -> [a] -> [a]
	 * @param {Number} index The position to insert the element
	 * @param {*} elt The element to insert into the Array
	 * @param {Array} list The list to insert into
	 * @return {Array} A new Array with `elt` inserted at `index`.
	 * @example
	 *
	 *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
	 */
	
	
	var insert = /*#__PURE__*/_curry3(function insert(idx, elt, list) {
	  idx = idx < list.length && idx >= 0 ? idx : list.length;
	  var result = Array.prototype.slice.call(list, 0);
	  result.splice(idx, 0, elt);
	  return result;
	});
	module.exports = insert;

/***/ },
/* 204 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/insertAll.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Inserts the sub-list into the list, at the specified `index`. _Note that this is not
	 * destructive_: it returns a copy of the list with the changes.
	 * <small>No lists have been harmed in the application of this function.</small>
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category List
	 * @sig Number -> [a] -> [a] -> [a]
	 * @param {Number} index The position to insert the sub-list
	 * @param {Array} elts The sub-list to insert into the Array
	 * @param {Array} list The list to insert the sub-list into
	 * @return {Array} A new Array with `elts` inserted starting at `index`.
	 * @example
	 *
	 *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
	 */
	
	
	var insertAll = /*#__PURE__*/_curry3(function insertAll(idx, elts, list) {
	  idx = idx < list.length && idx >= 0 ? idx : list.length;
	  return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
	});
	module.exports = insertAll;

/***/ },
/* 205 */
/*!*************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/intersection.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _contains = /*#__PURE__*/__webpack_require__(/*! ./internal/_contains */ 116);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _filter = /*#__PURE__*/__webpack_require__(/*! ./internal/_filter */ 129);
	
	var flip = /*#__PURE__*/__webpack_require__(/*! ./flip */ 184);
	
	var uniq = /*#__PURE__*/__webpack_require__(/*! ./uniq */ 206);
	
	/**
	 * Combines two lists into a set (i.e. no duplicates) composed of those
	 * elements common to both lists.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig [*] -> [*] -> [*]
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The list of elements found in both `list1` and `list2`.
	 * @see R.innerJoin
	 * @example
	 *
	 *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
	 */
	
	
	var intersection = /*#__PURE__*/_curry2(function intersection(list1, list2) {
	  var lookupList, filteredList;
	  if (list1.length > list2.length) {
	    lookupList = list1;
	    filteredList = list2;
	  } else {
	    lookupList = list2;
	    filteredList = list1;
	  }
	  return uniq(_filter(flip(_contains)(lookupList), filteredList));
	});
	module.exports = intersection;

/***/ },
/* 206 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/uniq.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var identity = /*#__PURE__*/__webpack_require__(/*! ./identity */ 195);
	
	var uniqBy = /*#__PURE__*/__webpack_require__(/*! ./uniqBy */ 207);
	
	/**
	 * Returns a new list containing only one copy of each element in the original
	 * list. [`R.equals`](#equals) is used to determine equality.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [a]
	 * @param {Array} list The array to consider.
	 * @return {Array} The list of unique items.
	 * @example
	 *
	 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
	 *      R.uniq([1, '1']);     //=> [1, '1']
	 *      R.uniq([[42], [42]]); //=> [[42]]
	 */
	
	
	var uniq = /*#__PURE__*/uniqBy(identity);
	module.exports = uniq;

/***/ },
/* 207 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/uniqBy.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _Set = /*#__PURE__*/__webpack_require__(/*! ./internal/_Set */ 208);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a new list containing only one copy of each element in the original
	 * list, based upon the value returned by applying the supplied function to
	 * each list element. Prefers the first item if the supplied function produces
	 * the same value on two items. [`R.equals`](#equals) is used for comparison.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig (a -> b) -> [a] -> [a]
	 * @param {Function} fn A function used to produce a value to use during comparisons.
	 * @param {Array} list The array to consider.
	 * @return {Array} The list of unique items.
	 * @example
	 *
	 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
	 */
	
	
	var uniqBy = /*#__PURE__*/_curry2(function uniqBy(fn, list) {
	  var set = new _Set();
	  var result = [];
	  var idx = 0;
	  var appliedItem, item;
	
	  while (idx < list.length) {
	    item = list[idx];
	    appliedItem = fn(item);
	    if (set.add(appliedItem)) {
	      result.push(item);
	    }
	    idx += 1;
	  }
	  return result;
	});
	module.exports = uniqBy;

/***/ },
/* 208 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_Set.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _contains = /*#__PURE__*/__webpack_require__(/*! ./_contains */ 116);
	
	var _Set = /*#__PURE__*/function () {
	
	  function _Set() {
	    /* globals Set */
	    this._nativeSet = typeof Set === 'function' ? new Set() : null;
	    this._items = {};
	  }
	
	  // until we figure out why jsdoc chokes on this
	  // @param item The item to add to the Set
	  // @returns {boolean} true if the item did not exist prior, otherwise false
	  //
	  _Set.prototype.add = function (item) {
	    return !hasOrAdd(item, true, this);
	  };
	
	  //
	  // @param item The item to check for existence in the Set
	  // @returns {boolean} true if the item exists in the Set, otherwise false
	  //
	  _Set.prototype.has = function (item) {
	    return hasOrAdd(item, false, this);
	  };
	
	  //
	  // Combines the logic for checking whether an item is a member of the set and
	  // for adding a new item to the set.
	  //
	  // @param item       The item to check or add to the Set instance.
	  // @param shouldAdd  If true, the item will be added to the set if it doesn't
	  //                   already exist.
	  // @param set        The set instance to check or add to.
	  // @return {boolean} true if the item already existed, otherwise false.
	  //
	  return _Set;
	}();
	
	function hasOrAdd(item, shouldAdd, set) {
	  var type = typeof item;
	  var prevSize, newSize;
	  switch (type) {
	    case 'string':
	    case 'number':
	      // distinguish between +0 and -0
	      if (item === 0 && 1 / item === -Infinity) {
	        if (set._items['-0']) {
	          return true;
	        } else {
	          if (shouldAdd) {
	            set._items['-0'] = true;
	          }
	          return false;
	        }
	      }
	      // these types can all utilise the native Set
	      if (set._nativeSet !== null) {
	        if (shouldAdd) {
	          prevSize = set._nativeSet.size;
	          set._nativeSet.add(item);
	          newSize = set._nativeSet.size;
	          return newSize === prevSize;
	        } else {
	          return set._nativeSet.has(item);
	        }
	      } else {
	        if (!(type in set._items)) {
	          if (shouldAdd) {
	            set._items[type] = {};
	            set._items[type][item] = true;
	          }
	          return false;
	        } else if (item in set._items[type]) {
	          return true;
	        } else {
	          if (shouldAdd) {
	            set._items[type][item] = true;
	          }
	          return false;
	        }
	      }
	
	    case 'boolean':
	      // set._items['boolean'] holds a two element array
	      // representing [ falseExists, trueExists ]
	      if (type in set._items) {
	        var bIdx = item ? 1 : 0;
	        if (set._items[type][bIdx]) {
	          return true;
	        } else {
	          if (shouldAdd) {
	            set._items[type][bIdx] = true;
	          }
	          return false;
	        }
	      } else {
	        if (shouldAdd) {
	          set._items[type] = item ? [false, true] : [true, false];
	        }
	        return false;
	      }
	
	    case 'function':
	      // compare functions for reference equality
	      if (set._nativeSet !== null) {
	        if (shouldAdd) {
	          prevSize = set._nativeSet.size;
	          set._nativeSet.add(item);
	          newSize = set._nativeSet.size;
	          return newSize === prevSize;
	        } else {
	          return set._nativeSet.has(item);
	        }
	      } else {
	        if (!(type in set._items)) {
	          if (shouldAdd) {
	            set._items[type] = [item];
	          }
	          return false;
	        }
	        if (!_contains(item, set._items[type])) {
	          if (shouldAdd) {
	            set._items[type].push(item);
	          }
	          return false;
	        }
	        return true;
	      }
	
	    case 'undefined':
	      if (set._items[type]) {
	        return true;
	      } else {
	        if (shouldAdd) {
	          set._items[type] = true;
	        }
	        return false;
	      }
	
	    case 'object':
	      if (item === null) {
	        if (!set._items['null']) {
	          if (shouldAdd) {
	            set._items['null'] = true;
	          }
	          return false;
	        }
	        return true;
	      }
	    /* falls through */
	    default:
	      // reduce the search size of heterogeneous sets by creating buckets
	      // for each type.
	      type = Object.prototype.toString.call(item);
	      if (!(type in set._items)) {
	        if (shouldAdd) {
	          set._items[type] = [item];
	        }
	        return false;
	      }
	      // scan through all previously applied items
	      if (!_contains(item, set._items[type])) {
	        if (shouldAdd) {
	          set._items[type].push(item);
	        }
	        return false;
	      }
	      return true;
	  }
	}
	
	// A simple Set type that honours R.equals semantics
	module.exports = _Set;

/***/ },
/* 209 */
/*!************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/intersperse.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _checkForMethod = /*#__PURE__*/__webpack_require__(/*! ./internal/_checkForMethod */ 106);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Creates a new list with the separator interposed between elements.
	 *
	 * Dispatches to the `intersperse` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category List
	 * @sig a -> [a] -> [a]
	 * @param {*} separator The element to add to the list.
	 * @param {Array} list The list to be interposed.
	 * @return {Array} The new list.
	 * @example
	 *
	 *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
	 */
	
	
	var intersperse = /*#__PURE__*/_curry2( /*#__PURE__*/_checkForMethod('intersperse', function intersperse(separator, list) {
	  var out = [];
	  var idx = 0;
	  var length = list.length;
	  while (idx < length) {
	    if (idx === length - 1) {
	      out.push(list[idx]);
	    } else {
	      out.push(list[idx], separator);
	    }
	    idx += 1;
	  }
	  return out;
	}));
	module.exports = intersperse;

/***/ },
/* 210 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/into.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _clone = /*#__PURE__*/__webpack_require__(/*! ./internal/_clone */ 96);
	
	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var _isTransformer = /*#__PURE__*/__webpack_require__(/*! ./internal/_isTransformer */ 42);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var _stepCat = /*#__PURE__*/__webpack_require__(/*! ./internal/_stepCat */ 211);
	
	/**
	 * Transforms the items of the list with the transducer and appends the
	 * transformed items to the accumulator using an appropriate iterator function
	 * based on the accumulator type.
	 *
	 * The accumulator can be an array, string, object or a transformer. Iterated
	 * items will be appended to arrays and concatenated to strings. Objects will
	 * be merged directly or 2-item arrays will be merged as key, value pairs.
	 *
	 * The accumulator can also be a transformer object that provides a 2-arity
	 * reducing iterator function, step, 0-arity initial value function, init, and
	 * 1-arity result extraction function result. The step function is used as the
	 * iterator function in reduce. The result function is used to convert the
	 * final accumulator into the return type and in most cases is R.identity. The
	 * init function is used to provide the initial accumulator.
	 *
	 * The iteration is performed with [`R.reduce`](#reduce) after initializing the
	 * transducer.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category List
	 * @sig a -> (b -> b) -> [c] -> a
	 * @param {*} acc The initial accumulator value.
	 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @example
	 *
	 *      var numbers = [1, 2, 3, 4];
	 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	 *
	 *      R.into([], transducer, numbers); //=> [2, 3]
	 *
	 *      var intoArray = R.into([]);
	 *      intoArray(transducer, numbers); //=> [2, 3]
	 */
	
	
	var into = /*#__PURE__*/_curry3(function into(acc, xf, list) {
	  return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
	});
	module.exports = into;

/***/ },
/* 211 */
/*!******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_stepCat.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _assign = /*#__PURE__*/__webpack_require__(/*! ./_assign */ 212);
	
	var _identity = /*#__PURE__*/__webpack_require__(/*! ./_identity */ 196);
	
	var _isArrayLike = /*#__PURE__*/__webpack_require__(/*! ./_isArrayLike */ 52);
	
	var _isTransformer = /*#__PURE__*/__webpack_require__(/*! ./_isTransformer */ 42);
	
	var objOf = /*#__PURE__*/__webpack_require__(/*! ../objOf */ 214);
	
	var _stepCatArray = {
	  '@@transducer/init': Array,
	  '@@transducer/step': function (xs, x) {
	    xs.push(x);
	    return xs;
	  },
	  '@@transducer/result': _identity
	};
	var _stepCatString = {
	  '@@transducer/init': String,
	  '@@transducer/step': function (a, b) {
	    return a + b;
	  },
	  '@@transducer/result': _identity
	};
	var _stepCatObject = {
	  '@@transducer/init': Object,
	  '@@transducer/step': function (result, input) {
	    return _assign(result, _isArrayLike(input) ? objOf(input[0], input[1]) : input);
	  },
	  '@@transducer/result': _identity
	};
	
	function _stepCat(obj) {
	  if (_isTransformer(obj)) {
	    return obj;
	  }
	  if (_isArrayLike(obj)) {
	    return _stepCatArray;
	  }
	  if (typeof obj === 'string') {
	    return _stepCatString;
	  }
	  if (typeof obj === 'object') {
	    return _stepCatObject;
	  }
	  throw new Error('Cannot create transformer for ' + obj);
	}
	module.exports = _stepCat;

/***/ },
/* 212 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_assign.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _objectAssign = /*#__PURE__*/__webpack_require__(/*! ./_objectAssign */ 213);
	
	module.exports = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

/***/ },
/* 213 */
/*!***********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_objectAssign.js ***!
  \***********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _has = /*#__PURE__*/__webpack_require__(/*! ./_has */ 58);
	
	// Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
	
	function _objectAssign(target) {
	  if (target == null) {
	    throw new TypeError('Cannot convert undefined or null to object');
	  }
	
	  var output = Object(target);
	  var idx = 1;
	  var length = arguments.length;
	  while (idx < length) {
	    var source = arguments[idx];
	    if (source != null) {
	      for (var nextKey in source) {
	        if (_has(nextKey, source)) {
	          output[nextKey] = source[nextKey];
	        }
	      }
	    }
	    idx += 1;
	  }
	  return output;
	}
	module.exports = _objectAssign;

/***/ },
/* 214 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/objOf.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Creates an object containing a single key:value pair.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Object
	 * @sig String -> a -> {String:a}
	 * @param {String} key
	 * @param {*} val
	 * @return {Object}
	 * @see R.pair
	 * @example
	 *
	 *      var matchPhrases = R.compose(
	 *        R.objOf('must'),
	 *        R.map(R.objOf('match_phrase'))
	 *      );
	 *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
	 */
	
	
	var objOf = /*#__PURE__*/_curry2(function objOf(key, val) {
	  var obj = {};
	  obj[key] = val;
	  return obj;
	});
	module.exports = objOf;

/***/ },
/* 215 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/invert.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ 57);
	
	/**
	 * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
	 * duplicate values by putting the values into an array.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Object
	 * @sig {s: x} -> {x: [ s, ... ]}
	 * @param {Object} obj The object or array to invert
	 * @return {Object} out A new object with keys in an array.
	 * @see R.invertObj
	 * @example
	 *
	 *      var raceResultsByFirstName = {
	 *        first: 'alice',
	 *        second: 'jake',
	 *        third: 'alice',
	 *      };
	 *      R.invert(raceResultsByFirstName);
	 *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
	 */
	
	
	var invert = /*#__PURE__*/_curry1(function invert(obj) {
	  var props = keys(obj);
	  var len = props.length;
	  var idx = 0;
	  var out = {};
	
	  while (idx < len) {
	    var key = props[idx];
	    var val = obj[key];
	    var list = _has(val, out) ? out[val] : out[val] = [];
	    list[list.length] = key;
	    idx += 1;
	  }
	  return out;
	});
	module.exports = invert;

/***/ },
/* 216 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/invertObj.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ 57);
	
	/**
	 * Returns a new object with the keys of the given object as values, and the
	 * values of the given object, which are coerced to strings, as keys. Note
	 * that the last key found is preferred when handling the same value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Object
	 * @sig {s: x} -> {x: s}
	 * @param {Object} obj The object or array to invert
	 * @return {Object} out A new object
	 * @see R.invert
	 * @example
	 *
	 *      var raceResults = {
	 *        first: 'alice',
	 *        second: 'jake'
	 *      };
	 *      R.invertObj(raceResults);
	 *      //=> { 'alice': 'first', 'jake':'second' }
	 *
	 *      // Alternatively:
	 *      var raceResults = ['alice', 'jake'];
	 *      R.invertObj(raceResults);
	 *      //=> { 'alice': '0', 'jake':'1' }
	 */
	
	
	var invertObj = /*#__PURE__*/_curry1(function invertObj(obj) {
	  var props = keys(obj);
	  var len = props.length;
	  var idx = 0;
	  var out = {};
	
	  while (idx < len) {
	    var key = props[idx];
	    out[obj[key]] = key;
	    idx += 1;
	  }
	  return out;
	});
	module.exports = invertObj;

/***/ },
/* 217 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/invoker.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isFunction = /*#__PURE__*/__webpack_require__(/*! ./internal/_isFunction */ 84);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	var toString = /*#__PURE__*/__webpack_require__(/*! ./toString */ 114);
	
	/**
	 * Turns a named method with a specified arity into a function that can be
	 * called directly supplied with arguments and a target object.
	 *
	 * The returned function is curried and accepts `arity + 1` parameters where
	 * the final parameter is the target object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
	 * @param {Number} arity Number of arguments the returned function should take
	 *        before the target object.
	 * @param {String} method Name of the method to call.
	 * @return {Function} A new curried function.
	 * @see R.construct
	 * @example
	 *
	 *      var sliceFrom = R.invoker(1, 'slice');
	 *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
	 *      var sliceFrom6 = R.invoker(2, 'slice')(6);
	 *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
	 * @symb R.invoker(0, 'method')(o) = o['method']()
	 * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
	 * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
	 */
	
	
	var invoker = /*#__PURE__*/_curry2(function invoker(arity, method) {
	  return curryN(arity + 1, function () {
	    var target = arguments[arity];
	    if (target != null && _isFunction(target[method])) {
	      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
	    }
	    throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
	  });
	});
	module.exports = invoker;

/***/ },
/* 218 */
/*!***************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/is.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * See if an object (`val`) is an instance of the supplied constructor. This
	 * function will check up the inheritance chain, if any.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Type
	 * @sig (* -> {*}) -> a -> Boolean
	 * @param {Object} ctor A constructor
	 * @param {*} val The value to test
	 * @return {Boolean}
	 * @example
	 *
	 *      R.is(Object, {}); //=> true
	 *      R.is(Number, 1); //=> true
	 *      R.is(Object, 1); //=> false
	 *      R.is(String, 's'); //=> true
	 *      R.is(String, new String('')); //=> true
	 *      R.is(Object, new String('')); //=> true
	 *      R.is(Object, 's'); //=> false
	 *      R.is(Number, {}); //=> false
	 */
	
	
	var is = /*#__PURE__*/_curry2(function is(Ctor, val) {
	  return val != null && val.constructor === Ctor || val instanceof Ctor;
	});
	module.exports = is;

/***/ },
/* 219 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/isEmpty.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var empty = /*#__PURE__*/__webpack_require__(/*! ./empty */ 169);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	/**
	 * Returns `true` if the given value is its type's empty value; `false`
	 * otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Logic
	 * @sig a -> Boolean
	 * @param {*} x
	 * @return {Boolean}
	 * @see R.empty
	 * @example
	 *
	 *      R.isEmpty([1, 2, 3]);   //=> false
	 *      R.isEmpty([]);          //=> true
	 *      R.isEmpty('');          //=> true
	 *      R.isEmpty(null);        //=> false
	 *      R.isEmpty({});          //=> true
	 *      R.isEmpty({length: 0}); //=> false
	 */
	
	
	var isEmpty = /*#__PURE__*/_curry1(function isEmpty(x) {
	  return x != null && equals(x, empty(x));
	});
	module.exports = isEmpty;

/***/ },
/* 220 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/join.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var invoker = /*#__PURE__*/__webpack_require__(/*! ./invoker */ 217);
	
	/**
	 * Returns a string made by inserting the `separator` between each element and
	 * concatenating all the elements into a single string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig String -> [a] -> String
	 * @param {Number|String} separator The string used to separate the elements.
	 * @param {Array} xs The elements to join into a string.
	 * @return {String} str The string made by concatenating `xs` with `separator`.
	 * @see R.split
	 * @example
	 *
	 *      var spacer = R.join(' ');
	 *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
	 *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
	 */
	
	
	var join = /*#__PURE__*/invoker(1, 'join');
	module.exports = join;

/***/ },
/* 221 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/juxt.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var converge = /*#__PURE__*/__webpack_require__(/*! ./converge */ 136);
	
	/**
	 * juxt applies a list of functions to a list of values.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Function
	 * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
	 * @param {Array} fns An array of functions
	 * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
	 * @see R.applySpec
	 * @example
	 *
	 *      var getRange = R.juxt([Math.min, Math.max]);
	 *      getRange(3, 4, 9, -3); //=> [-3, 9]
	 * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
	 */
	
	
	var juxt = /*#__PURE__*/_curry1(function juxt(fns) {
	  return converge(function () {
	    return Array.prototype.slice.call(arguments, 0);
	  }, fns);
	});
	module.exports = juxt;

/***/ },
/* 222 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/keysIn.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Returns a list containing the names of all the properties of the supplied
	 * object, including prototype properties.
	 * Note that the order of the output array is not guaranteed to be consistent
	 * across different JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Object
	 * @sig {k: v} -> [k]
	 * @param {Object} obj The object to extract properties from
	 * @return {Array} An array of the object's own and prototype properties.
	 * @see R.keys, R.valuesIn
	 * @example
	 *
	 *      var F = function() { this.x = 'X'; };
	 *      F.prototype.y = 'Y';
	 *      var f = new F();
	 *      R.keysIn(f); //=> ['x', 'y']
	 */
	
	
	var keysIn = /*#__PURE__*/_curry1(function keysIn(obj) {
	  var prop;
	  var ks = [];
	  for (prop in obj) {
	    ks[ks.length] = prop;
	  }
	  return ks;
	});
	module.exports = keysIn;

/***/ },
/* 223 */
/*!************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/lastIndexOf.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isArray = /*#__PURE__*/__webpack_require__(/*! ./internal/_isArray */ 41);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	/**
	 * Returns the position of the last occurrence of an item in an array, or -1 if
	 * the item is not included in the array. [`R.equals`](#equals) is used to
	 * determine equality.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> Number
	 * @param {*} target The item to find.
	 * @param {Array} xs The array to search in.
	 * @return {Number} the index of the target, or -1 if the target is not found.
	 * @see R.indexOf
	 * @example
	 *
	 *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
	 *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
	 */
	
	
	var lastIndexOf = /*#__PURE__*/_curry2(function lastIndexOf(target, xs) {
	  if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
	    return xs.lastIndexOf(target);
	  } else {
	    var idx = xs.length - 1;
	    while (idx >= 0) {
	      if (equals(xs[idx], target)) {
	        return idx;
	      }
	      idx -= 1;
	    }
	    return -1;
	  }
	});
	module.exports = lastIndexOf;

/***/ },
/* 224 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/length.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _isNumber = /*#__PURE__*/__webpack_require__(/*! ./internal/_isNumber */ 225);
	
	/**
	 * Returns the number of elements in the array by returning `list.length`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig [a] -> Number
	 * @param {Array} list The array to inspect.
	 * @return {Number} The length of the array.
	 * @example
	 *
	 *      R.length([]); //=> 0
	 *      R.length([1, 2, 3]); //=> 3
	 */
	
	
	var length = /*#__PURE__*/_curry1(function length(list) {
	  return list != null && _isNumber(list.length) ? list.length : NaN;
	});
	module.exports = length;

/***/ },
/* 225 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isNumber.js ***!
  \*******************************************************************************/
/***/ function(module, exports) {

	function _isNumber(x) {
	  return Object.prototype.toString.call(x) === '[object Number]';
	}
	module.exports = _isNumber;

/***/ },
/* 226 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/lens.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	/**
	 * Returns a lens for the given getter and setter functions. The getter "gets"
	 * the value of the focus; the setter "sets" the value of the focus. The setter
	 * should not mutate the data structure.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
	 * @param {Function} getter
	 * @param {Function} setter
	 * @return {Lens}
	 * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
	 * @example
	 *
	 *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
	 *
	 *      R.view(xLens, {x: 1, y: 2});            //=> 1
	 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	 */
	
	
	var lens = /*#__PURE__*/_curry2(function lens(getter, setter) {
	  return function (toFunctorFn) {
	    return function (target) {
	      return map(function (focus) {
	        return setter(focus, target);
	      }, toFunctorFn(getter(target)));
	    };
	  };
	});
	module.exports = lens;

/***/ },
/* 227 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/lensIndex.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var lens = /*#__PURE__*/__webpack_require__(/*! ./lens */ 226);
	
	var nth = /*#__PURE__*/__webpack_require__(/*! ./nth */ 164);
	
	var update = /*#__PURE__*/__webpack_require__(/*! ./update */ 148);
	
	/**
	 * Returns a lens whose focus is the specified index.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig Number -> Lens s a
	 * @param {Number} n
	 * @return {Lens}
	 * @see R.view, R.set, R.over
	 * @example
	 *
	 *      var headLens = R.lensIndex(0);
	 *
	 *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
	 *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
	 *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
	 */
	
	
	var lensIndex = /*#__PURE__*/_curry1(function lensIndex(n) {
	  return lens(nth(n), update(n));
	});
	module.exports = lensIndex;

/***/ },
/* 228 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/lensPath.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var assocPath = /*#__PURE__*/__webpack_require__(/*! ./assocPath */ 78);
	
	var lens = /*#__PURE__*/__webpack_require__(/*! ./lens */ 226);
	
	var path = /*#__PURE__*/__webpack_require__(/*! ./path */ 61);
	
	/**
	 * Returns a lens whose focus is the specified path.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig [Idx] -> Lens s a
	 * @param {Array} path The path to use.
	 * @return {Lens}
	 * @see R.view, R.set, R.over
	 * @example
	 *
	 *      var xHeadYLens = R.lensPath(['x', 0, 'y']);
	 *
	 *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
	 *      //=> 2
	 *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
	 *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
	 *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
	 *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
	 */
	
	
	var lensPath = /*#__PURE__*/_curry1(function lensPath(p) {
	  return lens(path(p), assocPath(p));
	});
	module.exports = lensPath;

/***/ },
/* 229 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/lensProp.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var assoc = /*#__PURE__*/__webpack_require__(/*! ./assoc */ 77);
	
	var lens = /*#__PURE__*/__webpack_require__(/*! ./lens */ 226);
	
	var prop = /*#__PURE__*/__webpack_require__(/*! ./prop */ 60);
	
	/**
	 * Returns a lens whose focus is the specified property.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig String -> Lens s a
	 * @param {String} k
	 * @return {Lens}
	 * @see R.view, R.set, R.over
	 * @example
	 *
	 *      var xLens = R.lensProp('x');
	 *
	 *      R.view(xLens, {x: 1, y: 2});            //=> 1
	 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
	 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
	 */
	
	
	var lensProp = /*#__PURE__*/_curry1(function lensProp(k) {
	  return lens(prop(k), assoc(k));
	});
	module.exports = lensProp;

/***/ },
/* 230 */
/*!***************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/lt.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns `true` if the first argument is less than the second; `false`
	 * otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> Boolean
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 * @see R.gt
	 * @example
	 *
	 *      R.lt(2, 1); //=> false
	 *      R.lt(2, 2); //=> false
	 *      R.lt(2, 3); //=> true
	 *      R.lt('a', 'z'); //=> true
	 *      R.lt('z', 'a'); //=> false
	 */
	
	
	var lt = /*#__PURE__*/_curry2(function lt(a, b) {
	  return a < b;
	});
	module.exports = lt;

/***/ },
/* 231 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/lte.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns `true` if the first argument is less than or equal to the second;
	 * `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> Boolean
	 * @param {Number} a
	 * @param {Number} b
	 * @return {Boolean}
	 * @see R.gte
	 * @example
	 *
	 *      R.lte(2, 1); //=> false
	 *      R.lte(2, 2); //=> true
	 *      R.lte(2, 3); //=> true
	 *      R.lte('a', 'z'); //=> true
	 *      R.lte('z', 'a'); //=> false
	 */
	
	
	var lte = /*#__PURE__*/_curry2(function lte(a, b) {
	  return a <= b;
	});
	module.exports = lte;

/***/ },
/* 232 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mapAccum.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * The `mapAccum` function behaves like a combination of map and reduce; it
	 * applies a function to each element of a list, passing an accumulating
	 * parameter from left to right, and returning a final value of this
	 * accumulator together with the new list.
	 *
	 * The iterator function receives two arguments, *acc* and *value*, and should
	 * return a tuple *[acc, value]*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
	 * @param {Function} fn The function to be called on every element of the input `list`.
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.addIndex, R.mapAccumRight
	 * @example
	 *
	 *      var digits = ['1', '2', '3', '4'];
	 *      var appender = (a, b) => [a + b, a + b];
	 *
	 *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
	 * @symb R.mapAccum(f, a, [b, c, d]) = [
	 *   f(f(f(a, b)[0], c)[0], d)[0],
	 *   [
	 *     f(a, b)[1],
	 *     f(f(a, b)[0], c)[1],
	 *     f(f(f(a, b)[0], c)[0], d)[1]
	 *   ]
	 * ]
	 */
	
	
	var mapAccum = /*#__PURE__*/_curry3(function mapAccum(fn, acc, list) {
	  var idx = 0;
	  var len = list.length;
	  var result = [];
	  var tuple = [acc];
	  while (idx < len) {
	    tuple = fn(tuple[0], list[idx]);
	    result[idx] = tuple[1];
	    idx += 1;
	  }
	  return [tuple[0], result];
	});
	module.exports = mapAccum;

/***/ },
/* 233 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mapAccumRight.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * The `mapAccumRight` function behaves like a combination of map and reduce; it
	 * applies a function to each element of a list, passing an accumulating
	 * parameter from right to left, and returning a final value of this
	 * accumulator together with the new list.
	 *
	 * Similar to [`mapAccum`](#mapAccum), except moves through the input list from
	 * the right to the left.
	 *
	 * The iterator function receives two arguments, *value* and *acc*, and should
	 * return a tuple *[value, acc]*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig ((x, acc) -> (y, acc)) -> acc -> [x] -> ([y], acc)
	 * @param {Function} fn The function to be called on every element of the input `list`.
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.addIndex, R.mapAccum
	 * @example
	 *
	 *      var digits = ['1', '2', '3', '4'];
	 *      var append = (a, b) => [a + b, a + b];
	 *
	 *      R.mapAccumRight(append, 5, digits); //=> [['12345', '2345', '345', '45'], '12345']
	 * @symb R.mapAccumRight(f, a, [b, c, d]) = [
	 *   [
	 *     f(b, f(c, f(d, a)[0])[0])[1],
	 *     f(c, f(d, a)[0])[1],
	 *     f(d, a)[1],
	 *   ]
	 *   f(b, f(c, f(d, a)[0])[0])[0],
	 * ]
	 */
	
	
	var mapAccumRight = /*#__PURE__*/_curry3(function mapAccumRight(fn, acc, list) {
	  var idx = list.length - 1;
	  var result = [];
	  var tuple = [acc];
	  while (idx >= 0) {
	    tuple = fn(list[idx], tuple[0]);
	    result[idx] = tuple[1];
	    idx -= 1;
	  }
	  return [result, tuple[0]];
	});
	module.exports = mapAccumRight;

/***/ },
/* 234 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mapObjIndexed.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ 57);
	
	/**
	 * An Object-specific version of [`map`](#map). The function is applied to three
	 * arguments: *(value, key, obj)*. If only the value is significant, use
	 * [`map`](#map) instead.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Object
	 * @sig ((*, String, Object) -> *) -> Object -> Object
	 * @param {Function} fn
	 * @param {Object} obj
	 * @return {Object}
	 * @see R.map
	 * @example
	 *
	 *      var values = { x: 1, y: 2, z: 3 };
	 *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
	 *
	 *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
	 */
	
	
	var mapObjIndexed = /*#__PURE__*/_curry2(function mapObjIndexed(fn, obj) {
	  return _reduce(function (acc, key) {
	    acc[key] = fn(obj[key], key, obj);
	    return acc;
	  }, {}, keys(obj));
	});
	module.exports = mapObjIndexed;

/***/ },
/* 235 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/match.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Tests a regular expression against a String. Note that this function will
	 * return an empty array when there are no matches. This differs from
	 * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
	 * which returns `null` when there are no matches.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category String
	 * @sig RegExp -> String -> [String | Undefined]
	 * @param {RegExp} rx A regular expression.
	 * @param {String} str The string to match against
	 * @return {Array} The list of matches or empty array.
	 * @see R.test
	 * @example
	 *
	 *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
	 *      R.match(/a/, 'b'); //=> []
	 *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
	 */
	
	
	var match = /*#__PURE__*/_curry2(function match(rx, str) {
	  return str.match(rx) || [];
	});
	module.exports = match;

/***/ },
/* 236 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mathMod.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isInteger = /*#__PURE__*/__webpack_require__(/*! ./internal/_isInteger */ 79);
	
	/**
	 * `mathMod` behaves like the modulo operator should mathematically, unlike the
	 * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
	 * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
	 * arguments, and returns NaN when the modulus is zero or negative.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} m The dividend.
	 * @param {Number} p the modulus.
	 * @return {Number} The result of `b mod a`.
	 * @see R.modulo
	 * @example
	 *
	 *      R.mathMod(-17, 5);  //=> 3
	 *      R.mathMod(17, 5);   //=> 2
	 *      R.mathMod(17, -5);  //=> NaN
	 *      R.mathMod(17, 0);   //=> NaN
	 *      R.mathMod(17.2, 5); //=> NaN
	 *      R.mathMod(17, 5.3); //=> NaN
	 *
	 *      var clock = R.mathMod(R.__, 12);
	 *      clock(15); //=> 3
	 *      clock(24); //=> 0
	 *
	 *      var seventeenMod = R.mathMod(17);
	 *      seventeenMod(3);  //=> 2
	 *      seventeenMod(4);  //=> 1
	 *      seventeenMod(10); //=> 7
	 */
	
	
	var mathMod = /*#__PURE__*/_curry2(function mathMod(m, p) {
	  if (!_isInteger(m)) {
	    return NaN;
	  }
	  if (!_isInteger(p) || p < 1) {
	    return NaN;
	  }
	  return (m % p + p) % p;
	});
	module.exports = mathMod;

/***/ },
/* 237 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/maxBy.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Takes a function and two values, and returns whichever value produces the
	 * larger result when passed to the provided function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Relation
	 * @sig Ord b => (a -> b) -> a -> a -> a
	 * @param {Function} f
	 * @param {*} a
	 * @param {*} b
	 * @return {*}
	 * @see R.max, R.minBy
	 * @example
	 *
	 *      //  square :: Number -> Number
	 *      var square = n => n * n;
	 *
	 *      R.maxBy(square, -3, 2); //=> -3
	 *
	 *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
	 *      R.reduce(R.maxBy(square), 0, []); //=> 0
	 */
	
	
	var maxBy = /*#__PURE__*/_curry3(function maxBy(f, a, b) {
	  return f(b) > f(a) ? b : a;
	});
	module.exports = maxBy;

/***/ },
/* 238 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mean.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var sum = /*#__PURE__*/__webpack_require__(/*! ./sum */ 239);
	
	/**
	 * Returns the mean of the given list of numbers.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Math
	 * @sig [Number] -> Number
	 * @param {Array} list
	 * @return {Number}
	 * @see R.median
	 * @example
	 *
	 *      R.mean([2, 7, 9]); //=> 6
	 *      R.mean([]); //=> NaN
	 */
	
	
	var mean = /*#__PURE__*/_curry1(function mean(list) {
	  return sum(list) / list.length;
	});
	module.exports = mean;

/***/ },
/* 239 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/sum.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var add = /*#__PURE__*/__webpack_require__(/*! ./add */ 30);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	/**
	 * Adds together all the elements of a list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig [Number] -> Number
	 * @param {Array} list An array of numbers
	 * @return {Number} The sum of all the numbers in the list.
	 * @see R.reduce
	 * @example
	 *
	 *      R.sum([2,4,6,8,100,1]); //=> 121
	 */
	
	
	var sum = /*#__PURE__*/reduce(add, 0);
	module.exports = sum;

/***/ },
/* 240 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/median.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var mean = /*#__PURE__*/__webpack_require__(/*! ./mean */ 238);
	
	/**
	 * Returns the median of the given list of numbers.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Math
	 * @sig [Number] -> Number
	 * @param {Array} list
	 * @return {Number}
	 * @see R.mean
	 * @example
	 *
	 *      R.median([2, 9, 7]); //=> 7
	 *      R.median([7, 2, 10, 9]); //=> 8
	 *      R.median([]); //=> NaN
	 */
	
	
	var median = /*#__PURE__*/_curry1(function median(list) {
	  var len = list.length;
	  if (len === 0) {
	    return NaN;
	  }
	  var width = 2 - len % 2;
	  var idx = (len - width) / 2;
	  return mean(Array.prototype.slice.call(list, 0).sort(function (a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	  }).slice(idx, idx + width));
	});
	module.exports = median;

/***/ },
/* 241 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/memoize.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var memoizeWith = /*#__PURE__*/__webpack_require__(/*! ./memoizeWith */ 242);
	
	var toString = /*#__PURE__*/__webpack_require__(/*! ./toString */ 114);
	
	/**
	 * Creates a new function that, when invoked, caches the result of calling `fn`
	 * for a given argument set and returns the result. Subsequent calls to the
	 * memoized `fn` with the same argument set will not result in an additional
	 * call to `fn`; instead, the cached result for that set of arguments will be
	 * returned.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (*... -> a) -> (*... -> a)
	 * @param {Function} fn The function to memoize.
	 * @return {Function} Memoized version of `fn`.
	 * @see R.memoizeWith
	 * @deprecated since v0.25.0
	 * @example
	 *
	 *      let count = 0;
	 *      const factorial = R.memoize(n => {
	 *        count += 1;
	 *        return R.product(R.range(1, n + 1));
	 *      });
	 *      factorial(5); //=> 120
	 *      factorial(5); //=> 120
	 *      factorial(5); //=> 120
	 *      count; //=> 1
	 */
	
	
	var memoize = /*#__PURE__*/memoizeWith(function () {
	  return toString(arguments);
	});
	module.exports = memoize;

/***/ },
/* 242 */
/*!************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/memoizeWith.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ 35);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	/**
	 * A customisable version of [`R.memoize`](#memoize). `memoizeWith` takes an
	 * additional function that will be applied to a given argument set and used to
	 * create the cache key under which the results of the function to be memoized
	 * will be stored. Care must be taken when implementing key generation to avoid
	 * clashes that may overwrite previous entries erroneously.
	 *
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Function
	 * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
	 * @param {Function} fn The function to generate the cache key.
	 * @param {Function} fn The function to memoize.
	 * @return {Function} Memoized version of `fn`.
	 * @see R.memoize
	 * @example
	 *
	 *      let count = 0;
	 *      const factorial = R.memoizeWith(R.identity, n => {
	 *        count += 1;
	 *        return R.product(R.range(1, n + 1));
	 *      });
	 *      factorial(5); //=> 120
	 *      factorial(5); //=> 120
	 *      factorial(5); //=> 120
	 *      count; //=> 1
	 */
	
	
	var memoizeWith = /*#__PURE__*/_curry2(function memoizeWith(mFn, fn) {
	  var cache = {};
	  return _arity(fn.length, function () {
	    var key = mFn.apply(this, arguments);
	    if (!_has(key, cache)) {
	      cache[key] = fn.apply(this, arguments);
	    }
	    return cache[key];
	  });
	});
	module.exports = memoizeWith;

/***/ },
/* 243 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/merge.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _assign = /*#__PURE__*/__webpack_require__(/*! ./internal/_assign */ 212);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Create a new object with the own properties of the first object merged with
	 * the own properties of the second object. If a key exists in both objects,
	 * the value from the second object will be used.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig {k: v} -> {k: v} -> {k: v}
	 * @param {Object} l
	 * @param {Object} r
	 * @return {Object}
	 * @see R.mergeDeepRight, R.mergeWith, R.mergeWithKey
	 * @example
	 *
	 *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
	 *      //=> { 'name': 'fred', 'age': 40 }
	 *
	 *      var resetToDefault = R.merge(R.__, {x: 0});
	 *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
	 * @symb R.merge({ x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: 5, z: 3 }
	 */
	
	
	var merge = /*#__PURE__*/_curry2(function merge(l, r) {
	  return _assign({}, l, r);
	});
	module.exports = merge;

/***/ },
/* 244 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mergeAll.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _assign = /*#__PURE__*/__webpack_require__(/*! ./internal/_assign */ 212);
	
	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Merges a list of objects together into one object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig [{k: v}] -> {k: v}
	 * @param {Array} list An array of objects
	 * @return {Object} A merged object.
	 * @see R.reduce
	 * @example
	 *
	 *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
	 *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
	 * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
	 */
	
	
	var mergeAll = /*#__PURE__*/_curry1(function mergeAll(list) {
	  return _assign.apply(null, [{}].concat(list));
	});
	module.exports = mergeAll;

/***/ },
/* 245 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mergeDeepLeft.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var mergeDeepWithKey = /*#__PURE__*/__webpack_require__(/*! ./mergeDeepWithKey */ 246);
	
	/**
	 * Creates a new object with the own properties of the first object merged with
	 * the own properties of the second object. If a key exists in both objects:
	 * - and both values are objects, the two values will be recursively merged
	 * - otherwise the value from the first object will be used.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Object
	 * @sig {a} -> {a} -> {a}
	 * @param {Object} lObj
	 * @param {Object} rObj
	 * @return {Object}
	 * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
	 * @example
	 *
	 *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
	 *                      { age: 40, contact: { email: 'baa@example.com' }});
	 *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
	 */
	
	
	var mergeDeepLeft = /*#__PURE__*/_curry2(function mergeDeepLeft(lObj, rObj) {
	  return mergeDeepWithKey(function (k, lVal, rVal) {
	    return lVal;
	  }, lObj, rObj);
	});
	module.exports = mergeDeepLeft;

/***/ },
/* 246 */
/*!*****************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mergeDeepWithKey.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var _isObject = /*#__PURE__*/__webpack_require__(/*! ./internal/_isObject */ 130);
	
	var mergeWithKey = /*#__PURE__*/__webpack_require__(/*! ./mergeWithKey */ 247);
	
	/**
	 * Creates a new object with the own properties of the two provided objects.
	 * If a key exists in both objects:
	 * - and both associated values are also objects then the values will be
	 *   recursively merged.
	 * - otherwise the provided function is applied to the key and associated values
	 *   using the resulting value as the new value associated with the key.
	 * If a key only exists in one object, the value will be associated with the key
	 * of the resulting object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Object
	 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
	 * @param {Function} fn
	 * @param {Object} lObj
	 * @param {Object} rObj
	 * @return {Object}
	 * @see R.mergeWithKey, R.mergeDeep, R.mergeDeepWith
	 * @example
	 *
	 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
	 *      R.mergeDeepWithKey(concatValues,
	 *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
	 *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
	 *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
	 */
	
	
	var mergeDeepWithKey = /*#__PURE__*/_curry3(function mergeDeepWithKey(fn, lObj, rObj) {
	  return mergeWithKey(function (k, lVal, rVal) {
	    if (_isObject(lVal) && _isObject(rVal)) {
	      return mergeDeepWithKey(fn, lVal, rVal);
	    } else {
	      return fn(k, lVal, rVal);
	    }
	  }, lObj, rObj);
	});
	module.exports = mergeDeepWithKey;

/***/ },
/* 247 */
/*!*************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mergeWithKey.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	/**
	 * Creates a new object with the own properties of the two provided objects. If
	 * a key exists in both objects, the provided function is applied to the key
	 * and the values associated with the key in each object, with the result being
	 * used as the value associated with the key in the returned object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Object
	 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
	 * @param {Function} fn
	 * @param {Object} l
	 * @param {Object} r
	 * @return {Object}
	 * @see R.mergeDeepWithKey, R.merge, R.mergeWith
	 * @example
	 *
	 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
	 *      R.mergeWithKey(concatValues,
	 *                     { a: true, thing: 'foo', values: [10, 20] },
	 *                     { b: true, thing: 'bar', values: [15, 35] });
	 *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
	 * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
	 */
	
	
	var mergeWithKey = /*#__PURE__*/_curry3(function mergeWithKey(fn, l, r) {
	  var result = {};
	  var k;
	
	  for (k in l) {
	    if (_has(k, l)) {
	      result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
	    }
	  }
	
	  for (k in r) {
	    if (_has(k, r) && !_has(k, result)) {
	      result[k] = r[k];
	    }
	  }
	
	  return result;
	});
	module.exports = mergeWithKey;

/***/ },
/* 248 */
/*!***************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mergeDeepRight.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var mergeDeepWithKey = /*#__PURE__*/__webpack_require__(/*! ./mergeDeepWithKey */ 246);
	
	/**
	 * Creates a new object with the own properties of the first object merged with
	 * the own properties of the second object. If a key exists in both objects:
	 * - and both values are objects, the two values will be recursively merged
	 * - otherwise the value from the second object will be used.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Object
	 * @sig {a} -> {a} -> {a}
	 * @param {Object} lObj
	 * @param {Object} rObj
	 * @return {Object}
	 * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
	 * @example
	 *
	 *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
	 *                       { age: 40, contact: { email: 'baa@example.com' }});
	 *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
	 */
	
	
	var mergeDeepRight = /*#__PURE__*/_curry2(function mergeDeepRight(lObj, rObj) {
	  return mergeDeepWithKey(function (k, lVal, rVal) {
	    return rVal;
	  }, lObj, rObj);
	});
	module.exports = mergeDeepRight;

/***/ },
/* 249 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mergeDeepWith.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var mergeDeepWithKey = /*#__PURE__*/__webpack_require__(/*! ./mergeDeepWithKey */ 246);
	
	/**
	 * Creates a new object with the own properties of the two provided objects.
	 * If a key exists in both objects:
	 * - and both associated values are also objects then the values will be
	 *   recursively merged.
	 * - otherwise the provided function is applied to associated values using the
	 *   resulting value as the new value associated with the key.
	 * If a key only exists in one object, the value will be associated with the key
	 * of the resulting object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Object
	 * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
	 * @param {Function} fn
	 * @param {Object} lObj
	 * @param {Object} rObj
	 * @return {Object}
	 * @see R.mergeWith, R.mergeDeep, R.mergeDeepWithKey
	 * @example
	 *
	 *      R.mergeDeepWith(R.concat,
	 *                      { a: true, c: { values: [10, 20] }},
	 *                      { b: true, c: { values: [15, 35] }});
	 *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
	 */
	
	
	var mergeDeepWith = /*#__PURE__*/_curry3(function mergeDeepWith(fn, lObj, rObj) {
	  return mergeDeepWithKey(function (k, lVal, rVal) {
	    return fn(lVal, rVal);
	  }, lObj, rObj);
	});
	module.exports = mergeDeepWith;

/***/ },
/* 250 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/mergeWith.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var mergeWithKey = /*#__PURE__*/__webpack_require__(/*! ./mergeWithKey */ 247);
	
	/**
	 * Creates a new object with the own properties of the two provided objects. If
	 * a key exists in both objects, the provided function is applied to the values
	 * associated with the key in each object, with the result being used as the
	 * value associated with the key in the returned object.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Object
	 * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
	 * @param {Function} fn
	 * @param {Object} l
	 * @param {Object} r
	 * @return {Object}
	 * @see R.mergeDeepWith, R.merge, R.mergeWithKey
	 * @example
	 *
	 *      R.mergeWith(R.concat,
	 *                  { a: true, values: [10, 20] },
	 *                  { b: true, values: [15, 35] });
	 *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
	 */
	
	
	var mergeWith = /*#__PURE__*/_curry3(function mergeWith(fn, l, r) {
	  return mergeWithKey(function (_, _l, _r) {
	    return fn(_l, _r);
	  }, l, r);
	});
	module.exports = mergeWith;

/***/ },
/* 251 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/min.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns the smaller of its two arguments.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord a => a -> a -> a
	 * @param {*} a
	 * @param {*} b
	 * @return {*}
	 * @see R.minBy, R.max
	 * @example
	 *
	 *      R.min(789, 123); //=> 123
	 *      R.min('a', 'b'); //=> 'a'
	 */
	
	
	var min = /*#__PURE__*/_curry2(function min(a, b) {
	  return b < a ? b : a;
	});
	module.exports = min;

/***/ },
/* 252 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/minBy.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Takes a function and two values, and returns whichever value produces the
	 * smaller result when passed to the provided function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Relation
	 * @sig Ord b => (a -> b) -> a -> a -> a
	 * @param {Function} f
	 * @param {*} a
	 * @param {*} b
	 * @return {*}
	 * @see R.min, R.maxBy
	 * @example
	 *
	 *      //  square :: Number -> Number
	 *      var square = n => n * n;
	 *
	 *      R.minBy(square, -3, 2); //=> 2
	 *
	 *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
	 *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
	 */
	
	
	var minBy = /*#__PURE__*/_curry3(function minBy(f, a, b) {
	  return f(b) < f(a) ? b : a;
	});
	module.exports = minBy;

/***/ },
/* 253 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/modulo.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Divides the first parameter by the second and returns the remainder. Note
	 * that this function preserves the JavaScript-style behavior for modulo. For
	 * mathematical modulo see [`mathMod`](#mathMod).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a The value to the divide.
	 * @param {Number} b The pseudo-modulus
	 * @return {Number} The result of `b % a`.
	 * @see R.mathMod
	 * @example
	 *
	 *      R.modulo(17, 3); //=> 2
	 *      // JS behavior:
	 *      R.modulo(-17, 3); //=> -2
	 *      R.modulo(17, -3); //=> 2
	 *
	 *      var isOdd = R.modulo(R.__, 2);
	 *      isOdd(42); //=> 0
	 *      isOdd(21); //=> 1
	 */
	
	
	var modulo = /*#__PURE__*/_curry2(function modulo(a, b) {
	  return a % b;
	});
	module.exports = modulo;

/***/ },
/* 254 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/multiply.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Multiplies two numbers. Equivalent to `a * b` but curried.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a The first value.
	 * @param {Number} b The second value.
	 * @return {Number} The result of `a * b`.
	 * @see R.divide
	 * @example
	 *
	 *      var double = R.multiply(2);
	 *      var triple = R.multiply(3);
	 *      double(3);       //=>  6
	 *      triple(4);       //=> 12
	 *      R.multiply(2, 5);  //=> 10
	 */
	
	
	var multiply = /*#__PURE__*/_curry2(function multiply(a, b) {
	  return a * b;
	});
	module.exports = multiply;

/***/ },
/* 255 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/negate.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Negates its argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Math
	 * @sig Number -> Number
	 * @param {Number} n
	 * @return {Number}
	 * @example
	 *
	 *      R.negate(42); //=> -42
	 */
	
	
	var negate = /*#__PURE__*/_curry1(function negate(n) {
	  return -n;
	});
	module.exports = negate;

/***/ },
/* 256 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/none.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _complement = /*#__PURE__*/__webpack_require__(/*! ./internal/_complement */ 127);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xany = /*#__PURE__*/__webpack_require__(/*! ./internal/_xany */ 65);
	
	var any = /*#__PURE__*/__webpack_require__(/*! ./any */ 64);
	
	/**
	 * Returns `true` if no elements of the list match the predicate, `false`
	 * otherwise.
	 *
	 * Dispatches to the `any` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> Boolean
	 * @param {Function} fn The predicate function.
	 * @param {Array} list The array to consider.
	 * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
	 * @see R.all, R.any
	 * @example
	 *
	 *      var isEven = n => n % 2 === 0;
	 *      var isOdd = n => n % 2 === 1;
	 *
	 *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
	 *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
	 */
	
	
	var none = /*#__PURE__*/_curry2( /*#__PURE__*/_complement( /*#__PURE__*/_dispatchable(['any'], _xany, any)));
	module.exports = none;

/***/ },
/* 257 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/nthArg.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	var nth = /*#__PURE__*/__webpack_require__(/*! ./nth */ 164);
	
	/**
	 * Returns a function which returns its nth argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category Function
	 * @sig Number -> *... -> *
	 * @param {Number} n
	 * @return {Function}
	 * @example
	 *
	 *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
	 *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
	 * @symb R.nthArg(-1)(a, b, c) = c
	 * @symb R.nthArg(0)(a, b, c) = a
	 * @symb R.nthArg(1)(a, b, c) = b
	 */
	
	
	var nthArg = /*#__PURE__*/_curry1(function nthArg(n) {
	  var arity = n < 0 ? 1 : n + 1;
	  return curryN(arity, function () {
	    return nth(n, arguments);
	  });
	});
	module.exports = nthArg;

/***/ },
/* 258 */
/*!**************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/o.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * `o` is a curried composition function that returns a unary function.
	 * Like [`compose`](#compose), `o` performs right-to-left function composition.
	 * Unlike [`compose`](#compose), the rightmost function passed to `o` will be
	 * invoked with only one argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category Function
	 * @sig (b -> c) -> (a -> b) -> a -> c
	 * @param {Function} f
	 * @param {Function} g
	 * @return {Function}
	 * @see R.compose, R.pipe
	 * @example
	 *
	 *      var classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + name.last
	 *      var yellGreeting = R.o(R.toUpper, classyGreeting);
	 *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
	 *
	 *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
	 *
	 * @symb R.o(f, g, x) = f(g(x))
	 */
	
	
	var o = /*#__PURE__*/_curry3(function o(f, g, x) {
	  return f(g(x));
	});
	module.exports = o;

/***/ },
/* 259 */
/*!***************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/of.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _of = /*#__PURE__*/__webpack_require__(/*! ./internal/_of */ 260);
	
	/**
	 * Returns a singleton array containing the value provided.
	 *
	 * Note this `of` is different from the ES6 `of`; See
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category Function
	 * @sig a -> [a]
	 * @param {*} x any value
	 * @return {Array} An array wrapping `x`.
	 * @example
	 *
	 *      R.of(null); //=> [null]
	 *      R.of([42]); //=> [[42]]
	 */
	
	
	var of = /*#__PURE__*/_curry1(_of);
	module.exports = of;

/***/ },
/* 260 */
/*!*************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_of.js ***!
  \*************************************************************************/
/***/ function(module, exports) {

	function _of(x) {
	  return [x];
	}
	module.exports = _of;

/***/ },
/* 261 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/omit.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a partial copy of an object omitting the keys specified.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig [String] -> {String: *} -> {String: *}
	 * @param {Array} names an array of String property names to omit from the new object
	 * @param {Object} obj The object to copy from
	 * @return {Object} A new object with properties from `names` not on it.
	 * @see R.pick
	 * @example
	 *
	 *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
	 */
	
	
	var omit = /*#__PURE__*/_curry2(function omit(names, obj) {
	  var result = {};
	  var index = {};
	  var idx = 0;
	  var len = names.length;
	
	  while (idx < len) {
	    index[names[idx]] = 1;
	    idx += 1;
	  }
	
	  for (var prop in obj) {
	    if (!index.hasOwnProperty(prop)) {
	      result[prop] = obj[prop];
	    }
	  }
	  return result;
	});
	module.exports = omit;

/***/ },
/* 262 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/once.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ 35);
	
	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Accepts a function `fn` and returns a function that guards invocation of
	 * `fn` such that `fn` can only ever be called once, no matter how many times
	 * the returned function is invoked. The first value calculated is returned in
	 * subsequent invocations.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (a... -> b) -> (a... -> b)
	 * @param {Function} fn The function to wrap in a call-only-once wrapper.
	 * @return {Function} The wrapped function.
	 * @example
	 *
	 *      var addOneOnce = R.once(x => x + 1);
	 *      addOneOnce(10); //=> 11
	 *      addOneOnce(addOneOnce(50)); //=> 11
	 */
	
	
	var once = /*#__PURE__*/_curry1(function once(fn) {
	  var called = false;
	  var result;
	  return _arity(fn.length, function () {
	    if (called) {
	      return result;
	    }
	    called = true;
	    result = fn.apply(this, arguments);
	    return result;
	  });
	});
	module.exports = once;

/***/ },
/* 263 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/over.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	// `Identity` is a functor that holds a single value, where `map` simply
	// transforms the held value with the provided function.
	
	
	var Identity = function (x) {
	  return { value: x, map: function (f) {
	      return Identity(f(x));
	    } };
	};
	
	/**
	 * Returns the result of "setting" the portion of the given data structure
	 * focused by the given lens to the result of applying the given function to
	 * the focused value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig Lens s a -> (a -> a) -> s -> s
	 * @param {Lens} lens
	 * @param {*} v
	 * @param {*} x
	 * @return {*}
	 * @see R.prop, R.lensIndex, R.lensProp
	 * @example
	 *
	 *      var headLens = R.lensIndex(0);
	 *
	 *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
	 */
	var over = /*#__PURE__*/_curry3(function over(lens, f, x) {
	  // The value returned by the getter function is first transformed with `f`,
	  // then set as the value of an `Identity`. This is then mapped over with the
	  // setter function of the lens.
	  return lens(function (y) {
	    return Identity(f(y));
	  })(x).value;
	});
	module.exports = over;

/***/ },
/* 264 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pair.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category List
	 * @sig a -> b -> (a,b)
	 * @param {*} fst
	 * @param {*} snd
	 * @return {Array}
	 * @see R.objOf, R.of
	 * @example
	 *
	 *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
	 */
	
	
	var pair = /*#__PURE__*/_curry2(function pair(fst, snd) {
	  return [fst, snd];
	});
	module.exports = pair;

/***/ },
/* 265 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/partial.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _createPartialApplicator = /*#__PURE__*/__webpack_require__(/*! ./internal/_createPartialApplicator */ 266);
	
	/**
	 * Takes a function `f` and a list of arguments, and returns a function `g`.
	 * When applied, `g` returns the result of applying `f` to the arguments
	 * provided initially followed by the arguments provided to `g`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Function
	 * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
	 * @param {Function} f
	 * @param {Array} args
	 * @return {Function}
	 * @see R.partialRight
	 * @example
	 *
	 *      var multiply2 = (a, b) => a * b;
	 *      var double = R.partial(multiply2, [2]);
	 *      double(2); //=> 4
	 *
	 *      var greet = (salutation, title, firstName, lastName) =>
	 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	 *
	 *      var sayHello = R.partial(greet, ['Hello']);
	 *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
	 *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
	 * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
	 */
	
	
	var partial = /*#__PURE__*/_createPartialApplicator(_concat);
	module.exports = partial;

/***/ },
/* 266 */
/*!**********************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_createPartialApplicator.js ***!
  \**********************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./_arity */ 35);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	function _createPartialApplicator(concat) {
	  return _curry2(function (fn, args) {
	    return _arity(Math.max(0, fn.length - args.length), function () {
	      return fn.apply(this, concat(args, arguments));
	    });
	  });
	}
	module.exports = _createPartialApplicator;

/***/ },
/* 267 */
/*!*************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/partialRight.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _createPartialApplicator = /*#__PURE__*/__webpack_require__(/*! ./internal/_createPartialApplicator */ 266);
	
	var flip = /*#__PURE__*/__webpack_require__(/*! ./flip */ 184);
	
	/**
	 * Takes a function `f` and a list of arguments, and returns a function `g`.
	 * When applied, `g` returns the result of applying `f` to the arguments
	 * provided to `g` followed by the arguments provided initially.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category Function
	 * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
	 * @param {Function} f
	 * @param {Array} args
	 * @return {Function}
	 * @see R.partial
	 * @example
	 *
	 *      var greet = (salutation, title, firstName, lastName) =>
	 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
	 *
	 *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
	 *
	 *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
	 * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
	 */
	
	
	var partialRight = /*#__PURE__*/_createPartialApplicator( /*#__PURE__*/flip(_concat));
	module.exports = partialRight;

/***/ },
/* 268 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/partition.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var filter = /*#__PURE__*/__webpack_require__(/*! ./filter */ 128);
	
	var juxt = /*#__PURE__*/__webpack_require__(/*! ./juxt */ 221);
	
	var reject = /*#__PURE__*/__webpack_require__(/*! ./reject */ 126);
	
	/**
	 * Takes a predicate and a list or other `Filterable` object and returns the
	 * pair of filterable objects of the same type of elements which do and do not
	 * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
	 * that has a filter method such as `Array`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.4
	 * @category List
	 * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
	 * @param {Function} pred A predicate to determine which side the element belongs to.
	 * @param {Array} filterable the list (or other filterable) to partition.
	 * @return {Array} An array, containing first the subset of elements that satisfy the
	 *         predicate, and second the subset of elements that do not satisfy.
	 * @see R.filter, R.reject
	 * @example
	 *
	 *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
	 *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
	 *
	 *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
	 *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
	 */
	
	
	var partition = /*#__PURE__*/juxt([filter, reject]);
	module.exports = partition;

/***/ },
/* 269 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pathEq.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	var path = /*#__PURE__*/__webpack_require__(/*! ./path */ 61);
	
	/**
	 * Determines whether a nested path on an object has a specific value, in
	 * [`R.equals`](#equals) terms. Most likely used to filter a list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category Relation
	 * @typedefn Idx = String | Int
	 * @sig [Idx] -> a -> {a} -> Boolean
	 * @param {Array} path The path of the nested property to use
	 * @param {*} val The value to compare the nested property with
	 * @param {Object} obj The object to check the nested property in
	 * @return {Boolean} `true` if the value equals the nested object property,
	 *         `false` otherwise.
	 * @example
	 *
	 *      var user1 = { address: { zipCode: 90210 } };
	 *      var user2 = { address: { zipCode: 55555 } };
	 *      var user3 = { name: 'Bob' };
	 *      var users = [ user1, user2, user3 ];
	 *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
	 *      R.filter(isFamous, users); //=> [ user1 ]
	 */
	
	
	var pathEq = /*#__PURE__*/_curry3(function pathEq(_path, val, obj) {
	  return equals(path(_path, obj), val);
	});
	module.exports = pathEq;

/***/ },
/* 270 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pathOr.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var defaultTo = /*#__PURE__*/__webpack_require__(/*! ./defaultTo */ 141);
	
	var path = /*#__PURE__*/__webpack_require__(/*! ./path */ 61);
	
	/**
	 * If the given, non-null object has a value at the given path, returns the
	 * value at that path. Otherwise returns the provided default value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Object
	 * @typedefn Idx = String | Int
	 * @sig a -> [Idx] -> {a} -> a
	 * @param {*} d The default value.
	 * @param {Array} p The path to use.
	 * @param {Object} obj The object to retrieve the nested property from.
	 * @return {*} The data at `path` of the supplied object or the default value.
	 * @example
	 *
	 *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
	 *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
	 */
	
	
	var pathOr = /*#__PURE__*/_curry3(function pathOr(d, p, obj) {
	  return defaultTo(d, path(p, obj));
	});
	module.exports = pathOr;

/***/ },
/* 271 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pathSatisfies.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var path = /*#__PURE__*/__webpack_require__(/*! ./path */ 61);
	
	/**
	 * Returns `true` if the specified object property at given path satisfies the
	 * given predicate; `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Logic
	 * @typedefn Idx = String | Int
	 * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
	 * @param {Function} pred
	 * @param {Array} propPath
	 * @param {*} obj
	 * @return {Boolean}
	 * @see R.propSatisfies, R.path
	 * @example
	 *
	 *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
	 */
	
	
	var pathSatisfies = /*#__PURE__*/_curry3(function pathSatisfies(pred, propPath, obj) {
	  return propPath.length > 0 && pred(path(propPath, obj));
	});
	module.exports = pathSatisfies;

/***/ },
/* 272 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pick.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a partial copy of an object containing only the keys specified. If
	 * the key does not exist, the property is ignored.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig [k] -> {k: v} -> {k: v}
	 * @param {Array} names an array of String property names to copy onto a new object
	 * @param {Object} obj The object to copy from
	 * @return {Object} A new object with only properties from `names` on it.
	 * @see R.omit, R.props
	 * @example
	 *
	 *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	 *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
	 */
	
	
	var pick = /*#__PURE__*/_curry2(function pick(names, obj) {
	  var result = {};
	  var idx = 0;
	  while (idx < names.length) {
	    if (names[idx] in obj) {
	      result[names[idx]] = obj[names[idx]];
	    }
	    idx += 1;
	  }
	  return result;
	});
	module.exports = pick;

/***/ },
/* 273 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pickAll.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Similar to `pick` except that this one includes a `key: undefined` pair for
	 * properties that don't exist.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig [k] -> {k: v} -> {k: v}
	 * @param {Array} names an array of String property names to copy onto a new object
	 * @param {Object} obj The object to copy from
	 * @return {Object} A new object with only properties from `names` on it.
	 * @see R.pick
	 * @example
	 *
	 *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
	 *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
	 */
	
	
	var pickAll = /*#__PURE__*/_curry2(function pickAll(names, obj) {
	  var result = {};
	  var idx = 0;
	  var len = names.length;
	  while (idx < len) {
	    var name = names[idx];
	    result[name] = obj[name];
	    idx += 1;
	  }
	  return result;
	});
	module.exports = pickAll;

/***/ },
/* 274 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pickBy.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a partial copy of an object containing only the keys that satisfy
	 * the supplied predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Object
	 * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
	 * @param {Function} pred A predicate to determine whether or not a key
	 *        should be included on the output object.
	 * @param {Object} obj The object to copy from
	 * @return {Object} A new object with only properties that satisfy `pred`
	 *         on it.
	 * @see R.pick, R.filter
	 * @example
	 *
	 *      var isUpperCase = (val, key) => key.toUpperCase() === key;
	 *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
	 */
	
	
	var pickBy = /*#__PURE__*/_curry2(function pickBy(test, obj) {
	  var result = {};
	  for (var prop in obj) {
	    if (test(obj[prop], prop, obj)) {
	      result[prop] = obj[prop];
	    }
	  }
	  return result;
	});
	module.exports = pickBy;

/***/ },
/* 275 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/pipeK.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var composeK = /*#__PURE__*/__webpack_require__(/*! ./composeK */ 109);
	
	var reverse = /*#__PURE__*/__webpack_require__(/*! ./reverse */ 108);
	
	/**
	 * Returns the left-to-right Kleisli composition of the provided functions,
	 * each of which must return a value of a type supported by [`chain`](#chain).
	 *
	 * `R.pipeK(f, g, h)` is equivalent to `R.pipe(f, R.chain(g), R.chain(h))`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Function
	 * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
	 * @param {...Function}
	 * @return {Function}
	 * @see R.composeK
	 * @example
	 *
	 *      //  parseJson :: String -> Maybe *
	 *      //  get :: String -> Object -> Maybe *
	 *
	 *      //  getStateCode :: Maybe String -> Maybe String
	 *      var getStateCode = R.pipeK(
	 *        parseJson,
	 *        get('user'),
	 *        get('address'),
	 *        get('state'),
	 *        R.compose(Maybe.of, R.toUpper)
	 *      );
	 *
	 *      getStateCode('{"user":{"address":{"state":"ny"}}}');
	 *      //=> Just('NY')
	 *      getStateCode('[Invalid JSON]');
	 *      //=> Nothing()
	 * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
	 */
	
	
	function pipeK() {
	  if (arguments.length === 0) {
	    throw new Error('pipeK requires at least one argument');
	  }
	  return composeK.apply(this, reverse(arguments));
	}
	module.exports = pipeK;

/***/ },
/* 276 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/prepend.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a new list with the given element at the front, followed by the
	 * contents of the list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig a -> [a] -> [a]
	 * @param {*} el The item to add to the head of the output list.
	 * @param {Array} list The array to add to the tail of the output list.
	 * @return {Array} A new array.
	 * @see R.append
	 * @example
	 *
	 *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
	 */
	
	
	var prepend = /*#__PURE__*/_curry2(function prepend(el, list) {
	  return _concat([el], list);
	});
	module.exports = prepend;

/***/ },
/* 277 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/product.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var multiply = /*#__PURE__*/__webpack_require__(/*! ./multiply */ 254);
	
	var reduce = /*#__PURE__*/__webpack_require__(/*! ./reduce */ 62);
	
	/**
	 * Multiplies together all the elements of a list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig [Number] -> Number
	 * @param {Array} list An array of numbers
	 * @return {Number} The product of all the numbers in the list.
	 * @see R.reduce
	 * @example
	 *
	 *      R.product([2,4,6,8,100,1]); //=> 38400
	 */
	
	
	var product = /*#__PURE__*/reduce(multiply, 1);
	module.exports = product;

/***/ },
/* 278 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/project.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _map = /*#__PURE__*/__webpack_require__(/*! ./internal/_map */ 50);
	
	var identity = /*#__PURE__*/__webpack_require__(/*! ./identity */ 195);
	
	var pickAll = /*#__PURE__*/__webpack_require__(/*! ./pickAll */ 273);
	
	var useWith = /*#__PURE__*/__webpack_require__(/*! ./useWith */ 279);
	
	/**
	 * Reasonable analog to SQL `select` statement.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @category Relation
	 * @sig [k] -> [{k: v}] -> [{k: v}]
	 * @param {Array} props The property names to project
	 * @param {Array} objs The objects to query
	 * @return {Array} An array of objects with just the `props` properties.
	 * @example
	 *
	 *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
	 *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
	 *      var kids = [abby, fred];
	 *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
	 */
	
	
	var project = /*#__PURE__*/useWith(_map, [pickAll, identity]); // passing `identity` gives correct arity
	module.exports = project;

/***/ },
/* 279 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/useWith.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	/**
	 * Accepts a function `fn` and a list of transformer functions and returns a
	 * new curried function. When the new function is invoked, it calls the
	 * function `fn` with parameters consisting of the result of calling each
	 * supplied handler on successive arguments to the new function.
	 *
	 * If more arguments are passed to the returned function than transformer
	 * functions, those arguments are passed directly to `fn` as additional
	 * parameters. If you expect additional arguments that don't need to be
	 * transformed, although you can ignore them, it's best to pass an identity
	 * function so that the new function reports the correct arity.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
	 * @param {Function} fn The function to wrap.
	 * @param {Array} transformers A list of transformer functions
	 * @return {Function} The wrapped function.
	 * @see R.converge
	 * @example
	 *
	 *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
	 *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
	 *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
	 *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
	 * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
	 */
	
	
	var useWith = /*#__PURE__*/_curry2(function useWith(fn, transformers) {
	  return curryN(transformers.length, function () {
	    var args = [];
	    var idx = 0;
	    while (idx < transformers.length) {
	      args.push(transformers[idx].call(this, arguments[idx]));
	      idx += 1;
	    }
	    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
	  });
	});
	module.exports = useWith;

/***/ },
/* 280 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/propEq.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	/**
	 * Returns `true` if the specified object property is equal, in
	 * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
	 * You can test multiple properties with [`R.where`](#where).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig String -> a -> Object -> Boolean
	 * @param {String} name
	 * @param {*} val
	 * @param {*} obj
	 * @return {Boolean}
	 * @see R.whereEq, R.propSatisfies, R.equals
	 * @example
	 *
	 *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
	 *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
	 *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
	 *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
	 *      var kids = [abby, fred, rusty, alois];
	 *      var hasBrownHair = R.propEq('hair', 'brown');
	 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
	 */
	
	
	var propEq = /*#__PURE__*/_curry3(function propEq(name, val, obj) {
	  return equals(val, obj[name]);
	});
	module.exports = propEq;

/***/ },
/* 281 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/propIs.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var is = /*#__PURE__*/__webpack_require__(/*! ./is */ 218);
	
	/**
	 * Returns `true` if the specified object property is of the given type;
	 * `false` otherwise.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Type
	 * @sig Type -> String -> Object -> Boolean
	 * @param {Function} type
	 * @param {String} name
	 * @param {*} obj
	 * @return {Boolean}
	 * @see R.is, R.propSatisfies
	 * @example
	 *
	 *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
	 *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
	 *      R.propIs(Number, 'x', {});            //=> false
	 */
	
	
	var propIs = /*#__PURE__*/_curry3(function propIs(type, name, obj) {
	  return is(type, obj[name]);
	});
	module.exports = propIs;

/***/ },
/* 282 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/propOr.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	/**
	 * If the given, non-null object has an own property with the specified name,
	 * returns the value of that property. Otherwise returns the provided default
	 * value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.6.0
	 * @category Object
	 * @sig a -> String -> Object -> a
	 * @param {*} val The default value.
	 * @param {String} p The name of the property to return.
	 * @param {Object} obj The object to query.
	 * @return {*} The value of given property of the supplied object or the default value.
	 * @example
	 *
	 *      var alice = {
	 *        name: 'ALICE',
	 *        age: 101
	 *      };
	 *      var favorite = R.prop('favoriteLibrary');
	 *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
	 *
	 *      favorite(alice);  //=> undefined
	 *      favoriteWithDefault(alice);  //=> 'Ramda'
	 */
	
	
	var propOr = /*#__PURE__*/_curry3(function propOr(val, p, obj) {
	  return obj != null && _has(p, obj) ? obj[p] : val;
	});
	module.exports = propOr;

/***/ },
/* 283 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/propSatisfies.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Returns `true` if the specified object property satisfies the given
	 * predicate; `false` otherwise. You can test multiple properties with
	 * [`R.where`](#where).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Logic
	 * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
	 * @param {Function} pred
	 * @param {String} name
	 * @param {*} obj
	 * @return {Boolean}
	 * @see R.where, R.propEq, R.propIs
	 * @example
	 *
	 *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
	 */
	
	
	var propSatisfies = /*#__PURE__*/_curry3(function propSatisfies(pred, name, obj) {
	  return pred(obj[name]);
	});
	module.exports = propSatisfies;

/***/ },
/* 284 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/props.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Acts as multiple `prop`: array of keys in, array of values out. Preserves
	 * order.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Object
	 * @sig [k] -> {k: v} -> [v]
	 * @param {Array} ps The property names to fetch
	 * @param {Object} obj The object to query
	 * @return {Array} The corresponding values or partially applied function.
	 * @example
	 *
	 *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
	 *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
	 *
	 *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
	 *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
	 */
	
	
	var props = /*#__PURE__*/_curry2(function props(ps, obj) {
	  var len = ps.length;
	  var out = [];
	  var idx = 0;
	
	  while (idx < len) {
	    out[idx] = obj[ps[idx]];
	    idx += 1;
	  }
	
	  return out;
	});
	module.exports = props;

/***/ },
/* 285 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/range.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isNumber = /*#__PURE__*/__webpack_require__(/*! ./internal/_isNumber */ 225);
	
	/**
	 * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig Number -> Number -> [Number]
	 * @param {Number} from The first number in the list.
	 * @param {Number} to One more than the last number in the list.
	 * @return {Array} The list of numbers in tthe set `[a, b)`.
	 * @example
	 *
	 *      R.range(1, 5);    //=> [1, 2, 3, 4]
	 *      R.range(50, 53);  //=> [50, 51, 52]
	 */
	
	
	var range = /*#__PURE__*/_curry2(function range(from, to) {
	  if (!(_isNumber(from) && _isNumber(to))) {
	    throw new TypeError('Both arguments to range must be numbers');
	  }
	  var result = [];
	  var n = from;
	  while (n < to) {
	    result.push(n);
	    n += 1;
	  }
	  return result;
	});
	module.exports = range;

/***/ },
/* 286 */
/*!************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/reduceRight.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Returns a single item by iterating through the list, successively calling
	 * the iterator function and passing it an accumulator value and the current
	 * value from the array, and then passing the result to the next call.
	 *
	 * Similar to [`reduce`](#reduce), except moves through the input list from the
	 * right to the left.
	 *
	 * The iterator function receives two values: *(value, acc)*, while the arguments'
	 * order of `reduce`'s iterator function is *(acc, value)*.
	 *
	 * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
	 * arrays), unlike the native `Array.prototype.reduceRight` method. For more details
	 * on this behavior, see:
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig ((a, b) -> b) -> b -> [a] -> b
	 * @param {Function} fn The iterator function. Receives two values, the current element from the array
	 *        and the accumulator.
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.reduce, R.addIndex
	 * @example
	 *
	 *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
	 *      //    -               -2
	 *      //   / \              / \
	 *      //  1   -            1   3
	 *      //     / \              / \
	 *      //    2   -     ==>    2  -1
	 *      //       / \              / \
	 *      //      3   -            3   4
	 *      //         / \              / \
	 *      //        4   0            4   0
	 *
	 * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
	 */
	
	
	var reduceRight = /*#__PURE__*/_curry3(function reduceRight(fn, acc, list) {
	  var idx = list.length - 1;
	  while (idx >= 0) {
	    acc = fn(list[idx], acc);
	    idx -= 1;
	  }
	  return acc;
	});
	module.exports = reduceRight;

/***/ },
/* 287 */
/*!************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/reduceWhile.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curryN = /*#__PURE__*/__webpack_require__(/*! ./internal/_curryN */ 36);
	
	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var _reduced = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduced */ 44);
	
	/**
	 * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
	 * through the list, successively calling the iterator function. `reduceWhile`
	 * also takes a predicate that is evaluated before each step. If the predicate
	 * returns `false`, it "short-circuits" the iteration and returns the current
	 * value of the accumulator.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.22.0
	 * @category List
	 * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
	 * @param {Function} pred The predicate. It is passed the accumulator and the
	 *        current element.
	 * @param {Function} fn The iterator function. Receives two values, the
	 *        accumulator and the current element.
	 * @param {*} a The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.reduce, R.reduced
	 * @example
	 *
	 *      var isOdd = (acc, x) => x % 2 === 1;
	 *      var xs = [1, 3, 5, 60, 777, 800];
	 *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
	 *
	 *      var ys = [2, 4, 6]
	 *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
	 */
	
	
	var reduceWhile = /*#__PURE__*/_curryN(4, [], function _reduceWhile(pred, fn, a, list) {
	  return _reduce(function (acc, x) {
	    return pred(acc, x) ? fn(acc, x) : _reduced(acc);
	  }, a, list);
	});
	module.exports = reduceWhile;

/***/ },
/* 288 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/reduced.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _reduced = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduced */ 44);
	
	/**
	 * Returns a value wrapped to indicate that it is the final value of the reduce
	 * and transduce functions. The returned value should be considered a black
	 * box: the internal structure is not guaranteed to be stable.
	 *
	 * Note: this optimization is unavailable to functions not explicitly listed
	 * above. For instance, it is not currently supported by
	 * [`reduceRight`](#reduceRight).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.15.0
	 * @category List
	 * @sig a -> *
	 * @param {*} x The final value of the reduce.
	 * @return {*} The wrapped value.
	 * @see R.reduce, R.transduce
	 * @example
	 *
	 *     R.reduce(
	 *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
	 *       [],
	 *       [1, 2, 3, 4, 5]) // [1, 2, 3]
	 */
	
	
	var reduced = /*#__PURE__*/_curry1(_reduced);
	module.exports = reduced;

/***/ },
/* 289 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/repeat.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var always = /*#__PURE__*/__webpack_require__(/*! ./always */ 25);
	
	var times = /*#__PURE__*/__webpack_require__(/*! ./times */ 290);
	
	/**
	 * Returns a fixed list of size `n` containing a specified identical value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category List
	 * @sig a -> n -> [a]
	 * @param {*} value The value to repeat.
	 * @param {Number} n The desired size of the output list.
	 * @return {Array} A new array containing `n` `value`s.
	 * @see R.times
	 * @example
	 *
	 *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
	 *
	 *      var obj = {};
	 *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
	 *      repeatedObjs[0] === repeatedObjs[1]; //=> true
	 * @symb R.repeat(a, 0) = []
	 * @symb R.repeat(a, 1) = [a]
	 * @symb R.repeat(a, 2) = [a, a]
	 */
	
	
	var repeat = /*#__PURE__*/_curry2(function repeat(value, n) {
	  return times(always(value), n);
	});
	module.exports = repeat;

/***/ },
/* 290 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/times.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Calls an input function `n` times, returning an array containing the results
	 * of those function calls.
	 *
	 * `fn` is passed one argument: The current value of `n`, which begins at `0`
	 * and is gradually incremented to `n - 1`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.3
	 * @category List
	 * @sig (Number -> a) -> Number -> [a]
	 * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
	 * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
	 * @return {Array} An array containing the return values of all calls to `fn`.
	 * @see R.repeat
	 * @example
	 *
	 *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
	 * @symb R.times(f, 0) = []
	 * @symb R.times(f, 1) = [f(0)]
	 * @symb R.times(f, 2) = [f(0), f(1)]
	 */
	
	
	var times = /*#__PURE__*/_curry2(function times(fn, n) {
	  var len = Number(n);
	  var idx = 0;
	  var list;
	
	  if (len < 0 || isNaN(len)) {
	    throw new RangeError('n must be a non-negative number');
	  }
	  list = new Array(len);
	  while (idx < len) {
	    list[idx] = fn(idx);
	    idx += 1;
	  }
	  return list;
	});
	module.exports = times;

/***/ },
/* 291 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/replace.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Replace a substring or regex match in a string with a replacement.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.7.0
	 * @category String
	 * @sig RegExp|String -> String -> String -> String
	 * @param {RegExp|String} pattern A regular expression or a substring to match.
	 * @param {String} replacement The string to replace the matches with.
	 * @param {String} str The String to do the search and replacement in.
	 * @return {String} The result.
	 * @example
	 *
	 *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
	 *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
	 *
	 *      // Use the "g" (global) flag to replace all occurrences:
	 *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
	 */
	
	
	var replace = /*#__PURE__*/_curry3(function replace(regex, replacement, str) {
	  return str.replace(regex, replacement);
	});
	module.exports = replace;

/***/ },
/* 292 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/scan.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Scan is similar to [`reduce`](#reduce), but returns a list of successively
	 * reduced values from the left
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig ((a, b) -> a) -> a -> [b] -> [a]
	 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	 *        current element from the array
	 * @param {*} acc The accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {Array} A list of all intermediately reduced values.
	 * @see R.reduce
	 * @example
	 *
	 *      var numbers = [1, 2, 3, 4];
	 *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
	 * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
	 */
	
	
	var scan = /*#__PURE__*/_curry3(function scan(fn, acc, list) {
	  var idx = 0;
	  var len = list.length;
	  var result = [acc];
	  while (idx < len) {
	    acc = fn(acc, list[idx]);
	    result[idx + 1] = acc;
	    idx += 1;
	  }
	  return result;
	});
	module.exports = scan;

/***/ },
/* 293 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/sequence.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var ap = /*#__PURE__*/__webpack_require__(/*! ./ap */ 67);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	var prepend = /*#__PURE__*/__webpack_require__(/*! ./prepend */ 276);
	
	var reduceRight = /*#__PURE__*/__webpack_require__(/*! ./reduceRight */ 286);
	
	/**
	 * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
	 * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
	 * Applicative of Traversable.
	 *
	 * Dispatches to the `sequence` method of the second argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
	 * @param {Function} of
	 * @param {*} traversable
	 * @return {*}
	 * @see R.traverse
	 * @example
	 *
	 *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
	 *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
	 *
	 *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
	 *      R.sequence(R.of, Nothing());       //=> [Nothing()]
	 */
	
	
	var sequence = /*#__PURE__*/_curry2(function sequence(of, traversable) {
	  return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (x, acc) {
	    return ap(map(prepend, x), acc);
	  }, of([]), traversable);
	});
	module.exports = sequence;

/***/ },
/* 294 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/set.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var always = /*#__PURE__*/__webpack_require__(/*! ./always */ 25);
	
	var over = /*#__PURE__*/__webpack_require__(/*! ./over */ 263);
	
	/**
	 * Returns the result of "setting" the portion of the given data structure
	 * focused by the given lens to the given value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig Lens s a -> a -> s -> s
	 * @param {Lens} lens
	 * @param {*} v
	 * @param {*} x
	 * @return {*}
	 * @see R.prop, R.lensIndex, R.lensProp
	 * @example
	 *
	 *      var xLens = R.lensProp('x');
	 *
	 *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
	 *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
	 */
	
	
	var set = /*#__PURE__*/_curry3(function set(lens, v, x) {
	  return over(lens, always(v), x);
	});
	module.exports = set;

/***/ },
/* 295 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/sort.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a copy of the list, sorted according to the comparator function,
	 * which should accept two values at a time and return a negative number if the
	 * first value is smaller, a positive number if it's larger, and zero if they
	 * are equal. Please note that this is a **copy** of the list. It does not
	 * modify the original.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig ((a, a) -> Number) -> [a] -> [a]
	 * @param {Function} comparator A sorting function :: a -> b -> Int
	 * @param {Array} list The list to sort
	 * @return {Array} a new array with its elements sorted by the comparator function.
	 * @example
	 *
	 *      var diff = function(a, b) { return a - b; };
	 *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
	 */
	
	
	var sort = /*#__PURE__*/_curry2(function sort(comparator, list) {
	  return Array.prototype.slice.call(list, 0).sort(comparator);
	});
	module.exports = sort;

/***/ },
/* 296 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/sortBy.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Sorts the list according to the supplied function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig Ord b => (a -> b) -> [a] -> [a]
	 * @param {Function} fn
	 * @param {Array} list The list to sort.
	 * @return {Array} A new list sorted by the keys generated by `fn`.
	 * @example
	 *
	 *      var sortByFirstItem = R.sortBy(R.prop(0));
	 *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
	 *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
	 *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
	 *      var alice = {
	 *        name: 'ALICE',
	 *        age: 101
	 *      };
	 *      var bob = {
	 *        name: 'Bob',
	 *        age: -10
	 *      };
	 *      var clara = {
	 *        name: 'clara',
	 *        age: 314.159
	 *      };
	 *      var people = [clara, bob, alice];
	 *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
	 */
	
	
	var sortBy = /*#__PURE__*/_curry2(function sortBy(fn, list) {
	  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
	    var aa = fn(a);
	    var bb = fn(b);
	    return aa < bb ? -1 : aa > bb ? 1 : 0;
	  });
	});
	module.exports = sortBy;

/***/ },
/* 297 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/sortWith.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Sorts a list according to a list of comparators.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.23.0
	 * @category Relation
	 * @sig [(a, a) -> Number] -> [a] -> [a]
	 * @param {Array} functions A list of comparator functions.
	 * @param {Array} list The list to sort.
	 * @return {Array} A new list sorted according to the comarator functions.
	 * @example
	 *
	 *      var alice = {
	 *        name: 'alice',
	 *        age: 40
	 *      };
	 *      var bob = {
	 *        name: 'bob',
	 *        age: 30
	 *      };
	 *      var clara = {
	 *        name: 'clara',
	 *        age: 40
	 *      };
	 *      var people = [clara, bob, alice];
	 *      var ageNameSort = R.sortWith([
	 *        R.descend(R.prop('age')),
	 *        R.ascend(R.prop('name'))
	 *      ]);
	 *      ageNameSort(people); //=> [alice, clara, bob]
	 */
	
	
	var sortWith = /*#__PURE__*/_curry2(function sortWith(fns, list) {
	  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
	    var result = 0;
	    var i = 0;
	    while (result === 0 && i < fns.length) {
	      result = fns[i](a, b);
	      i += 1;
	    }
	    return result;
	  });
	});
	module.exports = sortWith;

/***/ },
/* 298 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/split.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var invoker = /*#__PURE__*/__webpack_require__(/*! ./invoker */ 217);
	
	/**
	 * Splits a string into an array of strings based on the given
	 * separator.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category String
	 * @sig (String | RegExp) -> String -> [String]
	 * @param {String|RegExp} sep The pattern.
	 * @param {String} str The string to separate into an array.
	 * @return {Array} The array of strings from `str` separated by `str`.
	 * @see R.join
	 * @example
	 *
	 *      var pathComponents = R.split('/');
	 *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
	 *
	 *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
	 */
	
	
	var split = /*#__PURE__*/invoker(1, 'split');
	module.exports = split;

/***/ },
/* 299 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/splitAt.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var length = /*#__PURE__*/__webpack_require__(/*! ./length */ 224);
	
	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Splits a given list or string at a given index.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig Number -> [a] -> [[a], [a]]
	 * @sig Number -> String -> [String, String]
	 * @param {Number} index The index where the array/string is split.
	 * @param {Array|String} array The array/string to be split.
	 * @return {Array}
	 * @example
	 *
	 *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
	 *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
	 *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
	 */
	
	
	var splitAt = /*#__PURE__*/_curry2(function splitAt(index, array) {
	  return [slice(0, index, array), slice(index, length(array), array)];
	});
	module.exports = splitAt;

/***/ },
/* 300 */
/*!***********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/splitEvery.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Splits a collection into slices of the specified length.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig Number -> [a] -> [[a]]
	 * @sig Number -> String -> [String]
	 * @param {Number} n
	 * @param {Array} list
	 * @return {Array}
	 * @example
	 *
	 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
	 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
	 */
	
	
	var splitEvery = /*#__PURE__*/_curry2(function splitEvery(n, list) {
	  if (n <= 0) {
	    throw new Error('First argument to splitEvery must be a positive integer');
	  }
	  var result = [];
	  var idx = 0;
	  while (idx < list.length) {
	    result.push(slice(idx, idx += n, list));
	  }
	  return result;
	});
	module.exports = splitEvery;

/***/ },
/* 301 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/splitWhen.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Takes a list and a predicate and returns a pair of lists with the following properties:
	 *
	 *  - the result of concatenating the two output lists is equivalent to the input list;
	 *  - none of the elements of the first output list satisfies the predicate; and
	 *  - if the second output list is non-empty, its first element satisfies the predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [[a], [a]]
	 * @param {Function} pred The predicate that determines where the array is split.
	 * @param {Array} list The array to be split.
	 * @return {Array}
	 * @example
	 *
	 *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
	 */
	
	
	var splitWhen = /*#__PURE__*/_curry2(function splitWhen(pred, list) {
	  var idx = 0;
	  var len = list.length;
	  var prefix = [];
	
	  while (idx < len && !pred(list[idx])) {
	    prefix.push(list[idx]);
	    idx += 1;
	  }
	
	  return [prefix, Array.prototype.slice.call(list, idx)];
	});
	module.exports = splitWhen;

/***/ },
/* 302 */
/*!***********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/startsWith.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	var take = /*#__PURE__*/__webpack_require__(/*! ./take */ 154);
	
	/**
	 * Checks if a list starts with the provided values
	 *
	 * @func
	 * @memberOf R
	 * @since v0.24.0
	 * @category List
	 * @sig [a] -> Boolean
	 * @sig String -> Boolean
	 * @param {*} prefix
	 * @param {*} list
	 * @return {Boolean}
	 * @example
	 *
	 *      R.startsWith('a', 'abc')                //=> true
	 *      R.startsWith('b', 'abc')                //=> false
	 *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
	 *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
	 */
	
	
	var startsWith = /*#__PURE__*/_curry2(function (prefix, list) {
	  return equals(take(prefix.length, list), prefix);
	});
	module.exports = startsWith;

/***/ },
/* 303 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/subtract.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Subtracts its second argument from its first argument.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Math
	 * @sig Number -> Number -> Number
	 * @param {Number} a The first value.
	 * @param {Number} b The second value.
	 * @return {Number} The result of `a - b`.
	 * @see R.add
	 * @example
	 *
	 *      R.subtract(10, 8); //=> 2
	 *
	 *      var minus5 = R.subtract(R.__, 5);
	 *      minus5(17); //=> 12
	 *
	 *      var complementaryAngle = R.subtract(90);
	 *      complementaryAngle(30); //=> 60
	 *      complementaryAngle(72); //=> 18
	 */
	
	
	var subtract = /*#__PURE__*/_curry2(function subtract(a, b) {
	  return Number(a) - Number(b);
	});
	module.exports = subtract;

/***/ },
/* 304 */
/*!********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/symmetricDifference.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var concat = /*#__PURE__*/__webpack_require__(/*! ./concat */ 113);
	
	var difference = /*#__PURE__*/__webpack_require__(/*! ./difference */ 143);
	
	/**
	 * Finds the set (i.e. no duplicates) of all elements contained in the first or
	 * second list, but not both.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Relation
	 * @sig [*] -> [*] -> [*]
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The elements in `list1` or `list2`, but not both.
	 * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
	 * @example
	 *
	 *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
	 *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
	 */
	
	
	var symmetricDifference = /*#__PURE__*/_curry2(function symmetricDifference(list1, list2) {
	  return concat(difference(list1, list2), difference(list2, list1));
	});
	module.exports = symmetricDifference;

/***/ },
/* 305 */
/*!************************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/symmetricDifferenceWith.js ***!
  \************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var concat = /*#__PURE__*/__webpack_require__(/*! ./concat */ 113);
	
	var differenceWith = /*#__PURE__*/__webpack_require__(/*! ./differenceWith */ 144);
	
	/**
	 * Finds the set (i.e. no duplicates) of all elements contained in the first or
	 * second list, but not both. Duplication is determined according to the value
	 * returned by applying the supplied predicate to two list elements.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category Relation
	 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The elements in `list1` or `list2`, but not both.
	 * @see R.symmetricDifference, R.difference, R.differenceWith
	 * @example
	 *
	 *      var eqA = R.eqBy(R.prop('a'));
	 *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
	 *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
	 *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
	 */
	
	
	var symmetricDifferenceWith = /*#__PURE__*/_curry3(function symmetricDifferenceWith(pred, list1, list2) {
	  return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
	});
	module.exports = symmetricDifferenceWith;

/***/ },
/* 306 */
/*!**************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/takeLastWhile.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Returns a new list containing the last `n` elements of a given list, passing
	 * each value to the supplied predicate function, and terminating when the
	 * predicate function returns `false`. Excludes the element that caused the
	 * predicate function to fail. The predicate function is passed one argument:
	 * *(value)*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [a]
	 * @sig (a -> Boolean) -> String -> String
	 * @param {Function} fn The function called per iteration.
	 * @param {Array} xs The collection to iterate over.
	 * @return {Array} A new array.
	 * @see R.dropLastWhile, R.addIndex
	 * @example
	 *
	 *      var isNotOne = x => x !== 1;
	 *
	 *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
	 *
	 *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
	 */
	
	
	var takeLastWhile = /*#__PURE__*/_curry2(function takeLastWhile(fn, xs) {
	  var idx = xs.length - 1;
	  while (idx >= 0 && fn(xs[idx])) {
	    idx -= 1;
	  }
	  return slice(idx + 1, Infinity, xs);
	});
	module.exports = takeLastWhile;

/***/ },
/* 307 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/takeWhile.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xtakeWhile = /*#__PURE__*/__webpack_require__(/*! ./internal/_xtakeWhile */ 308);
	
	var slice = /*#__PURE__*/__webpack_require__(/*! ./slice */ 107);
	
	/**
	 * Returns a new list containing the first `n` elements of a given list,
	 * passing each value to the supplied predicate function, and terminating when
	 * the predicate function returns `false`. Excludes the element that caused the
	 * predicate function to fail. The predicate function is passed one argument:
	 * *(value)*.
	 *
	 * Dispatches to the `takeWhile` method of the second argument, if present.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig (a -> Boolean) -> [a] -> [a]
	 * @sig (a -> Boolean) -> String -> String
	 * @param {Function} fn The function called per iteration.
	 * @param {Array} xs The collection to iterate over.
	 * @return {Array} A new array.
	 * @see R.dropWhile, R.transduce, R.addIndex
	 * @example
	 *
	 *      var isNotFour = x => x !== 4;
	 *
	 *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
	 *
	 *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
	 */
	
	
	var takeWhile = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['takeWhile'], _xtakeWhile, function takeWhile(fn, xs) {
	  var idx = 0;
	  var len = xs.length;
	  while (idx < len && fn(xs[idx])) {
	    idx += 1;
	  }
	  return slice(0, idx, xs);
	}));
	module.exports = takeWhile;

/***/ },
/* 308 */
/*!*********************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xtakeWhile.js ***!
  \*********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _reduced = /*#__PURE__*/__webpack_require__(/*! ./_reduced */ 44);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XTakeWhile = /*#__PURE__*/function () {
	
	  function XTakeWhile(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }
	  XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
	  XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
	  XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
	    return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
	  };
	
	  return XTakeWhile;
	}();
	
	var _xtakeWhile = /*#__PURE__*/_curry2(function _xtakeWhile(f, xf) {
	  return new XTakeWhile(f, xf);
	});
	module.exports = _xtakeWhile;

/***/ },
/* 309 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/tap.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ 40);
	
	var _xtap = /*#__PURE__*/__webpack_require__(/*! ./internal/_xtap */ 310);
	
	/**
	 * Runs the given function with the supplied object, then returns the object.
	 *
	 * Acts as a transducer if a transformer is given as second parameter.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Function
	 * @sig (a -> *) -> a -> a
	 * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
	 * @param {*} x
	 * @return {*} `x`.
	 * @example
	 *
	 *      var sayX = x => console.log('x is ' + x);
	 *      R.tap(sayX, 100); //=> 100
	 *      // logs 'x is 100'
	 * @symb R.tap(f, a) = a
	 */
	
	
	var tap = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xtap, function tap(fn, x) {
	  fn(x);
	  return x;
	}));
	module.exports = tap;

/***/ },
/* 310 */
/*!***************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_xtap.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ 31);
	
	var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ 45);
	
	var XTap = /*#__PURE__*/function () {
	
	  function XTap(f, xf) {
	    this.xf = xf;
	    this.f = f;
	  }
	  XTap.prototype['@@transducer/init'] = _xfBase.init;
	  XTap.prototype['@@transducer/result'] = _xfBase.result;
	  XTap.prototype['@@transducer/step'] = function (result, input) {
	    this.f(input);
	    return this.xf['@@transducer/step'](result, input);
	  };
	
	  return XTap;
	}();
	
	var _xtap = /*#__PURE__*/_curry2(function _xtap(f, xf) {
	  return new XTap(f, xf);
	});
	module.exports = _xtap;

/***/ },
/* 311 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/test.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _cloneRegExp = /*#__PURE__*/__webpack_require__(/*! ./internal/_cloneRegExp */ 97);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _isRegExp = /*#__PURE__*/__webpack_require__(/*! ./internal/_isRegExp */ 312);
	
	var toString = /*#__PURE__*/__webpack_require__(/*! ./toString */ 114);
	
	/**
	 * Determines whether a given string matches a given regular expression.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category String
	 * @sig RegExp -> String -> Boolean
	 * @param {RegExp} pattern
	 * @param {String} str
	 * @return {Boolean}
	 * @see R.match
	 * @example
	 *
	 *      R.test(/^x/, 'xyz'); //=> true
	 *      R.test(/^y/, 'xyz'); //=> false
	 */
	
	
	var test = /*#__PURE__*/_curry2(function test(pattern, str) {
	  if (!_isRegExp(pattern)) {
	    throw new TypeError('test requires a value of type RegExp as its first argument; received ' + toString(pattern));
	  }
	  return _cloneRegExp(pattern).test(str);
	});
	module.exports = test;

/***/ },
/* 312 */
/*!*******************************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/internal/_isRegExp.js ***!
  \*******************************************************************************/
/***/ function(module, exports) {

	function _isRegExp(x) {
	  return Object.prototype.toString.call(x) === '[object RegExp]';
	}
	module.exports = _isRegExp;

/***/ },
/* 313 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/toLower.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var invoker = /*#__PURE__*/__webpack_require__(/*! ./invoker */ 217);
	
	/**
	 * The lower case version of a string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category String
	 * @sig String -> String
	 * @param {String} str The string to lower case.
	 * @return {String} The lower case version of `str`.
	 * @see R.toUpper
	 * @example
	 *
	 *      R.toLower('XYZ'); //=> 'xyz'
	 */
	
	
	var toLower = /*#__PURE__*/invoker(0, 'toLowerCase');
	module.exports = toLower;

/***/ },
/* 314 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/toPairs.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	/**
	 * Converts an object into an array of key, value arrays. Only the object's
	 * own properties are used.
	 * Note that the order of the output array is not guaranteed to be consistent
	 * across different JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.4.0
	 * @category Object
	 * @sig {String: *} -> [[String,*]]
	 * @param {Object} obj The object to extract from
	 * @return {Array} An array of key, value arrays from the object's own properties.
	 * @see R.fromPairs
	 * @example
	 *
	 *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
	 */
	
	
	var toPairs = /*#__PURE__*/_curry1(function toPairs(obj) {
	  var pairs = [];
	  for (var prop in obj) {
	    if (_has(prop, obj)) {
	      pairs[pairs.length] = [prop, obj[prop]];
	    }
	  }
	  return pairs;
	});
	module.exports = toPairs;

/***/ },
/* 315 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/toPairsIn.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Converts an object into an array of key, value arrays. The object's own
	 * properties and prototype properties are used. Note that the order of the
	 * output array is not guaranteed to be consistent across different JS
	 * platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.4.0
	 * @category Object
	 * @sig {String: *} -> [[String,*]]
	 * @param {Object} obj The object to extract from
	 * @return {Array} An array of key, value arrays from the object's own
	 *         and prototype properties.
	 * @example
	 *
	 *      var F = function() { this.x = 'X'; };
	 *      F.prototype.y = 'Y';
	 *      var f = new F();
	 *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
	 */
	
	
	var toPairsIn = /*#__PURE__*/_curry1(function toPairsIn(obj) {
	  var pairs = [];
	  for (var prop in obj) {
	    pairs[pairs.length] = [prop, obj[prop]];
	  }
	  return pairs;
	});
	module.exports = toPairsIn;

/***/ },
/* 316 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/toUpper.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var invoker = /*#__PURE__*/__webpack_require__(/*! ./invoker */ 217);
	
	/**
	 * The upper case version of a string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.9.0
	 * @category String
	 * @sig String -> String
	 * @param {String} str The string to upper case.
	 * @return {String} The upper case version of `str`.
	 * @see R.toLower
	 * @example
	 *
	 *      R.toUpper('abc'); //=> 'ABC'
	 */
	
	
	var toUpper = /*#__PURE__*/invoker(0, 'toUpperCase');
	module.exports = toUpper;

/***/ },
/* 317 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/transduce.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ 51);
	
	var _xwrap = /*#__PURE__*/__webpack_require__(/*! ./internal/_xwrap */ 54);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	/**
	 * Initializes a transducer using supplied iterator function. Returns a single
	 * item by iterating through the list, successively calling the transformed
	 * iterator function and passing it an accumulator value and the current value
	 * from the array, and then passing the result to the next call.
	 *
	 * The iterator function receives two values: *(acc, value)*. It will be
	 * wrapped as a transformer to initialize the transducer. A transformer can be
	 * passed directly in place of an iterator function. In both cases, iteration
	 * may be stopped early with the [`R.reduced`](#reduced) function.
	 *
	 * A transducer is a function that accepts a transformer and returns a
	 * transformer and can be composed directly.
	 *
	 * A transformer is an an object that provides a 2-arity reducing iterator
	 * function, step, 0-arity initial value function, init, and 1-arity result
	 * extraction function, result. The step function is used as the iterator
	 * function in reduce. The result function is used to convert the final
	 * accumulator into the return type and in most cases is
	 * [`R.identity`](#identity). The init function can be used to provide an
	 * initial accumulator, but is ignored by transduce.
	 *
	 * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.12.0
	 * @category List
	 * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
	 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
	 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
	 *        current element from the array. Wrapped as transformer, if necessary, and used to
	 *        initialize the transducer
	 * @param {*} acc The initial accumulator value.
	 * @param {Array} list The list to iterate over.
	 * @return {*} The final, accumulated value.
	 * @see R.reduce, R.reduced, R.into
	 * @example
	 *
	 *      var numbers = [1, 2, 3, 4];
	 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
	 *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
	 *
	 *      var isOdd = (x) => x % 2 === 1;
	 *      var firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
	 *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
	 */
	
	
	var transduce = /*#__PURE__*/curryN(4, function transduce(xf, fn, acc, list) {
	  return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
	});
	module.exports = transduce;

/***/ },
/* 318 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/transpose.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Transposes the rows and columns of a 2D list.
	 * When passed a list of `n` lists of length `x`,
	 * returns a list of `x` lists of length `n`.
	 *
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig [[a]] -> [[a]]
	 * @param {Array} list A 2D list
	 * @return {Array} A 2D list
	 * @example
	 *
	 *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
	 *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	 *
	 *      // If some of the rows are shorter than the following rows, their elements are skipped:
	 *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
	 * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
	 * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
	 * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
	 */
	
	
	var transpose = /*#__PURE__*/_curry1(function transpose(outerlist) {
	  var i = 0;
	  var result = [];
	  while (i < outerlist.length) {
	    var innerlist = outerlist[i];
	    var j = 0;
	    while (j < innerlist.length) {
	      if (typeof result[j] === 'undefined') {
	        result[j] = [];
	      }
	      result[j].push(innerlist[j]);
	      j += 1;
	    }
	    i += 1;
	  }
	  return result;
	});
	module.exports = transpose;

/***/ },
/* 319 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/traverse.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	var sequence = /*#__PURE__*/__webpack_require__(/*! ./sequence */ 293);
	
	/**
	 * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
	 * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
	 * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
	 * into an Applicative of Traversable.
	 *
	 * Dispatches to the `traverse` method of the third argument, if present.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
	 * @param {Function} of
	 * @param {Function} f
	 * @param {*} traversable
	 * @return {*}
	 * @see R.sequence
	 * @example
	 *
	 *      // Returns `Nothing` if the given divisor is `0`
	 *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
	 *
	 *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
	 *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
	 */
	
	
	var traverse = /*#__PURE__*/_curry3(function traverse(of, f, traversable) {
	  return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](f, of) : sequence(of, map(f, traversable));
	});
	module.exports = traverse;

/***/ },
/* 320 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/trim.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
	var zeroWidth = '\u200b';
	var hasProtoTrim = typeof String.prototype.trim === 'function';
	/**
	 * Removes (strips) whitespace from both ends of the string.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.6.0
	 * @category String
	 * @sig String -> String
	 * @param {String} str The string to trim.
	 * @return {String} Trimmed version of `str`.
	 * @example
	 *
	 *      R.trim('   xyz  '); //=> 'xyz'
	 *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
	 */
	var _trim = !hasProtoTrim || /*#__PURE__*/ws.trim() || ! /*#__PURE__*/zeroWidth.trim() ? function trim(str) {
	  var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
	  var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
	  return str.replace(beginRx, '').replace(endRx, '');
	} : function trim(str) {
	  return str.trim();
	};
	var trim = /*#__PURE__*/_curry1(_trim);
	module.exports = trim;

/***/ },
/* 321 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/tryCatch.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ 35);
	
	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
	 * function evaluates the `tryer`; if it does not throw, it simply returns the
	 * result. If the `tryer` *does* throw, the returned function evaluates the
	 * `catcher` function and returns its result. Note that for effective
	 * composition with this function, both the `tryer` and `catcher` functions
	 * must return the same type of results.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category Function
	 * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
	 * @param {Function} tryer The function that may throw.
	 * @param {Function} catcher The function that will be evaluated if `tryer` throws.
	 * @return {Function} A new function that will catch exceptions and send then to the catcher.
	 * @example
	 *
	 *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
	 *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
	 */
	
	
	var tryCatch = /*#__PURE__*/_curry2(function _tryCatch(tryer, catcher) {
	  return _arity(tryer.length, function () {
	    try {
	      return tryer.apply(this, arguments);
	    } catch (e) {
	      return catcher.apply(this, _concat([e], arguments));
	    }
	  });
	});
	module.exports = tryCatch;

/***/ },
/* 322 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/unapply.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Takes a function `fn`, which takes a single array argument, and returns a
	 * function which:
	 *
	 *   - takes any number of positional arguments;
	 *   - passes these arguments to `fn` as an array; and
	 *   - returns the result.
	 *
	 * In other words, `R.unapply` derives a variadic function from a function which
	 * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.8.0
	 * @category Function
	 * @sig ([*...] -> a) -> (*... -> a)
	 * @param {Function} fn
	 * @return {Function}
	 * @see R.apply
	 * @example
	 *
	 *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
	 * @symb R.unapply(f)(a, b) = f([a, b])
	 */
	
	
	var unapply = /*#__PURE__*/_curry1(function unapply(fn) {
	  return function () {
	    return fn(Array.prototype.slice.call(arguments, 0));
	  };
	});
	module.exports = unapply;

/***/ },
/* 323 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/unary.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	var nAry = /*#__PURE__*/__webpack_require__(/*! ./nAry */ 82);
	
	/**
	 * Wraps a function of any arity (including nullary) in a function that accepts
	 * exactly 1 parameter. Any extraneous parameters will not be passed to the
	 * supplied function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Function
	 * @sig (* -> b) -> (a -> b)
	 * @param {Function} fn The function to wrap.
	 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
	 *         arity 1.
	 * @see R.binary, R.nAry
	 * @example
	 *
	 *      var takesTwoArgs = function(a, b) {
	 *        return [a, b];
	 *      };
	 *      takesTwoArgs.length; //=> 2
	 *      takesTwoArgs(1, 2); //=> [1, 2]
	 *
	 *      var takesOneArg = R.unary(takesTwoArgs);
	 *      takesOneArg.length; //=> 1
	 *      // Only 1 argument is passed to the wrapped function
	 *      takesOneArg(1, 2); //=> [1, undefined]
	 * @symb R.unary(f)(a, b, c) = f(a)
	 */
	
	
	var unary = /*#__PURE__*/_curry1(function unary(fn) {
	  return nAry(1, fn);
	});
	module.exports = unary;

/***/ },
/* 324 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/uncurryN.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ 34);
	
	/**
	 * Returns a function of arity `n` from a (manually) curried function.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Function
	 * @sig Number -> (a -> b) -> (a -> c)
	 * @param {Number} length The arity for the returned function.
	 * @param {Function} fn The function to uncurry.
	 * @return {Function} A new function.
	 * @see R.curry
	 * @example
	 *
	 *      var addFour = a => b => c => d => a + b + c + d;
	 *
	 *      var uncurriedAddFour = R.uncurryN(4, addFour);
	 *      uncurriedAddFour(1, 2, 3, 4); //=> 10
	 */
	
	
	var uncurryN = /*#__PURE__*/_curry2(function uncurryN(depth, fn) {
	  return curryN(depth, function () {
	    var currentDepth = 1;
	    var value = fn;
	    var idx = 0;
	    var endIdx;
	    while (currentDepth <= depth && typeof value === 'function') {
	      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
	      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
	      currentDepth += 1;
	      idx = endIdx;
	    }
	    return value;
	  });
	});
	module.exports = uncurryN;

/***/ },
/* 325 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/unfold.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Builds a list from a seed value. Accepts an iterator function, which returns
	 * either false to stop iteration or an array of length 2 containing the value
	 * to add to the resulting list and the seed to be used in the next call to the
	 * iterator function.
	 *
	 * The iterator function receives one argument: *(seed)*.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.10.0
	 * @category List
	 * @sig (a -> [b]) -> * -> [b]
	 * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
	 *        either false to quit iteration or an array of length two to proceed. The element
	 *        at index 0 of this array will be added to the resulting array, and the element
	 *        at index 1 will be passed to the next call to `fn`.
	 * @param {*} seed The seed value.
	 * @return {Array} The final list.
	 * @example
	 *
	 *      var f = n => n > 50 ? false : [-n, n + 10];
	 *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
	 * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
	 */
	
	
	var unfold = /*#__PURE__*/_curry2(function unfold(fn, seed) {
	  var pair = fn(seed);
	  var result = [];
	  while (pair && pair.length) {
	    result[result.length] = pair[0];
	    pair = fn(pair[1]);
	  }
	  return result;
	});
	module.exports = unfold;

/***/ },
/* 326 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/union.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var compose = /*#__PURE__*/__webpack_require__(/*! ./compose */ 102);
	
	var uniq = /*#__PURE__*/__webpack_require__(/*! ./uniq */ 206);
	
	/**
	 * Combines two lists into a set (i.e. no duplicates) composed of the elements
	 * of each list.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig [*] -> [*] -> [*]
	 * @param {Array} as The first list.
	 * @param {Array} bs The second list.
	 * @return {Array} The first and second lists concatenated, with
	 *         duplicates removed.
	 * @example
	 *
	 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
	 */
	
	
	var union = /*#__PURE__*/_curry2( /*#__PURE__*/compose(uniq, _concat));
	module.exports = union;

/***/ },
/* 327 */
/*!**********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/unionWith.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ 33);
	
	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	var uniqWith = /*#__PURE__*/__webpack_require__(/*! ./uniqWith */ 328);
	
	/**
	 * Combines two lists into a set (i.e. no duplicates) composed of the elements
	 * of each list. Duplication is determined according to the value returned by
	 * applying the supplied predicate to two list elements.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category Relation
	 * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list1 The first list.
	 * @param {Array} list2 The second list.
	 * @return {Array} The first and second lists concatenated, with
	 *         duplicates removed.
	 * @see R.union
	 * @example
	 *
	 *      var l1 = [{a: 1}, {a: 2}];
	 *      var l2 = [{a: 1}, {a: 4}];
	 *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
	 */
	
	
	var unionWith = /*#__PURE__*/_curry3(function unionWith(pred, list1, list2) {
	  return uniqWith(pred, _concat(list1, list2));
	});
	module.exports = unionWith;

/***/ },
/* 328 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/uniqWith.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _containsWith = /*#__PURE__*/__webpack_require__(/*! ./internal/_containsWith */ 121);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Returns a new list containing only one copy of each element in the original
	 * list, based upon the value returned by applying the supplied predicate to
	 * two list elements. Prefers the first item if two items compare equal based
	 * on the predicate.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category List
	 * @sig ((a, a) -> Boolean) -> [a] -> [a]
	 * @param {Function} pred A predicate used to test whether two items are equal.
	 * @param {Array} list The array to consider.
	 * @return {Array} The list of unique items.
	 * @example
	 *
	 *      var strEq = R.eqBy(String);
	 *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
	 *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
	 *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
	 *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
	 */
	
	
	var uniqWith = /*#__PURE__*/_curry2(function uniqWith(pred, list) {
	  var idx = 0;
	  var len = list.length;
	  var result = [];
	  var item;
	  while (idx < len) {
	    item = list[idx];
	    if (!_containsWith(pred, item, result)) {
	      result[result.length] = item;
	    }
	    idx += 1;
	  }
	  return result;
	});
	module.exports = uniqWith;

/***/ },
/* 329 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/unless.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Tests the final argument by passing it to the given predicate function. If
	 * the predicate is not satisfied, the function will return the result of
	 * calling the `whenFalseFn` function with the same argument. If the predicate
	 * is satisfied, the argument is returned as is.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Logic
	 * @sig (a -> Boolean) -> (a -> a) -> a -> a
	 * @param {Function} pred        A predicate function
	 * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
	 *                               to a falsy value.
	 * @param {*}        x           An object to test with the `pred` function and
	 *                               pass to `whenFalseFn` if necessary.
	 * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
	 * @see R.ifElse, R.when
	 * @example
	 *
	 *      let safeInc = R.unless(R.isNil, R.inc);
	 *      safeInc(null); //=> null
	 *      safeInc(1); //=> 2
	 */
	
	
	var unless = /*#__PURE__*/_curry3(function unless(pred, whenFalseFn, x) {
	  return pred(x) ? x : whenFalseFn(x);
	});
	module.exports = unless;

/***/ },
/* 330 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/unnest.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _identity = /*#__PURE__*/__webpack_require__(/*! ./internal/_identity */ 196);
	
	var chain = /*#__PURE__*/__webpack_require__(/*! ./chain */ 89);
	
	/**
	 * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
	 * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig Chain c => c (c a) -> c a
	 * @param {*} list
	 * @return {*}
	 * @see R.flatten, R.chain
	 * @example
	 *
	 *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
	 *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
	 */
	
	
	var unnest = /*#__PURE__*/chain(_identity);
	module.exports = unnest;

/***/ },
/* 331 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/until.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Takes a predicate, a transformation function, and an initial value,
	 * and returns a value of the same type as the initial value.
	 * It does so by applying the transformation until the predicate is satisfied,
	 * at which point it returns the satisfactory value.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.20.0
	 * @category Logic
	 * @sig (a -> Boolean) -> (a -> a) -> a -> a
	 * @param {Function} pred A predicate function
	 * @param {Function} fn The iterator function
	 * @param {*} init Initial value
	 * @return {*} Final value that satisfies predicate
	 * @example
	 *
	 *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
	 */
	
	
	var until = /*#__PURE__*/_curry3(function until(pred, fn, init) {
	  var val = init;
	  while (!pred(val)) {
	    val = fn(val);
	  }
	  return val;
	});
	module.exports = until;

/***/ },
/* 332 */
/*!*********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/valuesIn.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ 26);
	
	/**
	 * Returns a list of all the properties, including prototype properties, of the
	 * supplied object.
	 * Note that the order of the output array is not guaranteed to be consistent
	 * across different JS platforms.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.2.0
	 * @category Object
	 * @sig {k: v} -> [v]
	 * @param {Object} obj The object to extract values from
	 * @return {Array} An array of the values of the object's own and prototype properties.
	 * @see R.values, R.keysIn
	 * @example
	 *
	 *      var F = function() { this.x = 'X'; };
	 *      F.prototype.y = 'Y';
	 *      var f = new F();
	 *      R.valuesIn(f); //=> ['X', 'Y']
	 */
	
	
	var valuesIn = /*#__PURE__*/_curry1(function valuesIn(obj) {
	  var prop;
	  var vs = [];
	  for (prop in obj) {
	    vs[vs.length] = obj[prop];
	  }
	  return vs;
	});
	module.exports = valuesIn;

/***/ },
/* 333 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/view.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	// `Const` is a functor that effectively ignores the function given to `map`.
	
	
	var Const = function (x) {
	  return { value: x, 'fantasy-land/map': function () {
	      return this;
	    } };
	};
	
	/**
	 * Returns a "view" of the given data structure, determined by the given lens.
	 * The lens's focus determines which portion of the data structure is visible.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.16.0
	 * @category Object
	 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
	 * @sig Lens s a -> s -> a
	 * @param {Lens} lens
	 * @param {*} x
	 * @return {*}
	 * @see R.prop, R.lensIndex, R.lensProp
	 * @example
	 *
	 *      var xLens = R.lensProp('x');
	 *
	 *      R.view(xLens, {x: 1, y: 2});  //=> 1
	 *      R.view(xLens, {x: 4, y: 2});  //=> 4
	 */
	var view = /*#__PURE__*/_curry2(function view(lens, x) {
	  // Using `Const` effectively ignores the setter function of the `lens`,
	  // leaving the value returned by the getter function unmodified.
	  return lens(Const)(x).value;
	});
	module.exports = view;

/***/ },
/* 334 */
/*!*****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/when.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Tests the final argument by passing it to the given predicate function. If
	 * the predicate is satisfied, the function will return the result of calling
	 * the `whenTrueFn` function with the same argument. If the predicate is not
	 * satisfied, the argument is returned as is.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.18.0
	 * @category Logic
	 * @sig (a -> Boolean) -> (a -> a) -> a -> a
	 * @param {Function} pred       A predicate function
	 * @param {Function} whenTrueFn A function to invoke when the `condition`
	 *                              evaluates to a truthy value.
	 * @param {*}        x          An object to test with the `pred` function and
	 *                              pass to `whenTrueFn` if necessary.
	 * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
	 * @see R.ifElse, R.unless
	 * @example
	 *
	 *      // truncate :: String -> String
	 *      var truncate = R.when(
	 *        R.propSatisfies(R.gt(R.__, 10), 'length'),
	 *        R.pipe(R.take(10), R.append(''), R.join(''))
	 *      );
	 *      truncate('12345');         //=> '12345'
	 *      truncate('0123456789ABC'); //=> '0123456789'
	 */
	
	
	var when = /*#__PURE__*/_curry3(function when(pred, whenTrueFn, x) {
	  return pred(x) ? whenTrueFn(x) : x;
	});
	module.exports = when;

/***/ },
/* 335 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/where.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ 58);
	
	/**
	 * Takes a spec object and a test object; returns true if the test satisfies
	 * the spec. Each of the spec's own properties must be a predicate function.
	 * Each predicate is applied to the value of the corresponding property of the
	 * test object. `where` returns true if all the predicates return true, false
	 * otherwise.
	 *
	 * `where` is well suited to declaratively expressing constraints for other
	 * functions such as [`filter`](#filter) and [`find`](#find).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.1
	 * @category Object
	 * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
	 * @param {Object} spec
	 * @param {Object} testObj
	 * @return {Boolean}
	 * @see R.propSatisfies, R.whereEq
	 * @example
	 *
	 *      // pred :: Object -> Boolean
	 *      var pred = R.where({
	 *        a: R.equals('foo'),
	 *        b: R.complement(R.equals('bar')),
	 *        x: R.gt(R.__, 10),
	 *        y: R.lt(R.__, 20)
	 *      });
	 *
	 *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
	 *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
	 *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
	 *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
	 *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
	 */
	
	
	var where = /*#__PURE__*/_curry2(function where(spec, testObj) {
	  for (var prop in spec) {
	    if (_has(prop, spec) && !spec[prop](testObj[prop])) {
	      return false;
	    }
	  }
	  return true;
	});
	module.exports = where;

/***/ },
/* 336 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/whereEq.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var equals = /*#__PURE__*/__webpack_require__(/*! ./equals */ 118);
	
	var map = /*#__PURE__*/__webpack_require__(/*! ./map */ 49);
	
	var where = /*#__PURE__*/__webpack_require__(/*! ./where */ 335);
	
	/**
	 * Takes a spec object and a test object; returns true if the test satisfies
	 * the spec, false otherwise. An object satisfies the spec if, for each of the
	 * spec's own properties, accessing that property of the object gives the same
	 * value (in [`R.equals`](#equals) terms) as accessing that property of the
	 * spec.
	 *
	 * `whereEq` is a specialization of [`where`](#where).
	 *
	 * @func
	 * @memberOf R
	 * @since v0.14.0
	 * @category Object
	 * @sig {String: *} -> {String: *} -> Boolean
	 * @param {Object} spec
	 * @param {Object} testObj
	 * @return {Boolean}
	 * @see R.propEq, R.where
	 * @example
	 *
	 *      // pred :: Object -> Boolean
	 *      var pred = R.whereEq({a: 1, b: 2});
	 *
	 *      pred({a: 1});              //=> false
	 *      pred({a: 1, b: 2});        //=> true
	 *      pred({a: 1, b: 2, c: 3});  //=> true
	 *      pred({a: 1, b: 1});        //=> false
	 */
	
	
	var whereEq = /*#__PURE__*/_curry2(function whereEq(spec, testObj) {
	  return where(map(equals, spec), testObj);
	});
	module.exports = whereEq;

/***/ },
/* 337 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/without.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _contains = /*#__PURE__*/__webpack_require__(/*! ./internal/_contains */ 116);
	
	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	var flip = /*#__PURE__*/__webpack_require__(/*! ./flip */ 184);
	
	var reject = /*#__PURE__*/__webpack_require__(/*! ./reject */ 126);
	
	/**
	 * Returns a new list without values in the first argument.
	 * [`R.equals`](#equals) is used to determine equality.
	 *
	 * Acts as a transducer if a transformer is given in list position.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.19.0
	 * @category List
	 * @sig [a] -> [a] -> [a]
	 * @param {Array} list1 The values to be removed from `list2`.
	 * @param {Array} list2 The array to remove values from.
	 * @return {Array} The new array without values in `list1`.
	 * @see R.transduce, R.difference
	 * @example
	 *
	 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
	 */
	
	
	var without = /*#__PURE__*/_curry2(function (xs, list) {
	  return reject(flip(_contains)(xs), list);
	});
	module.exports = without;

/***/ },
/* 338 */
/*!******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/xprod.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Creates a new list out of the two supplied by creating each possible pair
	 * from the lists.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [b] -> [[a,b]]
	 * @param {Array} as The first list.
	 * @param {Array} bs The second list.
	 * @return {Array} The list made by combining each possible pair from
	 *         `as` and `bs` into pairs (`[a, b]`).
	 * @example
	 *
	 *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
	 * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
	 */
	
	
	var xprod = /*#__PURE__*/_curry2(function xprod(a, b) {
	  // = xprodWith(prepend); (takes about 3 times as long...)
	  var idx = 0;
	  var ilen = a.length;
	  var j;
	  var jlen = b.length;
	  var result = [];
	  while (idx < ilen) {
	    j = 0;
	    while (j < jlen) {
	      result[result.length] = [a[idx], b[j]];
	      j += 1;
	    }
	    idx += 1;
	  }
	  return result;
	});
	module.exports = xprod;

/***/ },
/* 339 */
/*!****************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/zip.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Creates a new list out of the two supplied by pairing up equally-positioned
	 * items from both lists. The returned list is truncated to the length of the
	 * shorter of the two input lists.
	 * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig [a] -> [b] -> [[a,b]]
	 * @param {Array} list1 The first array to consider.
	 * @param {Array} list2 The second array to consider.
	 * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
	 * @example
	 *
	 *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
	 * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
	 */
	
	
	var zip = /*#__PURE__*/_curry2(function zip(a, b) {
	  var rv = [];
	  var idx = 0;
	  var len = Math.min(a.length, b.length);
	  while (idx < len) {
	    rv[idx] = [a[idx], b[idx]];
	    idx += 1;
	  }
	  return rv;
	});
	module.exports = zip;

/***/ },
/* 340 */
/*!*******************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/zipObj.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ 31);
	
	/**
	 * Creates a new object out of a list of keys and a list of values.
	 * Key/value pairing is truncated to the length of the shorter of the two lists.
	 * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.
	 *
	 * @func
	 * @memberOf R
	 * @since v0.3.0
	 * @category List
	 * @sig [String] -> [*] -> {String: *}
	 * @param {Array} keys The array that will be properties on the output object.
	 * @param {Array} values The list of values on the output object.
	 * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
	 * @example
	 *
	 *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
	 */
	
	
	var zipObj = /*#__PURE__*/_curry2(function zipObj(keys, values) {
	  var idx = 0;
	  var len = Math.min(keys.length, values.length);
	  var out = {};
	  while (idx < len) {
	    out[keys[idx]] = values[idx];
	    idx += 1;
	  }
	  return out;
	});
	module.exports = zipObj;

/***/ },
/* 341 */
/*!********************************************************************!*\
  !*** ../~/.registry.npmjs.org/ramda/0.25.0/~/ramda/src/zipWith.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ 38);
	
	/**
	 * Creates a new list out of the two supplied by applying the function to each
	 * equally-positioned pair in the lists. The returned list is truncated to the
	 * length of the shorter of the two input lists.
	 *
	 * @function
	 * @memberOf R
	 * @since v0.1.0
	 * @category List
	 * @sig ((a, b) -> c) -> [a] -> [b] -> [c]
	 * @param {Function} fn The function used to combine the two elements into one value.
	 * @param {Array} list1 The first array to consider.
	 * @param {Array} list2 The second array to consider.
	 * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
	 *         using `fn`.
	 * @example
	 *
	 *      var f = (x, y) => {
	 *        // ...
	 *      };
	 *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
	 *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
	 * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
	 */
	
	
	var zipWith = /*#__PURE__*/_curry3(function zipWith(fn, a, b) {
	  var rv = [];
	  var idx = 0;
	  var len = Math.min(a.length, b.length);
	  while (idx < len) {
	    rv[idx] = fn(a[idx], b[idx]);
	    idx += 1;
	  }
	  return rv;
	});
	module.exports = zipWith;

/***/ },
/* 342 */
/*!************************************!*\
  !*** ./transpile/errorBoundary.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(/*! react */ 2);
	
	var React = _interopRequireDefault(_react).default;
	
	var Component = _react.Component;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var errorBoundary = function errorBoundary(Element, errorCallback) {
	  return function (_React$Component) {
	    _inherits(ErrorBoundary, _React$Component);
	
	    function ErrorBoundary() {
	      _classCallCheck(this, ErrorBoundary);
	
	      return _possibleConstructorReturn(this, (ErrorBoundary.__proto__ || Object.getPrototypeOf(ErrorBoundary)).apply(this, arguments));
	    }
	
	    _createClass(ErrorBoundary, [{
	      key: 'componentDidCatch',
	      value: function componentDidCatch(error) {
	        errorCallback(error);
	      }
	    }, {
	      key: 'render',
	      value: function render() {
	        return typeof Element === 'function' ? React.createElement(Element, this.props) : Element;
	      }
	    }]);
	
	    return ErrorBoundary;
	  }(React.Component);
	};
	
	exports.default = errorBoundary;

/***/ },
/* 343 */
/*!*******************************!*\
  !*** ./transpile/evalCode.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(/*! react */ 2);
	
	var React = _interopRequireDefault(_react).default;
	
	var _transform = __webpack_require__(/*! ./transform */ 13);
	
	var _poly = _transform._poly;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var evalCode = function evalCode(code, scope) {
	  var scopeKeys = Object.keys(scope);
	  var scopeValues = scopeKeys.map(function (key) {
	    return scope[key];
	  });
	  var res = new (Function.prototype.bind.apply(Function, [null].concat(['_poly', 'React'], _toConsumableArray(scopeKeys), [code])))();
	  return res.apply(undefined, [_poly, React].concat(_toConsumableArray(scopeValues)));
	};
	
	exports.default = evalCode;

/***/ }
/******/ ]);
//# sourceMappingURL=http://127.0.0.1:8080/build/bundle.js.map